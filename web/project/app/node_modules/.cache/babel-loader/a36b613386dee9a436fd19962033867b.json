{"ast":null,"code":"var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\");\n\nvar fixShadow = require(\"./fixShadow\");\n\nvar _constant = require(\"../constant\");\n\nvar ContextCachedBy = _constant.ContextCachedBy;\nvar WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;\nvar DEFAULT_FONT = textContain.DEFAULT_FONT; // TODO: Have not support 'start', 'end' yet.\n\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n}; // Different from `STYLE_COMMON_PROPS` of `graphic/Style`,\n// the default value of shadowColor is `'transparent'`.\n\nvar SHADOW_STYLE_COMMON_PROPS = [['textShadowBlur', 'shadowBlur', 0], ['textShadowOffsetX', 'shadowOffsetX', 0], ['textShadowOffsetY', 'shadowOffsetY', 0], ['textShadowColor', 'shadowColor', 'transparent']];\nvar _tmpTextPositionResult = {};\nvar _tmpBoxPositionResult = {};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n * @param {Element|module:zrender/graphic/helper/constant.WILL_BE_RESTORED} [prevEl] For ctx prop cache.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect, prevEl) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);\n} // Avoid setting to ctx according to prevEl if possible for\n// performance in scenarios of large amount text.\n\n\nfunction renderPlainText(hostEl, ctx, text, style, rect, prevEl) {\n  'use strict';\n\n  var needDrawBg = needDrawBackground(style);\n  var prevStyle;\n  var checkCache = false;\n  var cachedByMe = ctx.__attrCachedBy === ContextCachedBy.PLAIN_TEXT; // Only take and check cache for `Text` el, but not RectText.\n\n  if (prevEl !== WILL_BE_RESTORED) {\n    if (prevEl) {\n      prevStyle = prevEl.style;\n      checkCache = !needDrawBg && cachedByMe && prevStyle;\n    } // Prevent from using cache in `Style::bind`, because of the case:\n    // ctx property is modified by other properties than `Style::bind`\n    // used, and Style::bind is called next.\n\n\n    ctx.__attrCachedBy = needDrawBg ? ContextCachedBy.NONE : ContextCachedBy.PLAIN_TEXT;\n  } // Since this will be restored, prevent from using these props to check cache in the next\n  // entering of this method. But do not need to clear other cache like `Style::bind`.\n  else if (cachedByMe) {\n    ctx.__attrCachedBy = ContextCachedBy.NONE;\n  }\n\n  var styleFont = style.font || DEFAULT_FONT; // PENDING\n  // Only `Text` el set `font` and keep it (`RectText` will restore). So theoretically\n  // we can make font cache on ctx, which can cache for text el that are discontinuous.\n  // But layer save/restore needed to be considered.\n  // if (styleFont !== ctx.__fontCache) {\n  //     ctx.font = styleFont;\n  //     if (prevEl !== WILL_BE_RESTORED) {\n  //         ctx.__fontCache = styleFont;\n  //     }\n  // }\n\n  if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT)) {\n    ctx.font = styleFont;\n  } // Use the final font from context-2d, because the final\n  // font might not be the style.font when it is illegal.\n  // But get `ctx.font` might be time consuming.\n\n\n  var computedFont = hostEl.__computedFont;\n\n  if (hostEl.__styleFont !== styleFont) {\n    hostEl.__styleFont = styleFont;\n    computedFont = hostEl.__computedFont = ctx.font;\n  }\n\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign || 'left';\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, computedFont);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  } // Always set textAlign and textBase line, because it is difficute to calculate\n  // textAlign from prevEl, and we dont sure whether textAlign will be reset if\n  // font set happened.\n\n\n  ctx.textAlign = textAlign; // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  ctx.textBaseline = 'middle'; // Set text opacity\n\n  ctx.globalAlpha = style.opacity || 1; // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {\n    var propItem = SHADOW_STYLE_COMMON_PROPS[i];\n    var styleProp = propItem[0];\n    var ctxProp = propItem[1];\n    var val = style[styleProp];\n\n    if (!checkCache || val !== prevStyle[styleProp]) {\n      ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);\n    }\n  } // `textBaseline` is set as 'middle'.\n\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;\n  var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;\n  var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    if (strokeWidthChanged) {\n      ctx.lineWidth = textStrokeWidth;\n    }\n\n    if (strokeChanged) {\n      ctx.strokeStyle = textStroke;\n    }\n  }\n\n  if (textFill) {\n    if (!checkCache || style.textFill !== prevStyle.textFill) {\n      ctx.fillStyle = textFill;\n    }\n  } // Optimize simply, in most cases only one line exists.\n\n\n  if (textLines.length === 1) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[0], textX, textY);\n    textFill && ctx.fillText(textLines[0], textX, textY);\n  } else {\n    for (var i = 0; i < textLines.length; i++) {\n      // Fill after stroke so the outline will not cover the main part.\n      textStroke && ctx.strokeText(textLines[i], textX, textY);\n      textFill && ctx.fillText(textLines[i], textX, textY);\n      textY += lineHeight;\n    }\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect, prevEl) {\n  // Do not do cache for rich text because of the complexity.\n  // But `RectText` this will be restored, do not need to clear other cache like `Style::bind`.\n  if (prevEl !== WILL_BE_RESTORED) {\n    ctx.__attrCachedBy = ContextCachedBy.NONE;\n  }\n\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {};\n  tokenStyle.text = token.text; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius, text}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n\n    if (style.fillOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.fillOpacity * style.opacity;\n      ctx.fill();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.fill();\n    }\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n\n    if (style.strokeOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.strokeOpacity * style.opacity;\n      ctx.stroke();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.stroke();\n    }\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(out, hostEl, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : textContain.calculateTextPosition(_tmpTextPositionResult, style, rect);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  out = out || {};\n  out.baseX = baseX;\n  out.baseY = baseY;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n\nfunction setCtx(ctx, prop, value) {\n  ctx[prop] = fixShadow(ctx, prop, value);\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getBoxPosition = getBoxPosition;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.parsePercent = parsePercent;\nexports.needDrawText = needDrawText;","map":{"version":3,"names":["_util","require","retrieve2","retrieve3","each","normalizeCssArray","isString","isObject","textContain","roundRectHelper","imageHelper","fixShadow","_constant","ContextCachedBy","WILL_BE_RESTORED","DEFAULT_FONT","VALID_TEXT_ALIGN","left","right","center","VALID_TEXT_VERTICAL_ALIGN","top","bottom","middle","SHADOW_STYLE_COMMON_PROPS","_tmpTextPositionResult","_tmpBoxPositionResult","normalizeTextStyle","style","normalizeStyle","rich","font","makeFont","textAlign","textVerticalAlign","textBaseline","textPadding","renderText","hostEl","ctx","text","rect","prevEl","renderRichText","renderPlainText","needDrawBg","needDrawBackground","prevStyle","checkCache","cachedByMe","__attrCachedBy","PLAIN_TEXT","NONE","styleFont","computedFont","__computedFont","__styleFont","textLineHeight","contentBlock","__textCotentBlock","__dirtyText","parsePlainText","truncate","outerHeight","textLines","lines","lineHeight","boxPos","getBoxPosition","baseX","baseY","applyTextRotation","boxY","adjustTextY","textX","textY","textWidth","getWidth","outerWidth","boxX","adjustTextX","drawBackground","getTextXForPadding","globalAlpha","opacity","i","length","propItem","styleProp","ctxProp","val","textStrokeWidth","textStrokeWidthPrev","strokeWidthChanged","strokeChanged","textStroke","getStroke","textFill","getFill","lineWidth","strokeStyle","fillStyle","strokeText","fillText","parseRichText","drawRichText","contentWidth","width","xLeft","lineTop","xRight","line","tokens","tokenCount","usedWidth","leftIndex","lineXLeft","lineXRight","rightIndex","token","placeToken","x","y","textRotation","origin","textOrigin","height","translate","rotate","tokenStyle","styleName","isLineHolder","textHeight","setCtx","textShadowBlur","textShadowColor","textShadowOffsetX","textShadowOffsetY","textBackgroundColor","textBorderWidth","textBorderColor","isPlainBg","textBoxShadowBlur","textBoxShadowColor","textBoxShadowOffsetX","textBoxShadowOffsetY","beginPath","textBorderRadius","buildPath","r","closePath","fillOpacity","originalGlobalAlpha","fill","image","createOrUpdateImage","onBgImageLoaded","isImageReady","drawImage","strokeOpacity","stroke","out","textPosition","Array","parsePercent","res","calculateTextPosition","textOffset","prop","value","colorStops","maxValue","lastIndexOf","parseFloat","needDrawText","exports"],"sources":["F:/Wechatfile/WeChat Files/wxid_cre715h75uat22/FileStorage/MsgAttach/843d799c0bb5fd5ab828b2371b6d88b0/File/2022-07/project/project/app/node_modules/zrender/lib/graphic/helper/text.js"],"sourcesContent":["var _util = require(\"../../core/util\");\n\nvar retrieve2 = _util.retrieve2;\nvar retrieve3 = _util.retrieve3;\nvar each = _util.each;\nvar normalizeCssArray = _util.normalizeCssArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\n\nvar textContain = require(\"../../contain/text\");\n\nvar roundRectHelper = require(\"./roundRect\");\n\nvar imageHelper = require(\"./image\");\n\nvar fixShadow = require(\"./fixShadow\");\n\nvar _constant = require(\"../constant\");\n\nvar ContextCachedBy = _constant.ContextCachedBy;\nvar WILL_BE_RESTORED = _constant.WILL_BE_RESTORED;\nvar DEFAULT_FONT = textContain.DEFAULT_FONT; // TODO: Have not support 'start', 'end' yet.\n\nvar VALID_TEXT_ALIGN = {\n  left: 1,\n  right: 1,\n  center: 1\n};\nvar VALID_TEXT_VERTICAL_ALIGN = {\n  top: 1,\n  bottom: 1,\n  middle: 1\n}; // Different from `STYLE_COMMON_PROPS` of `graphic/Style`,\n// the default value of shadowColor is `'transparent'`.\n\nvar SHADOW_STYLE_COMMON_PROPS = [['textShadowBlur', 'shadowBlur', 0], ['textShadowOffsetX', 'shadowOffsetX', 0], ['textShadowOffsetY', 'shadowOffsetY', 0], ['textShadowColor', 'shadowColor', 'transparent']];\nvar _tmpTextPositionResult = {};\nvar _tmpBoxPositionResult = {};\n/**\n * @param {module:zrender/graphic/Style} style\n * @return {module:zrender/graphic/Style} The input style.\n */\n\nfunction normalizeTextStyle(style) {\n  normalizeStyle(style);\n  each(style.rich, normalizeStyle);\n  return style;\n}\n\nfunction normalizeStyle(style) {\n  if (style) {\n    style.font = textContain.makeFont(style);\n    var textAlign = style.textAlign;\n    textAlign === 'middle' && (textAlign = 'center');\n    style.textAlign = textAlign == null || VALID_TEXT_ALIGN[textAlign] ? textAlign : 'left'; // Compatible with textBaseline.\n\n    var textVerticalAlign = style.textVerticalAlign || style.textBaseline;\n    textVerticalAlign === 'center' && (textVerticalAlign = 'middle');\n    style.textVerticalAlign = textVerticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[textVerticalAlign] ? textVerticalAlign : 'top';\n    var textPadding = style.textPadding;\n\n    if (textPadding) {\n      style.textPadding = normalizeCssArray(style.textPadding);\n    }\n  }\n}\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {string} text\n * @param {module:zrender/graphic/Style} style\n * @param {Object|boolean} [rect] {x, y, width, height}\n *                  If set false, rect text is not used.\n * @param {Element|module:zrender/graphic/helper/constant.WILL_BE_RESTORED} [prevEl] For ctx prop cache.\n */\n\n\nfunction renderText(hostEl, ctx, text, style, rect, prevEl) {\n  style.rich ? renderRichText(hostEl, ctx, text, style, rect, prevEl) : renderPlainText(hostEl, ctx, text, style, rect, prevEl);\n} // Avoid setting to ctx according to prevEl if possible for\n// performance in scenarios of large amount text.\n\n\nfunction renderPlainText(hostEl, ctx, text, style, rect, prevEl) {\n  'use strict';\n\n  var needDrawBg = needDrawBackground(style);\n  var prevStyle;\n  var checkCache = false;\n  var cachedByMe = ctx.__attrCachedBy === ContextCachedBy.PLAIN_TEXT; // Only take and check cache for `Text` el, but not RectText.\n\n  if (prevEl !== WILL_BE_RESTORED) {\n    if (prevEl) {\n      prevStyle = prevEl.style;\n      checkCache = !needDrawBg && cachedByMe && prevStyle;\n    } // Prevent from using cache in `Style::bind`, because of the case:\n    // ctx property is modified by other properties than `Style::bind`\n    // used, and Style::bind is called next.\n\n\n    ctx.__attrCachedBy = needDrawBg ? ContextCachedBy.NONE : ContextCachedBy.PLAIN_TEXT;\n  } // Since this will be restored, prevent from using these props to check cache in the next\n  // entering of this method. But do not need to clear other cache like `Style::bind`.\n  else if (cachedByMe) {\n      ctx.__attrCachedBy = ContextCachedBy.NONE;\n    }\n\n  var styleFont = style.font || DEFAULT_FONT; // PENDING\n  // Only `Text` el set `font` and keep it (`RectText` will restore). So theoretically\n  // we can make font cache on ctx, which can cache for text el that are discontinuous.\n  // But layer save/restore needed to be considered.\n  // if (styleFont !== ctx.__fontCache) {\n  //     ctx.font = styleFont;\n  //     if (prevEl !== WILL_BE_RESTORED) {\n  //         ctx.__fontCache = styleFont;\n  //     }\n  // }\n\n  if (!checkCache || styleFont !== (prevStyle.font || DEFAULT_FONT)) {\n    ctx.font = styleFont;\n  } // Use the final font from context-2d, because the final\n  // font might not be the style.font when it is illegal.\n  // But get `ctx.font` might be time consuming.\n\n\n  var computedFont = hostEl.__computedFont;\n\n  if (hostEl.__styleFont !== styleFont) {\n    hostEl.__styleFont = styleFont;\n    computedFont = hostEl.__computedFont = ctx.font;\n  }\n\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var textLines = contentBlock.lines;\n  var lineHeight = contentBlock.lineHeight;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign || 'left';\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY;\n\n  if (needDrawBg || textPadding) {\n    // Consider performance, do not call getTextWidth util necessary.\n    var textWidth = textContain.getWidth(text, computedFont);\n    var outerWidth = textWidth;\n    textPadding && (outerWidth += textPadding[1] + textPadding[3]);\n    var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n    needDrawBg && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n    if (textPadding) {\n      textX = getTextXForPadding(baseX, textAlign, textPadding);\n      textY += textPadding[0];\n    }\n  } // Always set textAlign and textBase line, because it is difficute to calculate\n  // textAlign from prevEl, and we dont sure whether textAlign will be reset if\n  // font set happened.\n\n\n  ctx.textAlign = textAlign; // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  ctx.textBaseline = 'middle'; // Set text opacity\n\n  ctx.globalAlpha = style.opacity || 1; // Always set shadowBlur and shadowOffset to avoid leak from displayable.\n\n  for (var i = 0; i < SHADOW_STYLE_COMMON_PROPS.length; i++) {\n    var propItem = SHADOW_STYLE_COMMON_PROPS[i];\n    var styleProp = propItem[0];\n    var ctxProp = propItem[1];\n    var val = style[styleProp];\n\n    if (!checkCache || val !== prevStyle[styleProp]) {\n      ctx[ctxProp] = fixShadow(ctx, ctxProp, val || propItem[2]);\n    }\n  } // `textBaseline` is set as 'middle'.\n\n\n  textY += lineHeight / 2;\n  var textStrokeWidth = style.textStrokeWidth;\n  var textStrokeWidthPrev = checkCache ? prevStyle.textStrokeWidth : null;\n  var strokeWidthChanged = !checkCache || textStrokeWidth !== textStrokeWidthPrev;\n  var strokeChanged = !checkCache || strokeWidthChanged || style.textStroke !== prevStyle.textStroke;\n  var textStroke = getStroke(style.textStroke, textStrokeWidth);\n  var textFill = getFill(style.textFill);\n\n  if (textStroke) {\n    if (strokeWidthChanged) {\n      ctx.lineWidth = textStrokeWidth;\n    }\n\n    if (strokeChanged) {\n      ctx.strokeStyle = textStroke;\n    }\n  }\n\n  if (textFill) {\n    if (!checkCache || style.textFill !== prevStyle.textFill) {\n      ctx.fillStyle = textFill;\n    }\n  } // Optimize simply, in most cases only one line exists.\n\n\n  if (textLines.length === 1) {\n    // Fill after stroke so the outline will not cover the main part.\n    textStroke && ctx.strokeText(textLines[0], textX, textY);\n    textFill && ctx.fillText(textLines[0], textX, textY);\n  } else {\n    for (var i = 0; i < textLines.length; i++) {\n      // Fill after stroke so the outline will not cover the main part.\n      textStroke && ctx.strokeText(textLines[i], textX, textY);\n      textFill && ctx.fillText(textLines[i], textX, textY);\n      textY += lineHeight;\n    }\n  }\n}\n\nfunction renderRichText(hostEl, ctx, text, style, rect, prevEl) {\n  // Do not do cache for rich text because of the complexity.\n  // But `RectText` this will be restored, do not need to clear other cache like `Style::bind`.\n  if (prevEl !== WILL_BE_RESTORED) {\n    ctx.__attrCachedBy = ContextCachedBy.NONE;\n  }\n\n  var contentBlock = hostEl.__textCotentBlock;\n\n  if (!contentBlock || hostEl.__dirtyText) {\n    contentBlock = hostEl.__textCotentBlock = textContain.parseRichText(text, style);\n  }\n\n  drawRichText(hostEl, ctx, contentBlock, style, rect);\n}\n\nfunction drawRichText(hostEl, ctx, contentBlock, style, rect) {\n  var contentWidth = contentBlock.width;\n  var outerWidth = contentBlock.outerWidth;\n  var outerHeight = contentBlock.outerHeight;\n  var textPadding = style.textPadding;\n  var boxPos = getBoxPosition(_tmpBoxPositionResult, hostEl, style, rect);\n  var baseX = boxPos.baseX;\n  var baseY = boxPos.baseY;\n  var textAlign = boxPos.textAlign;\n  var textVerticalAlign = boxPos.textVerticalAlign; // Origin of textRotation should be the base point of text drawing.\n\n  applyTextRotation(ctx, style, rect, baseX, baseY);\n  var boxX = textContain.adjustTextX(baseX, outerWidth, textAlign);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var xLeft = boxX;\n  var lineTop = boxY;\n\n  if (textPadding) {\n    xLeft += textPadding[3];\n    lineTop += textPadding[0];\n  }\n\n  var xRight = xLeft + contentWidth;\n  needDrawBackground(style) && drawBackground(hostEl, ctx, style, boxX, boxY, outerWidth, outerHeight);\n\n  for (var i = 0; i < contentBlock.lines.length; i++) {\n    var line = contentBlock.lines[i];\n    var tokens = line.tokens;\n    var tokenCount = tokens.length;\n    var lineHeight = line.lineHeight;\n    var usedWidth = line.width;\n    var leftIndex = 0;\n    var lineXLeft = xLeft;\n    var lineXRight = xRight;\n    var rightIndex = tokenCount - 1;\n    var token;\n\n    while (leftIndex < tokenCount && (token = tokens[leftIndex], !token.textAlign || token.textAlign === 'left')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft, 'left');\n      usedWidth -= token.width;\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    while (rightIndex >= 0 && (token = tokens[rightIndex], token.textAlign === 'right')) {\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXRight, 'right');\n      usedWidth -= token.width;\n      lineXRight -= token.width;\n      rightIndex--;\n    } // The other tokens are placed as textAlign 'center' if there is enough space.\n\n\n    lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - usedWidth) / 2;\n\n    while (leftIndex <= rightIndex) {\n      token = tokens[leftIndex]; // Consider width specified by user, use 'center' rather than 'left'.\n\n      placeToken(hostEl, ctx, token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center');\n      lineXLeft += token.width;\n      leftIndex++;\n    }\n\n    lineTop += lineHeight;\n  }\n}\n\nfunction applyTextRotation(ctx, style, rect, x, y) {\n  // textRotation only apply in RectText.\n  if (rect && style.textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      x = rect.width / 2 + rect.x;\n      y = rect.height / 2 + rect.y;\n    } else if (origin) {\n      x = origin[0] + rect.x;\n      y = origin[1] + rect.y;\n    }\n\n    ctx.translate(x, y); // Positive: anticlockwise\n\n    ctx.rotate(-style.textRotation);\n    ctx.translate(-x, -y);\n  }\n}\n\nfunction placeToken(hostEl, ctx, token, style, lineHeight, lineTop, x, textAlign) {\n  var tokenStyle = style.rich[token.styleName] || {};\n  tokenStyle.text = token.text; // 'ctx.textBaseline' is always set as 'middle', for sake of\n  // the bias of \"Microsoft YaHei\".\n\n  var textVerticalAlign = token.textVerticalAlign;\n  var y = lineTop + lineHeight / 2;\n\n  if (textVerticalAlign === 'top') {\n    y = lineTop + token.height / 2;\n  } else if (textVerticalAlign === 'bottom') {\n    y = lineTop + lineHeight - token.height / 2;\n  }\n\n  !token.isLineHolder && needDrawBackground(tokenStyle) && drawBackground(hostEl, ctx, tokenStyle, textAlign === 'right' ? x - token.width : textAlign === 'center' ? x - token.width / 2 : x, y - token.height / 2, token.width, token.height);\n  var textPadding = token.textPadding;\n\n  if (textPadding) {\n    x = getTextXForPadding(x, textAlign, textPadding);\n    y -= token.height / 2 - textPadding[2] - token.textHeight / 2;\n  }\n\n  setCtx(ctx, 'shadowBlur', retrieve3(tokenStyle.textShadowBlur, style.textShadowBlur, 0));\n  setCtx(ctx, 'shadowColor', tokenStyle.textShadowColor || style.textShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', retrieve3(tokenStyle.textShadowOffsetX, style.textShadowOffsetX, 0));\n  setCtx(ctx, 'shadowOffsetY', retrieve3(tokenStyle.textShadowOffsetY, style.textShadowOffsetY, 0));\n  setCtx(ctx, 'textAlign', textAlign); // Force baseline to be \"middle\". Otherwise, if using \"top\", the\n  // text will offset downward a little bit in font \"Microsoft YaHei\".\n\n  setCtx(ctx, 'textBaseline', 'middle');\n  setCtx(ctx, 'font', token.font || DEFAULT_FONT);\n  var textStroke = getStroke(tokenStyle.textStroke || style.textStroke, textStrokeWidth);\n  var textFill = getFill(tokenStyle.textFill || style.textFill);\n  var textStrokeWidth = retrieve2(tokenStyle.textStrokeWidth, style.textStrokeWidth); // Fill after stroke so the outline will not cover the main part.\n\n  if (textStroke) {\n    setCtx(ctx, 'lineWidth', textStrokeWidth);\n    setCtx(ctx, 'strokeStyle', textStroke);\n    ctx.strokeText(token.text, x, y);\n  }\n\n  if (textFill) {\n    setCtx(ctx, 'fillStyle', textFill);\n    ctx.fillText(token.text, x, y);\n  }\n}\n\nfunction needDrawBackground(style) {\n  return !!(style.textBackgroundColor || style.textBorderWidth && style.textBorderColor);\n} // style: {textBackgroundColor, textBorderWidth, textBorderColor, textBorderRadius, text}\n// shape: {x, y, width, height}\n\n\nfunction drawBackground(hostEl, ctx, style, x, y, width, height) {\n  var textBackgroundColor = style.textBackgroundColor;\n  var textBorderWidth = style.textBorderWidth;\n  var textBorderColor = style.textBorderColor;\n  var isPlainBg = isString(textBackgroundColor);\n  setCtx(ctx, 'shadowBlur', style.textBoxShadowBlur || 0);\n  setCtx(ctx, 'shadowColor', style.textBoxShadowColor || 'transparent');\n  setCtx(ctx, 'shadowOffsetX', style.textBoxShadowOffsetX || 0);\n  setCtx(ctx, 'shadowOffsetY', style.textBoxShadowOffsetY || 0);\n\n  if (isPlainBg || textBorderWidth && textBorderColor) {\n    ctx.beginPath();\n    var textBorderRadius = style.textBorderRadius;\n\n    if (!textBorderRadius) {\n      ctx.rect(x, y, width, height);\n    } else {\n      roundRectHelper.buildPath(ctx, {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        r: textBorderRadius\n      });\n    }\n\n    ctx.closePath();\n  }\n\n  if (isPlainBg) {\n    setCtx(ctx, 'fillStyle', textBackgroundColor);\n\n    if (style.fillOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.fillOpacity * style.opacity;\n      ctx.fill();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.fill();\n    }\n  } else if (isObject(textBackgroundColor)) {\n    var image = textBackgroundColor.image;\n    image = imageHelper.createOrUpdateImage(image, null, hostEl, onBgImageLoaded, textBackgroundColor);\n\n    if (image && imageHelper.isImageReady(image)) {\n      ctx.drawImage(image, x, y, width, height);\n    }\n  }\n\n  if (textBorderWidth && textBorderColor) {\n    setCtx(ctx, 'lineWidth', textBorderWidth);\n    setCtx(ctx, 'strokeStyle', textBorderColor);\n\n    if (style.strokeOpacity != null) {\n      var originalGlobalAlpha = ctx.globalAlpha;\n      ctx.globalAlpha = style.strokeOpacity * style.opacity;\n      ctx.stroke();\n      ctx.globalAlpha = originalGlobalAlpha;\n    } else {\n      ctx.stroke();\n    }\n  }\n}\n\nfunction onBgImageLoaded(image, textBackgroundColor) {\n  // Replace image, so that `contain/text.js#parseRichText`\n  // will get correct result in next tick.\n  textBackgroundColor.image = image;\n}\n\nfunction getBoxPosition(out, hostEl, style, rect) {\n  var baseX = style.x || 0;\n  var baseY = style.y || 0;\n  var textAlign = style.textAlign;\n  var textVerticalAlign = style.textVerticalAlign; // Text position represented by coord\n\n  if (rect) {\n    var textPosition = style.textPosition;\n\n    if (textPosition instanceof Array) {\n      // Percent\n      baseX = rect.x + parsePercent(textPosition[0], rect.width);\n      baseY = rect.y + parsePercent(textPosition[1], rect.height);\n    } else {\n      var res = hostEl && hostEl.calculateTextPosition ? hostEl.calculateTextPosition(_tmpTextPositionResult, style, rect) : textContain.calculateTextPosition(_tmpTextPositionResult, style, rect);\n      baseX = res.x;\n      baseY = res.y; // Default align and baseline when has textPosition\n\n      textAlign = textAlign || res.textAlign;\n      textVerticalAlign = textVerticalAlign || res.textVerticalAlign;\n    } // textOffset is only support in RectText, otherwise\n    // we have to adjust boundingRect for textOffset.\n\n\n    var textOffset = style.textOffset;\n\n    if (textOffset) {\n      baseX += textOffset[0];\n      baseY += textOffset[1];\n    }\n  }\n\n  out = out || {};\n  out.baseX = baseX;\n  out.baseY = baseY;\n  out.textAlign = textAlign;\n  out.textVerticalAlign = textVerticalAlign;\n  return out;\n}\n\nfunction setCtx(ctx, prop, value) {\n  ctx[prop] = fixShadow(ctx, prop, value);\n  return ctx[prop];\n}\n/**\n * @param {string} [stroke] If specified, do not check style.textStroke.\n * @param {string} [lineWidth] If specified, do not check style.textStroke.\n * @param {number} style\n */\n\n\nfunction getStroke(stroke, lineWidth) {\n  return stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none' ? null // TODO pattern and gradient?\n  : stroke.image || stroke.colorStops ? '#000' : stroke;\n}\n\nfunction getFill(fill) {\n  return fill == null || fill === 'none' ? null // TODO pattern and gradient?\n  : fill.image || fill.colorStops ? '#000' : fill;\n}\n\nfunction parsePercent(value, maxValue) {\n  if (typeof value === 'string') {\n    if (value.lastIndexOf('%') >= 0) {\n      return parseFloat(value) / 100 * maxValue;\n    }\n\n    return parseFloat(value);\n  }\n\n  return value;\n}\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n/**\n * @param {string} text\n * @param {module:zrender/Style} style\n * @return {boolean}\n */\n\n\nfunction needDrawText(text, style) {\n  return text != null && (text || style.textBackgroundColor || style.textBorderWidth && style.textBorderColor || style.textPadding);\n}\n\nexports.normalizeTextStyle = normalizeTextStyle;\nexports.renderText = renderText;\nexports.getBoxPosition = getBoxPosition;\nexports.getStroke = getStroke;\nexports.getFill = getFill;\nexports.parsePercent = parsePercent;\nexports.needDrawText = needDrawText;"],"mappings":"AAAA,IAAIA,KAAK,GAAGC,OAAO,CAAC,iBAAD,CAAnB;;AAEA,IAAIC,SAAS,GAAGF,KAAK,CAACE,SAAtB;AACA,IAAIC,SAAS,GAAGH,KAAK,CAACG,SAAtB;AACA,IAAIC,IAAI,GAAGJ,KAAK,CAACI,IAAjB;AACA,IAAIC,iBAAiB,GAAGL,KAAK,CAACK,iBAA9B;AACA,IAAIC,QAAQ,GAAGN,KAAK,CAACM,QAArB;AACA,IAAIC,QAAQ,GAAGP,KAAK,CAACO,QAArB;;AAEA,IAAIC,WAAW,GAAGP,OAAO,CAAC,oBAAD,CAAzB;;AAEA,IAAIQ,eAAe,GAAGR,OAAO,CAAC,aAAD,CAA7B;;AAEA,IAAIS,WAAW,GAAGT,OAAO,CAAC,SAAD,CAAzB;;AAEA,IAAIU,SAAS,GAAGV,OAAO,CAAC,aAAD,CAAvB;;AAEA,IAAIW,SAAS,GAAGX,OAAO,CAAC,aAAD,CAAvB;;AAEA,IAAIY,eAAe,GAAGD,SAAS,CAACC,eAAhC;AACA,IAAIC,gBAAgB,GAAGF,SAAS,CAACE,gBAAjC;AACA,IAAIC,YAAY,GAAGP,WAAW,CAACO,YAA/B,C,CAA6C;;AAE7C,IAAIC,gBAAgB,GAAG;EACrBC,IAAI,EAAE,CADe;EAErBC,KAAK,EAAE,CAFc;EAGrBC,MAAM,EAAE;AAHa,CAAvB;AAKA,IAAIC,yBAAyB,GAAG;EAC9BC,GAAG,EAAE,CADyB;EAE9BC,MAAM,EAAE,CAFsB;EAG9BC,MAAM,EAAE;AAHsB,CAAhC,C,CAIG;AACH;;AAEA,IAAIC,yBAAyB,GAAG,CAAC,CAAC,gBAAD,EAAmB,YAAnB,EAAiC,CAAjC,CAAD,EAAsC,CAAC,mBAAD,EAAsB,eAAtB,EAAuC,CAAvC,CAAtC,EAAiF,CAAC,mBAAD,EAAsB,eAAtB,EAAuC,CAAvC,CAAjF,EAA4H,CAAC,iBAAD,EAAoB,aAApB,EAAmC,aAAnC,CAA5H,CAAhC;AACA,IAAIC,sBAAsB,GAAG,EAA7B;AACA,IAAIC,qBAAqB,GAAG,EAA5B;AACA;AACA;AACA;AACA;;AAEA,SAASC,kBAAT,CAA4BC,KAA5B,EAAmC;EACjCC,cAAc,CAACD,KAAD,CAAd;EACAxB,IAAI,CAACwB,KAAK,CAACE,IAAP,EAAaD,cAAb,CAAJ;EACA,OAAOD,KAAP;AACD;;AAED,SAASC,cAAT,CAAwBD,KAAxB,EAA+B;EAC7B,IAAIA,KAAJ,EAAW;IACTA,KAAK,CAACG,IAAN,GAAavB,WAAW,CAACwB,QAAZ,CAAqBJ,KAArB,CAAb;IACA,IAAIK,SAAS,GAAGL,KAAK,CAACK,SAAtB;IACAA,SAAS,KAAK,QAAd,KAA2BA,SAAS,GAAG,QAAvC;IACAL,KAAK,CAACK,SAAN,GAAkBA,SAAS,IAAI,IAAb,IAAqBjB,gBAAgB,CAACiB,SAAD,CAArC,GAAmDA,SAAnD,GAA+D,MAAjF,CAJS,CAIgF;;IAEzF,IAAIC,iBAAiB,GAAGN,KAAK,CAACM,iBAAN,IAA2BN,KAAK,CAACO,YAAzD;IACAD,iBAAiB,KAAK,QAAtB,KAAmCA,iBAAiB,GAAG,QAAvD;IACAN,KAAK,CAACM,iBAAN,GAA0BA,iBAAiB,IAAI,IAArB,IAA6Bd,yBAAyB,CAACc,iBAAD,CAAtD,GAA4EA,iBAA5E,GAAgG,KAA1H;IACA,IAAIE,WAAW,GAAGR,KAAK,CAACQ,WAAxB;;IAEA,IAAIA,WAAJ,EAAiB;MACfR,KAAK,CAACQ,WAAN,GAAoB/B,iBAAiB,CAACuB,KAAK,CAACQ,WAAP,CAArC;IACD;EACF;AACF;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASC,UAAT,CAAoBC,MAApB,EAA4BC,GAA5B,EAAiCC,IAAjC,EAAuCZ,KAAvC,EAA8Ca,IAA9C,EAAoDC,MAApD,EAA4D;EAC1Dd,KAAK,CAACE,IAAN,GAAaa,cAAc,CAACL,MAAD,EAASC,GAAT,EAAcC,IAAd,EAAoBZ,KAApB,EAA2Ba,IAA3B,EAAiCC,MAAjC,CAA3B,GAAsEE,eAAe,CAACN,MAAD,EAASC,GAAT,EAAcC,IAAd,EAAoBZ,KAApB,EAA2Ba,IAA3B,EAAiCC,MAAjC,CAArF;AACD,C,CAAC;AACF;;;AAGA,SAASE,eAAT,CAAyBN,MAAzB,EAAiCC,GAAjC,EAAsCC,IAAtC,EAA4CZ,KAA5C,EAAmDa,IAAnD,EAAyDC,MAAzD,EAAiE;EAC/D;;EAEA,IAAIG,UAAU,GAAGC,kBAAkB,CAAClB,KAAD,CAAnC;EACA,IAAImB,SAAJ;EACA,IAAIC,UAAU,GAAG,KAAjB;EACA,IAAIC,UAAU,GAAGV,GAAG,CAACW,cAAJ,KAAuBrC,eAAe,CAACsC,UAAxD,CAN+D,CAMK;;EAEpE,IAAIT,MAAM,KAAK5B,gBAAf,EAAiC;IAC/B,IAAI4B,MAAJ,EAAY;MACVK,SAAS,GAAGL,MAAM,CAACd,KAAnB;MACAoB,UAAU,GAAG,CAACH,UAAD,IAAeI,UAAf,IAA6BF,SAA1C;IACD,CAJ8B,CAI7B;IACF;IACA;;;IAGAR,GAAG,CAACW,cAAJ,GAAqBL,UAAU,GAAGhC,eAAe,CAACuC,IAAnB,GAA0BvC,eAAe,CAACsC,UAAzE;EACD,CAVD,CAUE;EACF;EAXA,KAYK,IAAIF,UAAJ,EAAgB;IACjBV,GAAG,CAACW,cAAJ,GAAqBrC,eAAe,CAACuC,IAArC;EACD;;EAEH,IAAIC,SAAS,GAAGzB,KAAK,CAACG,IAAN,IAAchB,YAA9B,CAxB+D,CAwBnB;EAC5C;EACA;EACA;EACA;EACA;EACA;EACA;EACA;EACA;;EAEA,IAAI,CAACiC,UAAD,IAAeK,SAAS,MAAMN,SAAS,CAAChB,IAAV,IAAkBhB,YAAxB,CAA5B,EAAmE;IACjEwB,GAAG,CAACR,IAAJ,GAAWsB,SAAX;EACD,CArC8D,CAqC7D;EACF;EACA;;;EAGA,IAAIC,YAAY,GAAGhB,MAAM,CAACiB,cAA1B;;EAEA,IAAIjB,MAAM,CAACkB,WAAP,KAAuBH,SAA3B,EAAsC;IACpCf,MAAM,CAACkB,WAAP,GAAqBH,SAArB;IACAC,YAAY,GAAGhB,MAAM,CAACiB,cAAP,GAAwBhB,GAAG,CAACR,IAA3C;EACD;;EAED,IAAIK,WAAW,GAAGR,KAAK,CAACQ,WAAxB;EACA,IAAIqB,cAAc,GAAG7B,KAAK,CAAC6B,cAA3B;EACA,IAAIC,YAAY,GAAGpB,MAAM,CAACqB,iBAA1B;;EAEA,IAAI,CAACD,YAAD,IAAiBpB,MAAM,CAACsB,WAA5B,EAAyC;IACvCF,YAAY,GAAGpB,MAAM,CAACqB,iBAAP,GAA2BnD,WAAW,CAACqD,cAAZ,CAA2BrB,IAA3B,EAAiCc,YAAjC,EAA+ClB,WAA/C,EAA4DqB,cAA5D,EAA4E7B,KAAK,CAACkC,QAAlF,CAA1C;EACD;;EAED,IAAIC,WAAW,GAAGL,YAAY,CAACK,WAA/B;EACA,IAAIC,SAAS,GAAGN,YAAY,CAACO,KAA7B;EACA,IAAIC,UAAU,GAAGR,YAAY,CAACQ,UAA9B;EACA,IAAIC,MAAM,GAAGC,cAAc,CAAC1C,qBAAD,EAAwBY,MAAxB,EAAgCV,KAAhC,EAAuCa,IAAvC,CAA3B;EACA,IAAI4B,KAAK,GAAGF,MAAM,CAACE,KAAnB;EACA,IAAIC,KAAK,GAAGH,MAAM,CAACG,KAAnB;EACA,IAAIrC,SAAS,GAAGkC,MAAM,CAAClC,SAAP,IAAoB,MAApC;EACA,IAAIC,iBAAiB,GAAGiC,MAAM,CAACjC,iBAA/B,CAhE+D,CAgEb;;EAElDqC,iBAAiB,CAAChC,GAAD,EAAMX,KAAN,EAAaa,IAAb,EAAmB4B,KAAnB,EAA0BC,KAA1B,CAAjB;EACA,IAAIE,IAAI,GAAGhE,WAAW,CAACiE,WAAZ,CAAwBH,KAAxB,EAA+BP,WAA/B,EAA4C7B,iBAA5C,CAAX;EACA,IAAIwC,KAAK,GAAGL,KAAZ;EACA,IAAIM,KAAK,GAAGH,IAAZ;;EAEA,IAAI3B,UAAU,IAAIT,WAAlB,EAA+B;IAC7B;IACA,IAAIwC,SAAS,GAAGpE,WAAW,CAACqE,QAAZ,CAAqBrC,IAArB,EAA2Bc,YAA3B,CAAhB;IACA,IAAIwB,UAAU,GAAGF,SAAjB;IACAxC,WAAW,KAAK0C,UAAU,IAAI1C,WAAW,CAAC,CAAD,CAAX,GAAiBA,WAAW,CAAC,CAAD,CAA/C,CAAX;IACA,IAAI2C,IAAI,GAAGvE,WAAW,CAACwE,WAAZ,CAAwBX,KAAxB,EAA+BS,UAA/B,EAA2C7C,SAA3C,CAAX;IACAY,UAAU,IAAIoC,cAAc,CAAC3C,MAAD,EAASC,GAAT,EAAcX,KAAd,EAAqBmD,IAArB,EAA2BP,IAA3B,EAAiCM,UAAjC,EAA6Cf,WAA7C,CAA5B;;IAEA,IAAI3B,WAAJ,EAAiB;MACfsC,KAAK,GAAGQ,kBAAkB,CAACb,KAAD,EAAQpC,SAAR,EAAmBG,WAAnB,CAA1B;MACAuC,KAAK,IAAIvC,WAAW,CAAC,CAAD,CAApB;IACD;EACF,CAnF8D,CAmF7D;EACF;EACA;;;EAGAG,GAAG,CAACN,SAAJ,GAAgBA,SAAhB,CAxF+D,CAwFpC;EAC3B;;EAEAM,GAAG,CAACJ,YAAJ,GAAmB,QAAnB,CA3F+D,CA2FlC;;EAE7BI,GAAG,CAAC4C,WAAJ,GAAkBvD,KAAK,CAACwD,OAAN,IAAiB,CAAnC,CA7F+D,CA6FzB;;EAEtC,KAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7D,yBAAyB,CAAC8D,MAA9C,EAAsDD,CAAC,EAAvD,EAA2D;IACzD,IAAIE,QAAQ,GAAG/D,yBAAyB,CAAC6D,CAAD,CAAxC;IACA,IAAIG,SAAS,GAAGD,QAAQ,CAAC,CAAD,CAAxB;IACA,IAAIE,OAAO,GAAGF,QAAQ,CAAC,CAAD,CAAtB;IACA,IAAIG,GAAG,GAAG9D,KAAK,CAAC4D,SAAD,CAAf;;IAEA,IAAI,CAACxC,UAAD,IAAe0C,GAAG,KAAK3C,SAAS,CAACyC,SAAD,CAApC,EAAiD;MAC/CjD,GAAG,CAACkD,OAAD,CAAH,GAAe9E,SAAS,CAAC4B,GAAD,EAAMkD,OAAN,EAAeC,GAAG,IAAIH,QAAQ,CAAC,CAAD,CAA9B,CAAxB;IACD;EACF,CAxG8D,CAwG7D;;;EAGFZ,KAAK,IAAIT,UAAU,GAAG,CAAtB;EACA,IAAIyB,eAAe,GAAG/D,KAAK,CAAC+D,eAA5B;EACA,IAAIC,mBAAmB,GAAG5C,UAAU,GAAGD,SAAS,CAAC4C,eAAb,GAA+B,IAAnE;EACA,IAAIE,kBAAkB,GAAG,CAAC7C,UAAD,IAAe2C,eAAe,KAAKC,mBAA5D;EACA,IAAIE,aAAa,GAAG,CAAC9C,UAAD,IAAe6C,kBAAf,IAAqCjE,KAAK,CAACmE,UAAN,KAAqBhD,SAAS,CAACgD,UAAxF;EACA,IAAIA,UAAU,GAAGC,SAAS,CAACpE,KAAK,CAACmE,UAAP,EAAmBJ,eAAnB,CAA1B;EACA,IAAIM,QAAQ,GAAGC,OAAO,CAACtE,KAAK,CAACqE,QAAP,CAAtB;;EAEA,IAAIF,UAAJ,EAAgB;IACd,IAAIF,kBAAJ,EAAwB;MACtBtD,GAAG,CAAC4D,SAAJ,GAAgBR,eAAhB;IACD;;IAED,IAAIG,aAAJ,EAAmB;MACjBvD,GAAG,CAAC6D,WAAJ,GAAkBL,UAAlB;IACD;EACF;;EAED,IAAIE,QAAJ,EAAc;IACZ,IAAI,CAACjD,UAAD,IAAepB,KAAK,CAACqE,QAAN,KAAmBlD,SAAS,CAACkD,QAAhD,EAA0D;MACxD1D,GAAG,CAAC8D,SAAJ,GAAgBJ,QAAhB;IACD;EACF,CAjI8D,CAiI7D;;;EAGF,IAAIjC,SAAS,CAACsB,MAAV,KAAqB,CAAzB,EAA4B;IAC1B;IACAS,UAAU,IAAIxD,GAAG,CAAC+D,UAAJ,CAAetC,SAAS,CAAC,CAAD,CAAxB,EAA6BU,KAA7B,EAAoCC,KAApC,CAAd;IACAsB,QAAQ,IAAI1D,GAAG,CAACgE,QAAJ,CAAavC,SAAS,CAAC,CAAD,CAAtB,EAA2BU,KAA3B,EAAkCC,KAAlC,CAAZ;EACD,CAJD,MAIO;IACL,KAAK,IAAIU,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGrB,SAAS,CAACsB,MAA9B,EAAsCD,CAAC,EAAvC,EAA2C;MACzC;MACAU,UAAU,IAAIxD,GAAG,CAAC+D,UAAJ,CAAetC,SAAS,CAACqB,CAAD,CAAxB,EAA6BX,KAA7B,EAAoCC,KAApC,CAAd;MACAsB,QAAQ,IAAI1D,GAAG,CAACgE,QAAJ,CAAavC,SAAS,CAACqB,CAAD,CAAtB,EAA2BX,KAA3B,EAAkCC,KAAlC,CAAZ;MACAA,KAAK,IAAIT,UAAT;IACD;EACF;AACF;;AAED,SAASvB,cAAT,CAAwBL,MAAxB,EAAgCC,GAAhC,EAAqCC,IAArC,EAA2CZ,KAA3C,EAAkDa,IAAlD,EAAwDC,MAAxD,EAAgE;EAC9D;EACA;EACA,IAAIA,MAAM,KAAK5B,gBAAf,EAAiC;IAC/ByB,GAAG,CAACW,cAAJ,GAAqBrC,eAAe,CAACuC,IAArC;EACD;;EAED,IAAIM,YAAY,GAAGpB,MAAM,CAACqB,iBAA1B;;EAEA,IAAI,CAACD,YAAD,IAAiBpB,MAAM,CAACsB,WAA5B,EAAyC;IACvCF,YAAY,GAAGpB,MAAM,CAACqB,iBAAP,GAA2BnD,WAAW,CAACgG,aAAZ,CAA0BhE,IAA1B,EAAgCZ,KAAhC,CAA1C;EACD;;EAED6E,YAAY,CAACnE,MAAD,EAASC,GAAT,EAAcmB,YAAd,EAA4B9B,KAA5B,EAAmCa,IAAnC,CAAZ;AACD;;AAED,SAASgE,YAAT,CAAsBnE,MAAtB,EAA8BC,GAA9B,EAAmCmB,YAAnC,EAAiD9B,KAAjD,EAAwDa,IAAxD,EAA8D;EAC5D,IAAIiE,YAAY,GAAGhD,YAAY,CAACiD,KAAhC;EACA,IAAI7B,UAAU,GAAGpB,YAAY,CAACoB,UAA9B;EACA,IAAIf,WAAW,GAAGL,YAAY,CAACK,WAA/B;EACA,IAAI3B,WAAW,GAAGR,KAAK,CAACQ,WAAxB;EACA,IAAI+B,MAAM,GAAGC,cAAc,CAAC1C,qBAAD,EAAwBY,MAAxB,EAAgCV,KAAhC,EAAuCa,IAAvC,CAA3B;EACA,IAAI4B,KAAK,GAAGF,MAAM,CAACE,KAAnB;EACA,IAAIC,KAAK,GAAGH,MAAM,CAACG,KAAnB;EACA,IAAIrC,SAAS,GAAGkC,MAAM,CAAClC,SAAvB;EACA,IAAIC,iBAAiB,GAAGiC,MAAM,CAACjC,iBAA/B,CAT4D,CASV;;EAElDqC,iBAAiB,CAAChC,GAAD,EAAMX,KAAN,EAAaa,IAAb,EAAmB4B,KAAnB,EAA0BC,KAA1B,CAAjB;EACA,IAAIS,IAAI,GAAGvE,WAAW,CAACwE,WAAZ,CAAwBX,KAAxB,EAA+BS,UAA/B,EAA2C7C,SAA3C,CAAX;EACA,IAAIuC,IAAI,GAAGhE,WAAW,CAACiE,WAAZ,CAAwBH,KAAxB,EAA+BP,WAA/B,EAA4C7B,iBAA5C,CAAX;EACA,IAAI0E,KAAK,GAAG7B,IAAZ;EACA,IAAI8B,OAAO,GAAGrC,IAAd;;EAEA,IAAIpC,WAAJ,EAAiB;IACfwE,KAAK,IAAIxE,WAAW,CAAC,CAAD,CAApB;IACAyE,OAAO,IAAIzE,WAAW,CAAC,CAAD,CAAtB;EACD;;EAED,IAAI0E,MAAM,GAAGF,KAAK,GAAGF,YAArB;EACA5D,kBAAkB,CAAClB,KAAD,CAAlB,IAA6BqD,cAAc,CAAC3C,MAAD,EAASC,GAAT,EAAcX,KAAd,EAAqBmD,IAArB,EAA2BP,IAA3B,EAAiCM,UAAjC,EAA6Cf,WAA7C,CAA3C;;EAEA,KAAK,IAAIsB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG3B,YAAY,CAACO,KAAb,CAAmBqB,MAAvC,EAA+CD,CAAC,EAAhD,EAAoD;IAClD,IAAI0B,IAAI,GAAGrD,YAAY,CAACO,KAAb,CAAmBoB,CAAnB,CAAX;IACA,IAAI2B,MAAM,GAAGD,IAAI,CAACC,MAAlB;IACA,IAAIC,UAAU,GAAGD,MAAM,CAAC1B,MAAxB;IACA,IAAIpB,UAAU,GAAG6C,IAAI,CAAC7C,UAAtB;IACA,IAAIgD,SAAS,GAAGH,IAAI,CAACJ,KAArB;IACA,IAAIQ,SAAS,GAAG,CAAhB;IACA,IAAIC,SAAS,GAAGR,KAAhB;IACA,IAAIS,UAAU,GAAGP,MAAjB;IACA,IAAIQ,UAAU,GAAGL,UAAU,GAAG,CAA9B;IACA,IAAIM,KAAJ;;IAEA,OAAOJ,SAAS,GAAGF,UAAZ,KAA2BM,KAAK,GAAGP,MAAM,CAACG,SAAD,CAAd,EAA2B,CAACI,KAAK,CAACtF,SAAP,IAAoBsF,KAAK,CAACtF,SAAN,KAAoB,MAA9F,CAAP,EAA8G;MAC5GuF,UAAU,CAAClF,MAAD,EAASC,GAAT,EAAcgF,KAAd,EAAqB3F,KAArB,EAA4BsC,UAA5B,EAAwC2C,OAAxC,EAAiDO,SAAjD,EAA4D,MAA5D,CAAV;MACAF,SAAS,IAAIK,KAAK,CAACZ,KAAnB;MACAS,SAAS,IAAIG,KAAK,CAACZ,KAAnB;MACAQ,SAAS;IACV;;IAED,OAAOG,UAAU,IAAI,CAAd,KAAoBC,KAAK,GAAGP,MAAM,CAACM,UAAD,CAAd,EAA4BC,KAAK,CAACtF,SAAN,KAAoB,OAApE,CAAP,EAAqF;MACnFuF,UAAU,CAAClF,MAAD,EAASC,GAAT,EAAcgF,KAAd,EAAqB3F,KAArB,EAA4BsC,UAA5B,EAAwC2C,OAAxC,EAAiDQ,UAAjD,EAA6D,OAA7D,CAAV;MACAH,SAAS,IAAIK,KAAK,CAACZ,KAAnB;MACAU,UAAU,IAAIE,KAAK,CAACZ,KAApB;MACAW,UAAU;IACX,CAxBiD,CAwBhD;;;IAGFF,SAAS,IAAI,CAACV,YAAY,IAAIU,SAAS,GAAGR,KAAhB,CAAZ,IAAsCE,MAAM,GAAGO,UAA/C,IAA6DH,SAA9D,IAA2E,CAAxF;;IAEA,OAAOC,SAAS,IAAIG,UAApB,EAAgC;MAC9BC,KAAK,GAAGP,MAAM,CAACG,SAAD,CAAd,CAD8B,CACH;;MAE3BK,UAAU,CAAClF,MAAD,EAASC,GAAT,EAAcgF,KAAd,EAAqB3F,KAArB,EAA4BsC,UAA5B,EAAwC2C,OAAxC,EAAiDO,SAAS,GAAGG,KAAK,CAACZ,KAAN,GAAc,CAA3E,EAA8E,QAA9E,CAAV;MACAS,SAAS,IAAIG,KAAK,CAACZ,KAAnB;MACAQ,SAAS;IACV;;IAEDN,OAAO,IAAI3C,UAAX;EACD;AACF;;AAED,SAASK,iBAAT,CAA2BhC,GAA3B,EAAgCX,KAAhC,EAAuCa,IAAvC,EAA6CgF,CAA7C,EAAgDC,CAAhD,EAAmD;EACjD;EACA,IAAIjF,IAAI,IAAIb,KAAK,CAAC+F,YAAlB,EAAgC;IAC9B,IAAIC,MAAM,GAAGhG,KAAK,CAACiG,UAAnB;;IAEA,IAAID,MAAM,KAAK,QAAf,EAAyB;MACvBH,CAAC,GAAGhF,IAAI,CAACkE,KAAL,GAAa,CAAb,GAAiBlE,IAAI,CAACgF,CAA1B;MACAC,CAAC,GAAGjF,IAAI,CAACqF,MAAL,GAAc,CAAd,GAAkBrF,IAAI,CAACiF,CAA3B;IACD,CAHD,MAGO,IAAIE,MAAJ,EAAY;MACjBH,CAAC,GAAGG,MAAM,CAAC,CAAD,CAAN,GAAYnF,IAAI,CAACgF,CAArB;MACAC,CAAC,GAAGE,MAAM,CAAC,CAAD,CAAN,GAAYnF,IAAI,CAACiF,CAArB;IACD;;IAEDnF,GAAG,CAACwF,SAAJ,CAAcN,CAAd,EAAiBC,CAAjB,EAX8B,CAWT;;IAErBnF,GAAG,CAACyF,MAAJ,CAAW,CAACpG,KAAK,CAAC+F,YAAlB;IACApF,GAAG,CAACwF,SAAJ,CAAc,CAACN,CAAf,EAAkB,CAACC,CAAnB;EACD;AACF;;AAED,SAASF,UAAT,CAAoBlF,MAApB,EAA4BC,GAA5B,EAAiCgF,KAAjC,EAAwC3F,KAAxC,EAA+CsC,UAA/C,EAA2D2C,OAA3D,EAAoEY,CAApE,EAAuExF,SAAvE,EAAkF;EAChF,IAAIgG,UAAU,GAAGrG,KAAK,CAACE,IAAN,CAAWyF,KAAK,CAACW,SAAjB,KAA+B,EAAhD;EACAD,UAAU,CAACzF,IAAX,GAAkB+E,KAAK,CAAC/E,IAAxB,CAFgF,CAElD;EAC9B;;EAEA,IAAIN,iBAAiB,GAAGqF,KAAK,CAACrF,iBAA9B;EACA,IAAIwF,CAAC,GAAGb,OAAO,GAAG3C,UAAU,GAAG,CAA/B;;EAEA,IAAIhC,iBAAiB,KAAK,KAA1B,EAAiC;IAC/BwF,CAAC,GAAGb,OAAO,GAAGU,KAAK,CAACO,MAAN,GAAe,CAA7B;EACD,CAFD,MAEO,IAAI5F,iBAAiB,KAAK,QAA1B,EAAoC;IACzCwF,CAAC,GAAGb,OAAO,GAAG3C,UAAV,GAAuBqD,KAAK,CAACO,MAAN,GAAe,CAA1C;EACD;;EAED,CAACP,KAAK,CAACY,YAAP,IAAuBrF,kBAAkB,CAACmF,UAAD,CAAzC,IAAyDhD,cAAc,CAAC3C,MAAD,EAASC,GAAT,EAAc0F,UAAd,EAA0BhG,SAAS,KAAK,OAAd,GAAwBwF,CAAC,GAAGF,KAAK,CAACZ,KAAlC,GAA0C1E,SAAS,KAAK,QAAd,GAAyBwF,CAAC,GAAGF,KAAK,CAACZ,KAAN,GAAc,CAA3C,GAA+Cc,CAAnH,EAAsHC,CAAC,GAAGH,KAAK,CAACO,MAAN,GAAe,CAAzI,EAA4IP,KAAK,CAACZ,KAAlJ,EAAyJY,KAAK,CAACO,MAA/J,CAAvE;EACA,IAAI1F,WAAW,GAAGmF,KAAK,CAACnF,WAAxB;;EAEA,IAAIA,WAAJ,EAAiB;IACfqF,CAAC,GAAGvC,kBAAkB,CAACuC,CAAD,EAAIxF,SAAJ,EAAeG,WAAf,CAAtB;IACAsF,CAAC,IAAIH,KAAK,CAACO,MAAN,GAAe,CAAf,GAAmB1F,WAAW,CAAC,CAAD,CAA9B,GAAoCmF,KAAK,CAACa,UAAN,GAAmB,CAA5D;EACD;;EAEDC,MAAM,CAAC9F,GAAD,EAAM,YAAN,EAAoBpC,SAAS,CAAC8H,UAAU,CAACK,cAAZ,EAA4B1G,KAAK,CAAC0G,cAAlC,EAAkD,CAAlD,CAA7B,CAAN;EACAD,MAAM,CAAC9F,GAAD,EAAM,aAAN,EAAqB0F,UAAU,CAACM,eAAX,IAA8B3G,KAAK,CAAC2G,eAApC,IAAuD,aAA5E,CAAN;EACAF,MAAM,CAAC9F,GAAD,EAAM,eAAN,EAAuBpC,SAAS,CAAC8H,UAAU,CAACO,iBAAZ,EAA+B5G,KAAK,CAAC4G,iBAArC,EAAwD,CAAxD,CAAhC,CAAN;EACAH,MAAM,CAAC9F,GAAD,EAAM,eAAN,EAAuBpC,SAAS,CAAC8H,UAAU,CAACQ,iBAAZ,EAA+B7G,KAAK,CAAC6G,iBAArC,EAAwD,CAAxD,CAAhC,CAAN;EACAJ,MAAM,CAAC9F,GAAD,EAAM,WAAN,EAAmBN,SAAnB,CAAN,CA1BgF,CA0B3C;EACrC;;EAEAoG,MAAM,CAAC9F,GAAD,EAAM,cAAN,EAAsB,QAAtB,CAAN;EACA8F,MAAM,CAAC9F,GAAD,EAAM,MAAN,EAAcgF,KAAK,CAACxF,IAAN,IAAchB,YAA5B,CAAN;EACA,IAAIgF,UAAU,GAAGC,SAAS,CAACiC,UAAU,CAAClC,UAAX,IAAyBnE,KAAK,CAACmE,UAAhC,EAA4CJ,eAA5C,CAA1B;EACA,IAAIM,QAAQ,GAAGC,OAAO,CAAC+B,UAAU,CAAChC,QAAX,IAAuBrE,KAAK,CAACqE,QAA9B,CAAtB;EACA,IAAIN,eAAe,GAAGzF,SAAS,CAAC+H,UAAU,CAACtC,eAAZ,EAA6B/D,KAAK,CAAC+D,eAAnC,CAA/B,CAjCgF,CAiCI;;EAEpF,IAAII,UAAJ,EAAgB;IACdsC,MAAM,CAAC9F,GAAD,EAAM,WAAN,EAAmBoD,eAAnB,CAAN;IACA0C,MAAM,CAAC9F,GAAD,EAAM,aAAN,EAAqBwD,UAArB,CAAN;IACAxD,GAAG,CAAC+D,UAAJ,CAAeiB,KAAK,CAAC/E,IAArB,EAA2BiF,CAA3B,EAA8BC,CAA9B;EACD;;EAED,IAAIzB,QAAJ,EAAc;IACZoC,MAAM,CAAC9F,GAAD,EAAM,WAAN,EAAmB0D,QAAnB,CAAN;IACA1D,GAAG,CAACgE,QAAJ,CAAagB,KAAK,CAAC/E,IAAnB,EAAyBiF,CAAzB,EAA4BC,CAA5B;EACD;AACF;;AAED,SAAS5E,kBAAT,CAA4BlB,KAA5B,EAAmC;EACjC,OAAO,CAAC,EAAEA,KAAK,CAAC8G,mBAAN,IAA6B9G,KAAK,CAAC+G,eAAN,IAAyB/G,KAAK,CAACgH,eAA9D,CAAR;AACD,C,CAAC;AACF;;;AAGA,SAAS3D,cAAT,CAAwB3C,MAAxB,EAAgCC,GAAhC,EAAqCX,KAArC,EAA4C6F,CAA5C,EAA+CC,CAA/C,EAAkDf,KAAlD,EAAyDmB,MAAzD,EAAiE;EAC/D,IAAIY,mBAAmB,GAAG9G,KAAK,CAAC8G,mBAAhC;EACA,IAAIC,eAAe,GAAG/G,KAAK,CAAC+G,eAA5B;EACA,IAAIC,eAAe,GAAGhH,KAAK,CAACgH,eAA5B;EACA,IAAIC,SAAS,GAAGvI,QAAQ,CAACoI,mBAAD,CAAxB;EACAL,MAAM,CAAC9F,GAAD,EAAM,YAAN,EAAoBX,KAAK,CAACkH,iBAAN,IAA2B,CAA/C,CAAN;EACAT,MAAM,CAAC9F,GAAD,EAAM,aAAN,EAAqBX,KAAK,CAACmH,kBAAN,IAA4B,aAAjD,CAAN;EACAV,MAAM,CAAC9F,GAAD,EAAM,eAAN,EAAuBX,KAAK,CAACoH,oBAAN,IAA8B,CAArD,CAAN;EACAX,MAAM,CAAC9F,GAAD,EAAM,eAAN,EAAuBX,KAAK,CAACqH,oBAAN,IAA8B,CAArD,CAAN;;EAEA,IAAIJ,SAAS,IAAIF,eAAe,IAAIC,eAApC,EAAqD;IACnDrG,GAAG,CAAC2G,SAAJ;IACA,IAAIC,gBAAgB,GAAGvH,KAAK,CAACuH,gBAA7B;;IAEA,IAAI,CAACA,gBAAL,EAAuB;MACrB5G,GAAG,CAACE,IAAJ,CAASgF,CAAT,EAAYC,CAAZ,EAAef,KAAf,EAAsBmB,MAAtB;IACD,CAFD,MAEO;MACLrH,eAAe,CAAC2I,SAAhB,CAA0B7G,GAA1B,EAA+B;QAC7BkF,CAAC,EAAEA,CAD0B;QAE7BC,CAAC,EAAEA,CAF0B;QAG7Bf,KAAK,EAAEA,KAHsB;QAI7BmB,MAAM,EAAEA,MAJqB;QAK7BuB,CAAC,EAAEF;MAL0B,CAA/B;IAOD;;IAED5G,GAAG,CAAC+G,SAAJ;EACD;;EAED,IAAIT,SAAJ,EAAe;IACbR,MAAM,CAAC9F,GAAD,EAAM,WAAN,EAAmBmG,mBAAnB,CAAN;;IAEA,IAAI9G,KAAK,CAAC2H,WAAN,IAAqB,IAAzB,EAA+B;MAC7B,IAAIC,mBAAmB,GAAGjH,GAAG,CAAC4C,WAA9B;MACA5C,GAAG,CAAC4C,WAAJ,GAAkBvD,KAAK,CAAC2H,WAAN,GAAoB3H,KAAK,CAACwD,OAA5C;MACA7C,GAAG,CAACkH,IAAJ;MACAlH,GAAG,CAAC4C,WAAJ,GAAkBqE,mBAAlB;IACD,CALD,MAKO;MACLjH,GAAG,CAACkH,IAAJ;IACD;EACF,CAXD,MAWO,IAAIlJ,QAAQ,CAACmI,mBAAD,CAAZ,EAAmC;IACxC,IAAIgB,KAAK,GAAGhB,mBAAmB,CAACgB,KAAhC;IACAA,KAAK,GAAGhJ,WAAW,CAACiJ,mBAAZ,CAAgCD,KAAhC,EAAuC,IAAvC,EAA6CpH,MAA7C,EAAqDsH,eAArD,EAAsElB,mBAAtE,CAAR;;IAEA,IAAIgB,KAAK,IAAIhJ,WAAW,CAACmJ,YAAZ,CAAyBH,KAAzB,CAAb,EAA8C;MAC5CnH,GAAG,CAACuH,SAAJ,CAAcJ,KAAd,EAAqBjC,CAArB,EAAwBC,CAAxB,EAA2Bf,KAA3B,EAAkCmB,MAAlC;IACD;EACF;;EAED,IAAIa,eAAe,IAAIC,eAAvB,EAAwC;IACtCP,MAAM,CAAC9F,GAAD,EAAM,WAAN,EAAmBoG,eAAnB,CAAN;IACAN,MAAM,CAAC9F,GAAD,EAAM,aAAN,EAAqBqG,eAArB,CAAN;;IAEA,IAAIhH,KAAK,CAACmI,aAAN,IAAuB,IAA3B,EAAiC;MAC/B,IAAIP,mBAAmB,GAAGjH,GAAG,CAAC4C,WAA9B;MACA5C,GAAG,CAAC4C,WAAJ,GAAkBvD,KAAK,CAACmI,aAAN,GAAsBnI,KAAK,CAACwD,OAA9C;MACA7C,GAAG,CAACyH,MAAJ;MACAzH,GAAG,CAAC4C,WAAJ,GAAkBqE,mBAAlB;IACD,CALD,MAKO;MACLjH,GAAG,CAACyH,MAAJ;IACD;EACF;AACF;;AAED,SAASJ,eAAT,CAAyBF,KAAzB,EAAgChB,mBAAhC,EAAqD;EACnD;EACA;EACAA,mBAAmB,CAACgB,KAApB,GAA4BA,KAA5B;AACD;;AAED,SAAStF,cAAT,CAAwB6F,GAAxB,EAA6B3H,MAA7B,EAAqCV,KAArC,EAA4Ca,IAA5C,EAAkD;EAChD,IAAI4B,KAAK,GAAGzC,KAAK,CAAC6F,CAAN,IAAW,CAAvB;EACA,IAAInD,KAAK,GAAG1C,KAAK,CAAC8F,CAAN,IAAW,CAAvB;EACA,IAAIzF,SAAS,GAAGL,KAAK,CAACK,SAAtB;EACA,IAAIC,iBAAiB,GAAGN,KAAK,CAACM,iBAA9B,CAJgD,CAIC;;EAEjD,IAAIO,IAAJ,EAAU;IACR,IAAIyH,YAAY,GAAGtI,KAAK,CAACsI,YAAzB;;IAEA,IAAIA,YAAY,YAAYC,KAA5B,EAAmC;MACjC;MACA9F,KAAK,GAAG5B,IAAI,CAACgF,CAAL,GAAS2C,YAAY,CAACF,YAAY,CAAC,CAAD,CAAb,EAAkBzH,IAAI,CAACkE,KAAvB,CAA7B;MACArC,KAAK,GAAG7B,IAAI,CAACiF,CAAL,GAAS0C,YAAY,CAACF,YAAY,CAAC,CAAD,CAAb,EAAkBzH,IAAI,CAACqF,MAAvB,CAA7B;IACD,CAJD,MAIO;MACL,IAAIuC,GAAG,GAAG/H,MAAM,IAAIA,MAAM,CAACgI,qBAAjB,GAAyChI,MAAM,CAACgI,qBAAP,CAA6B7I,sBAA7B,EAAqDG,KAArD,EAA4Da,IAA5D,CAAzC,GAA6GjC,WAAW,CAAC8J,qBAAZ,CAAkC7I,sBAAlC,EAA0DG,KAA1D,EAAiEa,IAAjE,CAAvH;MACA4B,KAAK,GAAGgG,GAAG,CAAC5C,CAAZ;MACAnD,KAAK,GAAG+F,GAAG,CAAC3C,CAAZ,CAHK,CAGU;;MAEfzF,SAAS,GAAGA,SAAS,IAAIoI,GAAG,CAACpI,SAA7B;MACAC,iBAAiB,GAAGA,iBAAiB,IAAImI,GAAG,CAACnI,iBAA7C;IACD,CAdO,CAcN;IACF;;;IAGA,IAAIqI,UAAU,GAAG3I,KAAK,CAAC2I,UAAvB;;IAEA,IAAIA,UAAJ,EAAgB;MACdlG,KAAK,IAAIkG,UAAU,CAAC,CAAD,CAAnB;MACAjG,KAAK,IAAIiG,UAAU,CAAC,CAAD,CAAnB;IACD;EACF;;EAEDN,GAAG,GAAGA,GAAG,IAAI,EAAb;EACAA,GAAG,CAAC5F,KAAJ,GAAYA,KAAZ;EACA4F,GAAG,CAAC3F,KAAJ,GAAYA,KAAZ;EACA2F,GAAG,CAAChI,SAAJ,GAAgBA,SAAhB;EACAgI,GAAG,CAAC/H,iBAAJ,GAAwBA,iBAAxB;EACA,OAAO+H,GAAP;AACD;;AAED,SAAS5B,MAAT,CAAgB9F,GAAhB,EAAqBiI,IAArB,EAA2BC,KAA3B,EAAkC;EAChClI,GAAG,CAACiI,IAAD,CAAH,GAAY7J,SAAS,CAAC4B,GAAD,EAAMiI,IAAN,EAAYC,KAAZ,CAArB;EACA,OAAOlI,GAAG,CAACiI,IAAD,CAAV;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAASxE,SAAT,CAAmBgE,MAAnB,EAA2B7D,SAA3B,EAAsC;EACpC,OAAO6D,MAAM,IAAI,IAAV,IAAkB7D,SAAS,IAAI,CAA/B,IAAoC6D,MAAM,KAAK,aAA/C,IAAgEA,MAAM,KAAK,MAA3E,GAAoF,IAApF,CAAyF;EAAzF,EACLA,MAAM,CAACN,KAAP,IAAgBM,MAAM,CAACU,UAAvB,GAAoC,MAApC,GAA6CV,MAD/C;AAED;;AAED,SAAS9D,OAAT,CAAiBuD,IAAjB,EAAuB;EACrB,OAAOA,IAAI,IAAI,IAAR,IAAgBA,IAAI,KAAK,MAAzB,GAAkC,IAAlC,CAAuC;EAAvC,EACLA,IAAI,CAACC,KAAL,IAAcD,IAAI,CAACiB,UAAnB,GAAgC,MAAhC,GAAyCjB,IAD3C;AAED;;AAED,SAASW,YAAT,CAAsBK,KAAtB,EAA6BE,QAA7B,EAAuC;EACrC,IAAI,OAAOF,KAAP,KAAiB,QAArB,EAA+B;IAC7B,IAAIA,KAAK,CAACG,WAAN,CAAkB,GAAlB,KAA0B,CAA9B,EAAiC;MAC/B,OAAOC,UAAU,CAACJ,KAAD,CAAV,GAAoB,GAApB,GAA0BE,QAAjC;IACD;;IAED,OAAOE,UAAU,CAACJ,KAAD,CAAjB;EACD;;EAED,OAAOA,KAAP;AACD;;AAED,SAASvF,kBAAT,CAA4BuC,CAA5B,EAA+BxF,SAA/B,EAA0CG,WAA1C,EAAuD;EACrD,OAAOH,SAAS,KAAK,OAAd,GAAwBwF,CAAC,GAAGrF,WAAW,CAAC,CAAD,CAAvC,GAA6CH,SAAS,KAAK,QAAd,GAAyBwF,CAAC,GAAGrF,WAAW,CAAC,CAAD,CAAX,GAAiB,CAArB,GAAyBA,WAAW,CAAC,CAAD,CAAX,GAAiB,CAAnE,GAAuEqF,CAAC,GAAGrF,WAAW,CAAC,CAAD,CAA1I;AACD;AACD;AACA;AACA;AACA;AACA;;;AAGA,SAAS0I,YAAT,CAAsBtI,IAAtB,EAA4BZ,KAA5B,EAAmC;EACjC,OAAOY,IAAI,IAAI,IAAR,KAAiBA,IAAI,IAAIZ,KAAK,CAAC8G,mBAAd,IAAqC9G,KAAK,CAAC+G,eAAN,IAAyB/G,KAAK,CAACgH,eAApE,IAAuFhH,KAAK,CAACQ,WAA9G,CAAP;AACD;;AAED2I,OAAO,CAACpJ,kBAAR,GAA6BA,kBAA7B;AACAoJ,OAAO,CAAC1I,UAAR,GAAqBA,UAArB;AACA0I,OAAO,CAAC3G,cAAR,GAAyBA,cAAzB;AACA2G,OAAO,CAAC/E,SAAR,GAAoBA,SAApB;AACA+E,OAAO,CAAC7E,OAAR,GAAkBA,OAAlB;AACA6E,OAAO,CAACX,YAAR,GAAuBA,YAAvB;AACAW,OAAO,CAACD,YAAR,GAAuBA,YAAvB"},"metadata":{},"sourceType":"script"}