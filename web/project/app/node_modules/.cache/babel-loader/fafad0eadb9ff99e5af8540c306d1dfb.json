{"ast":null,"code":"// Myers' Diff Algorithm\n// Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js\nfunction Diff() {}\n\nDiff.prototype = {\n  diff: function (oldArr, newArr, equals) {\n    if (!equals) {\n      equals = function (a, b) {\n        return a === b;\n      };\n    }\n\n    this.equals = equals;\n    var self = this;\n    oldArr = oldArr.slice();\n    newArr = newArr.slice(); // Allow subclasses to massage the input prior to running\n\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      var indices = [];\n\n      for (var i = 0; i < newArr.length; i++) {\n        indices.push(i);\n      } // Identity per the equality and tokenizer\n\n\n      return [{\n        indices: indices,\n        count: newArr.length\n      }];\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath;\n        var addPath = bestPath[diagonalPath - 1];\n        var removePath = bestPath[diagonalPath + 1];\n        var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen;\n        var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        oldPos = self.extractCommon(basePath, newArr, oldArr, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newArr, oldArr);\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    while (editLength <= maxEditLength) {\n      var ret = execEditLength();\n\n      if (ret) {\n        return ret;\n      }\n    }\n  },\n  pushComponent: function (components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function (basePath, newArr, oldArr, diagonalPath) {\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var newPos = basePath.newPos;\n    var oldPos = newPos - diagonalPath;\n    var commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  tokenize: function (value) {\n    return value.slice();\n  },\n  join: function (value) {\n    return value.slice();\n  }\n};\n\nfunction buildValues(diff, components, newArr, oldArr) {\n  var componentPos = 0;\n  var componentLen = components.length;\n  var newPos = 0;\n  var oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      var indices = [];\n\n      for (var i = newPos; i < newPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      var indices = [];\n\n      for (var i = oldPos; i < oldPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      oldPos += component.count;\n    }\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar arrayDiff = new Diff();\n\nfunction _default(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nmodule.exports = _default;","map":{"version":3,"names":["Diff","prototype","diff","oldArr","newArr","equals","a","b","self","slice","newLen","length","oldLen","editLength","maxEditLength","bestPath","newPos","components","oldPos","extractCommon","indices","i","push","count","execEditLength","diagonalPath","basePath","addPath","removePath","undefined","canAdd","canRemove","clonePath","pushComponent","buildValues","ret","added","removed","last","commonCount","tokenize","value","join","componentPos","componentLen","component","path","arrayDiff","_default","callback","module","exports"],"sources":["D:/Desktop/project/app/node_modules/zrender/lib/core/arrayDiff2.js"],"sourcesContent":["// Myers' Diff Algorithm\n// Modified from https://github.com/kpdecker/jsdiff/blob/master/src/diff/base.js\nfunction Diff() {}\n\nDiff.prototype = {\n  diff: function (oldArr, newArr, equals) {\n    if (!equals) {\n      equals = function (a, b) {\n        return a === b;\n      };\n    }\n\n    this.equals = equals;\n    var self = this;\n    oldArr = oldArr.slice();\n    newArr = newArr.slice(); // Allow subclasses to massage the input prior to running\n\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var editLength = 1;\n    var maxEditLength = newLen + oldLen;\n    var bestPath = [{\n      newPos: -1,\n      components: []\n    }]; // Seed editLength = 0, i.e. the content starts with the same values\n\n    var oldPos = this.extractCommon(bestPath[0], newArr, oldArr, 0);\n\n    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n      var indices = [];\n\n      for (var i = 0; i < newArr.length; i++) {\n        indices.push(i);\n      } // Identity per the equality and tokenizer\n\n\n      return [{\n        indices: indices,\n        count: newArr.length\n      }];\n    } // Main worker method. checks all permutations of a given edit length for acceptance.\n\n\n    function execEditLength() {\n      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n        var basePath;\n        var addPath = bestPath[diagonalPath - 1];\n        var removePath = bestPath[diagonalPath + 1];\n        var oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\n        if (addPath) {\n          // No one else is going to attempt to use this value, clear it\n          bestPath[diagonalPath - 1] = undefined;\n        }\n\n        var canAdd = addPath && addPath.newPos + 1 < newLen;\n        var canRemove = removePath && 0 <= oldPos && oldPos < oldLen;\n\n        if (!canAdd && !canRemove) {\n          // If this path is a terminal then prune\n          bestPath[diagonalPath] = undefined;\n          continue;\n        } // Select the diagonal that we want to branch from. We select the prior\n        // path whose position in the new string is the farthest from the origin\n        // and does not pass the bounds of the diff graph\n\n\n        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n          basePath = clonePath(removePath);\n          self.pushComponent(basePath.components, undefined, true);\n        } else {\n          basePath = addPath; // No need to clone, we've pulled it from the list\n\n          basePath.newPos++;\n          self.pushComponent(basePath.components, true, undefined);\n        }\n\n        oldPos = self.extractCommon(basePath, newArr, oldArr, diagonalPath); // If we have hit the end of both strings, then we are done\n\n        if (basePath.newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n          return buildValues(self, basePath.components, newArr, oldArr);\n        } else {\n          // Otherwise track this path as a potential candidate and continue.\n          bestPath[diagonalPath] = basePath;\n        }\n      }\n\n      editLength++;\n    }\n\n    while (editLength <= maxEditLength) {\n      var ret = execEditLength();\n\n      if (ret) {\n        return ret;\n      }\n    }\n  },\n  pushComponent: function (components, added, removed) {\n    var last = components[components.length - 1];\n\n    if (last && last.added === added && last.removed === removed) {\n      // We need to clone here as the component clone operation is just\n      // as shallow array clone\n      components[components.length - 1] = {\n        count: last.count + 1,\n        added: added,\n        removed: removed\n      };\n    } else {\n      components.push({\n        count: 1,\n        added: added,\n        removed: removed\n      });\n    }\n  },\n  extractCommon: function (basePath, newArr, oldArr, diagonalPath) {\n    var newLen = newArr.length;\n    var oldLen = oldArr.length;\n    var newPos = basePath.newPos;\n    var oldPos = newPos - diagonalPath;\n    var commonCount = 0;\n\n    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newArr[newPos + 1], oldArr[oldPos + 1])) {\n      newPos++;\n      oldPos++;\n      commonCount++;\n    }\n\n    if (commonCount) {\n      basePath.components.push({\n        count: commonCount\n      });\n    }\n\n    basePath.newPos = newPos;\n    return oldPos;\n  },\n  tokenize: function (value) {\n    return value.slice();\n  },\n  join: function (value) {\n    return value.slice();\n  }\n};\n\nfunction buildValues(diff, components, newArr, oldArr) {\n  var componentPos = 0;\n  var componentLen = components.length;\n  var newPos = 0;\n  var oldPos = 0;\n\n  for (; componentPos < componentLen; componentPos++) {\n    var component = components[componentPos];\n\n    if (!component.removed) {\n      var indices = [];\n\n      for (var i = newPos; i < newPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      newPos += component.count; // Common case\n\n      if (!component.added) {\n        oldPos += component.count;\n      }\n    } else {\n      var indices = [];\n\n      for (var i = oldPos; i < oldPos + component.count; i++) {\n        indices.push(i);\n      }\n\n      component.indices = indices;\n      oldPos += component.count;\n    }\n  }\n\n  return components;\n}\n\nfunction clonePath(path) {\n  return {\n    newPos: path.newPos,\n    components: path.components.slice(0)\n  };\n}\n\nvar arrayDiff = new Diff();\n\nfunction _default(oldArr, newArr, callback) {\n  return arrayDiff.diff(oldArr, newArr, callback);\n}\n\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}