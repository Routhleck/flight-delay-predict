{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\n\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;","map":{"version":3,"names":["_helper","require","prepareDataCoordInfo","getStackedOnPoint","diffData","oldData","newData","diffResult","diff","add","idx","push","cmd","update","newIdx","oldIdx","idx1","remove","execute","_default","oldStackedOnPoints","newStackedOnPoints","oldCoordSys","newCoordSys","oldValueOrigin","newValueOrigin","currPoints","nextPoints","currStackedPoints","nextStackedPoints","status","sortedIndices","rawIndices","newDataOldCoordInfo","oldDataNewCoordInfo","i","length","diffItem","pointAdded","currentPt","getItemLayout","nextPt","isNaN","slice","getRawIndex","dataToPoint","get","dataDimsForPoint","rawIndex","sort","a","b","sortedCurrPoints","sortedNextPoints","sortedCurrStackedPoints","sortedNextStackedPoints","sortedStatus","current","next","stackedOnCurrent","stackedOnNext","module","exports"],"sources":["D:/Desktop/project/project/project/app/node_modules/echarts/lib/chart/line/lineAnimationDiff.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _helper = require(\"./helper\");\n\nvar prepareDataCoordInfo = _helper.prepareDataCoordInfo;\nvar getStackedOnPoint = _helper.getStackedOnPoint;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// var arrayDiff = require('zrender/src/core/arrayDiff');\n// 'zrender/src/core/arrayDiff' has been used before, but it did\n// not do well in performance when roam with fixed dataZoom window.\n// function convertToIntId(newIdList, oldIdList) {\n//     // Generate int id instead of string id.\n//     // Compare string maybe slow in score function of arrDiff\n//     // Assume id in idList are all unique\n//     var idIndicesMap = {};\n//     var idx = 0;\n//     for (var i = 0; i < newIdList.length; i++) {\n//         idIndicesMap[newIdList[i]] = idx;\n//         newIdList[i] = idx++;\n//     }\n//     for (var i = 0; i < oldIdList.length; i++) {\n//         var oldId = oldIdList[i];\n//         // Same with newIdList\n//         if (idIndicesMap[oldId]) {\n//             oldIdList[i] = idIndicesMap[oldId];\n//         }\n//         else {\n//             oldIdList[i] = idx++;\n//         }\n//     }\n// }\nfunction diffData(oldData, newData) {\n  var diffResult = [];\n  newData.diff(oldData).add(function (idx) {\n    diffResult.push({\n      cmd: '+',\n      idx: idx\n    });\n  }).update(function (newIdx, oldIdx) {\n    diffResult.push({\n      cmd: '=',\n      idx: oldIdx,\n      idx1: newIdx\n    });\n  }).remove(function (idx) {\n    diffResult.push({\n      cmd: '-',\n      idx: idx\n    });\n  }).execute();\n  return diffResult;\n}\n\nfunction _default(oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {\n  var diff = diffData(oldData, newData); // var newIdList = newData.mapArray(newData.getId);\n  // var oldIdList = oldData.mapArray(oldData.getId);\n  // convertToIntId(newIdList, oldIdList);\n  // // FIXME One data ?\n  // diff = arrayDiff(oldIdList, newIdList);\n\n  var currPoints = [];\n  var nextPoints = []; // Points for stacking base line\n\n  var currStackedPoints = [];\n  var nextStackedPoints = [];\n  var status = [];\n  var sortedIndices = [];\n  var rawIndices = [];\n  var newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin);\n  var oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);\n\n  for (var i = 0; i < diff.length; i++) {\n    var diffItem = diff[i];\n    var pointAdded = true; // FIXME, animation is not so perfect when dataZoom window moves fast\n    // Which is in case remvoing or add more than one data in the tail or head\n\n    switch (diffItem.cmd) {\n      case '=':\n        var currentPt = oldData.getItemLayout(diffItem.idx);\n        var nextPt = newData.getItemLayout(diffItem.idx1); // If previous data is NaN, use next point directly\n\n        if (isNaN(currentPt[0]) || isNaN(currentPt[1])) {\n          currentPt = nextPt.slice();\n        }\n\n        currPoints.push(currentPt);\n        nextPoints.push(nextPt);\n        currStackedPoints.push(oldStackedOnPoints[diffItem.idx]);\n        nextStackedPoints.push(newStackedOnPoints[diffItem.idx1]);\n        rawIndices.push(newData.getRawIndex(diffItem.idx1));\n        break;\n\n      case '+':\n        var idx = diffItem.idx;\n        currPoints.push(oldCoordSys.dataToPoint([newData.get(newDataOldCoordInfo.dataDimsForPoint[0], idx), newData.get(newDataOldCoordInfo.dataDimsForPoint[1], idx)]));\n        nextPoints.push(newData.getItemLayout(idx).slice());\n        currStackedPoints.push(getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, idx));\n        nextStackedPoints.push(newStackedOnPoints[idx]);\n        rawIndices.push(newData.getRawIndex(idx));\n        break;\n\n      case '-':\n        var idx = diffItem.idx;\n        var rawIndex = oldData.getRawIndex(idx); // Data is replaced. In the case of dynamic data queue\n        // FIXME FIXME FIXME\n\n        if (rawIndex !== idx) {\n          currPoints.push(oldData.getItemLayout(idx));\n          nextPoints.push(newCoordSys.dataToPoint([oldData.get(oldDataNewCoordInfo.dataDimsForPoint[0], idx), oldData.get(oldDataNewCoordInfo.dataDimsForPoint[1], idx)]));\n          currStackedPoints.push(oldStackedOnPoints[idx]);\n          nextStackedPoints.push(getStackedOnPoint(oldDataNewCoordInfo, newCoordSys, oldData, idx));\n          rawIndices.push(rawIndex);\n        } else {\n          pointAdded = false;\n        }\n\n    } // Original indices\n\n\n    if (pointAdded) {\n      status.push(diffItem);\n      sortedIndices.push(sortedIndices.length);\n    }\n  } // Diff result may be crossed if all items are changed\n  // Sort by data index\n\n\n  sortedIndices.sort(function (a, b) {\n    return rawIndices[a] - rawIndices[b];\n  });\n  var sortedCurrPoints = [];\n  var sortedNextPoints = [];\n  var sortedCurrStackedPoints = [];\n  var sortedNextStackedPoints = [];\n  var sortedStatus = [];\n\n  for (var i = 0; i < sortedIndices.length; i++) {\n    var idx = sortedIndices[i];\n    sortedCurrPoints[i] = currPoints[idx];\n    sortedNextPoints[i] = nextPoints[idx];\n    sortedCurrStackedPoints[i] = currStackedPoints[idx];\n    sortedNextStackedPoints[i] = nextStackedPoints[idx];\n    sortedStatus[i] = status[idx];\n  }\n\n  return {\n    current: sortedCurrPoints,\n    next: sortedNextPoints,\n    stackedOnCurrent: sortedCurrStackedPoints,\n    stackedOnNext: sortedNextStackedPoints,\n    status: sortedStatus\n  };\n}\n\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}