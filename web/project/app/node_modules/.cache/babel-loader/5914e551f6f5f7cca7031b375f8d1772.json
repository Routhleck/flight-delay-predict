{"ast":null,"code":"var Definable = require(\"./Definable\");\n\nvar zrUtil = require(\"../../core/util\");\n\nvar matrix = require(\"../../core/matrix\");\n/**\n * @file Manages SVG clipPath elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG clipPath elements.\n *\n * @class\n * @extends Definable\n * @param   {number}     zrId    zrender instance id\n * @param   {SVGElement} svgRoot root of SVG document\n */\n\n\nfunction ClippathManager(zrId, svgRoot) {\n  Definable.call(this, zrId, svgRoot, 'clipPath', '__clippath_in_use__');\n}\n\nzrUtil.inherits(ClippathManager, Definable);\n/**\n * Update clipPath.\n *\n * @param {Displayable} displayable displayable element\n */\n\nClippathManager.prototype.update = function (displayable) {\n  var svgEl = this.getSvgElement(displayable);\n\n  if (svgEl) {\n    this.updateDom(svgEl, displayable.__clipPaths, false);\n  }\n\n  var textEl = this.getTextSvgElement(displayable);\n\n  if (textEl) {\n    // Make another clipPath for text, since it's transform\n    // matrix is not the same with svgElement\n    this.updateDom(textEl, displayable.__clipPaths, true);\n  }\n\n  this.markUsed(displayable);\n};\n/**\n * Create an SVGElement of displayable and create a <clipPath> of its\n * clipPath\n *\n * @param {Displayable} parentEl  parent element\n * @param {ClipPath[]}  clipPaths clipPaths of parent element\n * @param {boolean}     isText    if parent element is Text\n */\n\n\nClippathManager.prototype.updateDom = function (parentEl, clipPaths, isText) {\n  if (clipPaths && clipPaths.length > 0) {\n    // Has clipPath, create <clipPath> with the first clipPath\n    var defs = this.getDefs(true);\n    var clipPath = clipPaths[0];\n    var clipPathEl;\n    var id;\n    var dom = isText ? '_textDom' : '_dom';\n\n    if (clipPath[dom]) {\n      // Use a dom that is already in <defs>\n      id = clipPath[dom].getAttribute('id');\n      clipPathEl = clipPath[dom]; // Use a dom that is already in <defs>\n\n      if (!defs.contains(clipPathEl)) {\n        // This happens when set old clipPath that has\n        // been previously removed\n        defs.appendChild(clipPathEl);\n      }\n    } else {\n      // New <clipPath>\n      id = 'zr' + this._zrId + '-clip-' + this.nextId;\n      ++this.nextId;\n      clipPathEl = this.createElement('clipPath');\n      clipPathEl.setAttribute('id', id);\n      defs.appendChild(clipPathEl);\n      clipPath[dom] = clipPathEl;\n    } // Build path and add to <clipPath>\n\n\n    var svgProxy = this.getSvgProxy(clipPath);\n\n    if (clipPath.transform && clipPath.parent.invTransform && !isText) {\n      /**\n       * If a clipPath has a parent with transform, the transform\n       * of parent should not be considered when setting transform\n       * of clipPath. So we need to transform back from parent's\n       * transform, which is done by multiplying parent's inverse\n       * transform.\n       */\n      // Store old transform\n      var transform = Array.prototype.slice.call(clipPath.transform); // Transform back from parent, and brush path\n\n      matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);\n      svgProxy.brush(clipPath); // Set back transform of clipPath\n\n      clipPath.transform = transform;\n    } else {\n      svgProxy.brush(clipPath);\n    }\n\n    var pathEl = this.getSvgElement(clipPath);\n    clipPathEl.innerHTML = '';\n    /**\n     * Use `cloneNode()` here to appendChild to multiple parents,\n     * which may happend when Text and other shapes are using the same\n     * clipPath. Since Text will create an extra clipPath DOM due to\n     * different transform rules.\n     */\n\n    clipPathEl.appendChild(pathEl.cloneNode());\n    parentEl.setAttribute('clip-path', 'url(#' + id + ')');\n\n    if (clipPaths.length > 1) {\n      // Make the other clipPaths recursively\n      this.updateDom(clipPathEl, clipPaths.slice(1), isText);\n    }\n  } else {\n    // No clipPath\n    if (parentEl) {\n      parentEl.setAttribute('clip-path', 'none');\n    }\n  }\n};\n/**\n * Mark a single clipPath to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\n\nClippathManager.prototype.markUsed = function (displayable) {\n  var that = this; // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n\n  if (displayable.__clipPaths) {\n    zrUtil.each(displayable.__clipPaths, function (clipPath) {\n      if (clipPath._dom) {\n        Definable.prototype.markUsed.call(that, clipPath._dom);\n      }\n\n      if (clipPath._textDom) {\n        Definable.prototype.markUsed.call(that, clipPath._textDom);\n      }\n    });\n  }\n};\n\nvar _default = ClippathManager;\nmodule.exports = _default;","map":{"version":3,"names":["Definable","require","zrUtil","matrix","ClippathManager","zrId","svgRoot","call","inherits","prototype","update","displayable","svgEl","getSvgElement","updateDom","__clipPaths","textEl","getTextSvgElement","markUsed","parentEl","clipPaths","isText","length","defs","getDefs","clipPath","clipPathEl","id","dom","getAttribute","contains","appendChild","_zrId","nextId","createElement","setAttribute","svgProxy","getSvgProxy","transform","parent","invTransform","Array","slice","mul","brush","pathEl","innerHTML","cloneNode","that","each","_dom","_textDom","_default","module","exports"],"sources":["F:/Wechatfile/WeChat Files/wxid_cre715h75uat22/FileStorage/MsgAttach/843d799c0bb5fd5ab828b2371b6d88b0/File/2022-07/project/project/app/node_modules/zrender/lib/svg/helper/ClippathManager.js"],"sourcesContent":["var Definable = require(\"./Definable\");\n\nvar zrUtil = require(\"../../core/util\");\n\nvar matrix = require(\"../../core/matrix\");\n\n/**\n * @file Manages SVG clipPath elements.\n * @author Zhang Wenli\n */\n\n/**\n * Manages SVG clipPath elements.\n *\n * @class\n * @extends Definable\n * @param   {number}     zrId    zrender instance id\n * @param   {SVGElement} svgRoot root of SVG document\n */\nfunction ClippathManager(zrId, svgRoot) {\n  Definable.call(this, zrId, svgRoot, 'clipPath', '__clippath_in_use__');\n}\n\nzrUtil.inherits(ClippathManager, Definable);\n/**\n * Update clipPath.\n *\n * @param {Displayable} displayable displayable element\n */\n\nClippathManager.prototype.update = function (displayable) {\n  var svgEl = this.getSvgElement(displayable);\n\n  if (svgEl) {\n    this.updateDom(svgEl, displayable.__clipPaths, false);\n  }\n\n  var textEl = this.getTextSvgElement(displayable);\n\n  if (textEl) {\n    // Make another clipPath for text, since it's transform\n    // matrix is not the same with svgElement\n    this.updateDom(textEl, displayable.__clipPaths, true);\n  }\n\n  this.markUsed(displayable);\n};\n/**\n * Create an SVGElement of displayable and create a <clipPath> of its\n * clipPath\n *\n * @param {Displayable} parentEl  parent element\n * @param {ClipPath[]}  clipPaths clipPaths of parent element\n * @param {boolean}     isText    if parent element is Text\n */\n\n\nClippathManager.prototype.updateDom = function (parentEl, clipPaths, isText) {\n  if (clipPaths && clipPaths.length > 0) {\n    // Has clipPath, create <clipPath> with the first clipPath\n    var defs = this.getDefs(true);\n    var clipPath = clipPaths[0];\n    var clipPathEl;\n    var id;\n    var dom = isText ? '_textDom' : '_dom';\n\n    if (clipPath[dom]) {\n      // Use a dom that is already in <defs>\n      id = clipPath[dom].getAttribute('id');\n      clipPathEl = clipPath[dom]; // Use a dom that is already in <defs>\n\n      if (!defs.contains(clipPathEl)) {\n        // This happens when set old clipPath that has\n        // been previously removed\n        defs.appendChild(clipPathEl);\n      }\n    } else {\n      // New <clipPath>\n      id = 'zr' + this._zrId + '-clip-' + this.nextId;\n      ++this.nextId;\n      clipPathEl = this.createElement('clipPath');\n      clipPathEl.setAttribute('id', id);\n      defs.appendChild(clipPathEl);\n      clipPath[dom] = clipPathEl;\n    } // Build path and add to <clipPath>\n\n\n    var svgProxy = this.getSvgProxy(clipPath);\n\n    if (clipPath.transform && clipPath.parent.invTransform && !isText) {\n      /**\n       * If a clipPath has a parent with transform, the transform\n       * of parent should not be considered when setting transform\n       * of clipPath. So we need to transform back from parent's\n       * transform, which is done by multiplying parent's inverse\n       * transform.\n       */\n      // Store old transform\n      var transform = Array.prototype.slice.call(clipPath.transform); // Transform back from parent, and brush path\n\n      matrix.mul(clipPath.transform, clipPath.parent.invTransform, clipPath.transform);\n      svgProxy.brush(clipPath); // Set back transform of clipPath\n\n      clipPath.transform = transform;\n    } else {\n      svgProxy.brush(clipPath);\n    }\n\n    var pathEl = this.getSvgElement(clipPath);\n    clipPathEl.innerHTML = '';\n    /**\n     * Use `cloneNode()` here to appendChild to multiple parents,\n     * which may happend when Text and other shapes are using the same\n     * clipPath. Since Text will create an extra clipPath DOM due to\n     * different transform rules.\n     */\n\n    clipPathEl.appendChild(pathEl.cloneNode());\n    parentEl.setAttribute('clip-path', 'url(#' + id + ')');\n\n    if (clipPaths.length > 1) {\n      // Make the other clipPaths recursively\n      this.updateDom(clipPathEl, clipPaths.slice(1), isText);\n    }\n  } else {\n    // No clipPath\n    if (parentEl) {\n      parentEl.setAttribute('clip-path', 'none');\n    }\n  }\n};\n/**\n * Mark a single clipPath to be used\n *\n * @param {Displayable} displayable displayable element\n */\n\n\nClippathManager.prototype.markUsed = function (displayable) {\n  var that = this; // displayable.__clipPaths can only be `null`/`undefined` or an non-empty array.\n\n  if (displayable.__clipPaths) {\n    zrUtil.each(displayable.__clipPaths, function (clipPath) {\n      if (clipPath._dom) {\n        Definable.prototype.markUsed.call(that, clipPath._dom);\n      }\n\n      if (clipPath._textDom) {\n        Definable.prototype.markUsed.call(that, clipPath._textDom);\n      }\n    });\n  }\n};\n\nvar _default = ClippathManager;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}