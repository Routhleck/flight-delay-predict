{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _util = require(\"zrender/lib/core/util\");\n\nvar each = _util.each;\nvar map = _util.map;\nvar isFunction = _util.isFunction;\nvar createHashMap = _util.createHashMap;\nvar noop = _util.noop;\n\nvar _task = require(\"./task\");\n\nvar createTask = _task.createTask;\n\nvar _component = require(\"../util/component\");\n\nvar getUID = _component.getUID;\n\nvar GlobalModel = require(\"../model/Global\");\n\nvar ExtensionAPI = require(\"../ExtensionAPI\");\n\nvar _model = require(\"../util/model\");\n\nvar normalizeToArray = _model.normalizeToArray;\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/stream/Scheduler\n */\n\n/**\n * @constructor\n */\n\nfunction Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n  this.ecInstance = ecInstance;\n  this.api = api;\n  this.unfinished; // Fix current processors in case that in some rear cases that\n  // processors might be registered after echarts instance created.\n  // Register processors incrementally for a echarts instance is\n  // not supported by this stream architecture.\n\n  var dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n  var visualHandlers = this._visualHandlers = visualHandlers.slice();\n  this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  /**\n   * @private\n   * @type {\n   *     [handlerUID: string]: {\n   *         seriesTaskMap?: {\n   *             [seriesUID: string]: Task\n   *         },\n   *         overallTask?: Task\n   *     }\n   * }\n   */\n\n  this._stageTaskMap = createHashMap();\n}\n\nvar proto = Scheduler.prototype;\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} payload\n */\n\nproto.restoreData = function (ecModel, payload) {\n  // TODO: Only restore needed series and components, but not all components.\n  // Currently `restoreData` of all of the series and component will be called.\n  // But some independent components like `title`, `legend`, `graphic`, `toolbox`,\n  // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,\n  // and some components like coordinate system, axes, dataZoom, visualMap only\n  // need their target series refresh.\n  // (1) If we are implementing this feature some day, we should consider these cases:\n  // if a data processor depends on a component (e.g., dataZoomProcessor depends\n  // on the settings of `dataZoom`), it should be re-performed if the component\n  // is modified by `setOption`.\n  // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,\n  // it should be re-performed when the result array of `getTargetSeries` changed.\n  // We use `dependencies` to cover these issues.\n  // (3) How to update target series when coordinate system related components modified.\n  // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,\n  // and this case all of the tasks will be set as dirty.\n  ecModel.restoreData(payload); // Theoretically an overall task not only depends on each of its target series, but also\n  // depends on all of the series.\n  // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks\n  // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure\n  // that the overall task is set as dirty and to be performed, otherwise it probably cause\n  // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it\n  // probably cause state chaos (consider `dataZoomProcessor`).\n\n  this._stageTaskMap.each(function (taskRecord) {\n    var overallTask = taskRecord.overallTask;\n    overallTask && overallTask.dirty();\n  });\n}; // If seriesModel provided, incremental threshold is check by series data.\n\n\nproto.getPerformArgs = function (task, isBlock) {\n  // For overall task\n  if (!task.__pipeline) {\n    return;\n  }\n\n  var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n  var pCtx = pipeline.context;\n  var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n  var step = incremental ? pipeline.step : null;\n  var modDataCount = pCtx && pCtx.modDataCount;\n  var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n  return {\n    step: step,\n    modBy: modBy,\n    modDataCount: modDataCount\n  };\n};\n\nproto.getPipeline = function (pipelineId) {\n  return this._pipelineMap.get(pipelineId);\n};\n/**\n * Current, progressive rendering starts from visual and layout.\n * Always detect render mode in the same stage, avoiding that incorrect\n * detection caused by data filtering.\n * Caution:\n * `updateStreamModes` use `seriesModel.getData()`.\n */\n\n\nproto.updateStreamModes = function (seriesModel, view) {\n  var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n  var data = seriesModel.getData();\n  var dataLen = data.count(); // `progressiveRender` means that can render progressively in each\n  // animation frame. Note that some types of series do not provide\n  // `view.incrementalPrepareRender` but support `chart.appendData`. We\n  // use the term `incremental` but not `progressive` to describe the\n  // case that `chart.appendData`.\n\n  var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n  var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold'); // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.\n  // see `test/candlestick-large3.html`\n\n  var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n  seriesModel.pipelineContext = pipeline.context = {\n    progressiveRender: progressiveRender,\n    modDataCount: modDataCount,\n    large: large\n  };\n};\n\nproto.restorePipelines = function (ecModel) {\n  var scheduler = this;\n  var pipelineMap = scheduler._pipelineMap = createHashMap();\n  ecModel.eachSeries(function (seriesModel) {\n    var progressive = seriesModel.getProgressive();\n    var pipelineId = seriesModel.uid;\n    pipelineMap.set(pipelineId, {\n      id: pipelineId,\n      head: null,\n      tail: null,\n      threshold: seriesModel.getProgressiveThreshold(),\n      progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n      blockIndex: -1,\n      step: Math.round(progressive || 700),\n      count: 0\n    });\n    pipe(scheduler, seriesModel, seriesModel.dataTask);\n  });\n};\n\nproto.prepareStageTasks = function () {\n  var stageTaskMap = this._stageTaskMap;\n  var ecModel = this.ecInstance.getModel();\n  var api = this.api;\n  each(this._allHandlers, function (handler) {\n    var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);\n    handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);\n    handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);\n  }, this);\n};\n\nproto.prepareView = function (view, model, ecModel, api) {\n  var renderTask = view.renderTask;\n  var context = renderTask.context;\n  context.model = model;\n  context.ecModel = ecModel;\n  context.api = api;\n  renderTask.__block = !view.incrementalPrepareRender;\n  pipe(this, model, renderTask);\n};\n\nproto.performDataProcessorTasks = function (ecModel, payload) {\n  // If we do not use `block` here, it should be considered when to update modes.\n  performStageTasks(this, this._dataProcessorHandlers, ecModel, payload, {\n    block: true\n  });\n}; // opt\n// opt.visualType: 'visual' or 'layout'\n// opt.setDirty\n\n\nproto.performVisualTasks = function (ecModel, payload, opt) {\n  performStageTasks(this, this._visualHandlers, ecModel, payload, opt);\n};\n\nfunction performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {\n  opt = opt || {};\n  var unfinished;\n  each(stageHandlers, function (stageHandler, idx) {\n    if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n      return;\n    }\n\n    var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n    var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n    var overallTask = stageHandlerRecord.overallTask;\n\n    if (overallTask) {\n      var overallNeedDirty;\n      var agentStubMap = overallTask.agentStubMap;\n      agentStubMap.each(function (stub) {\n        if (needSetDirty(opt, stub)) {\n          stub.dirty();\n          overallNeedDirty = true;\n        }\n      });\n      overallNeedDirty && overallTask.dirty();\n      updatePayload(overallTask, payload);\n      var performArgs = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,\n      // then execute the overall task. And stub will call seriesModel.setData,\n      // which ensures that in the overallTask seriesModel.getData() will not\n      // return incorrect data.\n\n      agentStubMap.each(function (stub) {\n        stub.perform(performArgs);\n      });\n      unfinished |= overallTask.perform(performArgs);\n    } else if (seriesTaskMap) {\n      seriesTaskMap.each(function (task, pipelineId) {\n        if (needSetDirty(opt, task)) {\n          task.dirty();\n        }\n\n        var performArgs = scheduler.getPerformArgs(task, opt.block); // FIXME\n        // if intending to decalare `performRawSeries` in handlers, only\n        // stream-independent (specifically, data item independent) operations can be\n        // performed. Because is a series is filtered, most of the tasks will not\n        // be performed. A stream-dependent operation probably cause wrong biz logic.\n        // Perhaps we should not provide a separate callback for this case instead\n        // of providing the config `performRawSeries`. The stream-dependent operaions\n        // and stream-independent operations should better not be mixed.\n\n        performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n        updatePayload(task, payload);\n        unfinished |= task.perform(performArgs);\n      });\n    }\n  });\n\n  function needSetDirty(opt, task) {\n    return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n  }\n\n  scheduler.unfinished |= unfinished;\n}\n\nproto.performSeriesTasks = function (ecModel) {\n  var unfinished;\n  ecModel.eachSeries(function (seriesModel) {\n    // Progress to the end for dataInit and dataRestore.\n    unfinished |= seriesModel.dataTask.perform();\n  });\n  this.unfinished |= unfinished;\n};\n\nproto.plan = function () {\n  // Travel pipelines, check block.\n  this._pipelineMap.each(function (pipeline) {\n    var task = pipeline.tail;\n\n    do {\n      if (task.__block) {\n        pipeline.blockIndex = task.__idxInPipeline;\n        break;\n      }\n\n      task = task.getUpstream();\n    } while (task);\n  });\n};\n\nvar updatePayload = proto.updatePayload = function (task, payload) {\n  payload !== 'remain' && (task.context.payload = payload);\n};\n\nfunction createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap());\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,\n  // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,\n  // it works but it may cause other irrelevant charts blocked.\n\n  if (stageHandler.createOnAllSeries) {\n    ecModel.eachRawSeries(create);\n  } else if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, create);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(create);\n  }\n\n  function create(seriesModel) {\n    var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.\n    // Reuse original task instance.\n\n    var task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask({\n      plan: seriesTaskPlan,\n      reset: seriesTaskReset,\n      count: seriesTaskCount\n    }));\n    task.context = {\n      model: seriesModel,\n      ecModel: ecModel,\n      api: api,\n      useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n      plan: stageHandler.plan,\n      reset: stageHandler.reset,\n      scheduler: scheduler\n    };\n    pipe(scheduler, seriesModel, task);\n  } // Clear unused series tasks.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  seriesTaskMap.each(function (task, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      task.dispose();\n      seriesTaskMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.\n  || createTask({\n    reset: overallTaskReset\n  });\n  overallTask.context = {\n    ecModel: ecModel,\n    api: api,\n    overallReset: stageHandler.overallReset,\n    scheduler: scheduler\n  }; // Reuse orignal stubs.\n\n  var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap();\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries;\n  var overallProgress = true;\n  var modifyOutputEnd = stageHandler.modifyOutputEnd; // An overall task with seriesType detected or has `getTargetSeries`, we add\n  // stub in each pipelines, it will set the overall task dirty when the pipeline\n  // progress. Moreover, to avoid call the overall task each frame (too frequent),\n  // we set the pipeline block.\n\n  if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, createStub);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(createStub);\n  } // Otherwise, (usually it is legancy case), the overall task will only be\n  // executed when upstream dirty. Otherwise the progressive rendering of all\n  // pipelines will be disabled unexpectedly. But it still needs stubs to receive\n  // dirty info from upsteam.\n  else {\n    overallProgress = false;\n    each(ecModel.getSeries(), createStub);\n  }\n\n  function createStub(seriesModel) {\n    var pipelineId = seriesModel.uid;\n    var stub = agentStubMap.get(pipelineId);\n\n    if (!stub) {\n      stub = agentStubMap.set(pipelineId, createTask({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })); // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n\n      overallTask.dirty();\n    }\n\n    stub.context = {\n      model: seriesModel,\n      overallProgress: overallProgress,\n      modifyOutputEnd: modifyOutputEnd\n    };\n    stub.agent = overallTask;\n    stub.__block = overallProgress;\n    pipe(scheduler, seriesModel, stub);\n  } // Clear unused stubs.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  agentStubMap.each(function (stub, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      stub.dispose(); // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n\n      overallTask.dirty();\n      agentStubMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\n\nfunction stubReset(context, upstreamContext) {\n  return context.overallProgress && stubProgress;\n}\n\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\n\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\n\nfunction seriesTaskPlan(context) {\n  return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);\n}\n\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n\n  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? map(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\n\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\n\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\n\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n\nfunction pipe(scheduler, seriesModel, task) {\n  var pipelineId = seriesModel.uid;\n\n  var pipeline = scheduler._pipelineMap.get(pipelineId);\n\n  !pipeline.head && (pipeline.head = task);\n  pipeline.tail && pipeline.tail.pipe(task);\n  pipeline.tail = task;\n  task.__idxInPipeline = pipeline.count++;\n  task.__pipeline = pipeline;\n}\n\nScheduler.wrapStageHandler = function (stageHandler, visualType) {\n  if (isFunction(stageHandler)) {\n    stageHandler = {\n      overallReset: stageHandler,\n      seriesType: detectSeriseType(stageHandler)\n    };\n  }\n\n  stageHandler.uid = getUID('stageHandler');\n  visualType && (stageHandler.visualType = visualType);\n  return stageHandler;\n};\n/**\n * Only some legacy stage handlers (usually in echarts extensions) are pure function.\n * To ensure that they can work normally, they should work in block mode, that is,\n * they should not be started util the previous tasks finished. So they cause the\n * progressive rendering disabled. We try to detect the series type, to narrow down\n * the block range to only the series type they concern, but not all series.\n */\n\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n\n  try {\n    // Assume there is no async when calling `eachSeriesByType`.\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n\n  return seriesType;\n}\n\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, GlobalModel);\nmockMethods(apiMock, ExtensionAPI);\n\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\n\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\n\nfunction mockMethods(target, Clz) {\n  /* eslint-disable */\n  for (var name in Clz.prototype) {\n    // Do not use hasOwnProperty\n    target[name] = noop;\n  }\n  /* eslint-enable */\n\n}\n\nvar _default = Scheduler;\nmodule.exports = _default;","map":{"version":3,"names":["_util","require","each","map","isFunction","createHashMap","noop","_task","createTask","_component","getUID","GlobalModel","ExtensionAPI","_model","normalizeToArray","Scheduler","ecInstance","api","dataProcessorHandlers","visualHandlers","unfinished","_dataProcessorHandlers","slice","_visualHandlers","_allHandlers","concat","_stageTaskMap","proto","prototype","restoreData","ecModel","payload","taskRecord","overallTask","dirty","getPerformArgs","task","isBlock","__pipeline","pipeline","_pipelineMap","get","id","pCtx","context","incremental","progressiveEnabled","progressiveRender","__idxInPipeline","blockIndex","step","modDataCount","modBy","Math","ceil","getPipeline","pipelineId","updateStreamModes","seriesModel","view","uid","data","getData","dataLen","count","incrementalPrepareRender","threshold","large","pipelineContext","restorePipelines","scheduler","pipelineMap","eachSeries","progressive","getProgressive","set","head","tail","getProgressiveThreshold","preventIncremental","round","pipe","dataTask","prepareStageTasks","stageTaskMap","getModel","handler","record","reset","createSeriesStageTask","overallReset","createOverallStageTask","prepareView","model","renderTask","__block","performDataProcessorTasks","performStageTasks","block","performVisualTasks","opt","stageHandlers","stageHandler","idx","visualType","stageHandlerRecord","seriesTaskMap","overallNeedDirty","agentStubMap","stub","needSetDirty","updatePayload","performArgs","perform","skip","performRawSeries","isSeriesFiltered","setDirty","dirtyMap","performSeriesTasks","plan","getUpstream","seriesType","getTargetSeries","createOnAllSeries","eachRawSeries","create","eachRawSeriesByType","seriesTaskPlan","seriesTaskReset","seriesTaskCount","useClearVisual","isVisual","isLayout","dispose","removeKey","overallTaskReset","overallProgress","modifyOutputEnd","createStub","getSeries","stubReset","onDirty","stubOnDirty","agent","upstreamContext","stubProgress","getDownstream","clearAllVisual","resetDefines","length","v","makeSeriesTaskProgress","singleSeriesTaskProgress","resetDefineIdx","params","resetDefine","dataEach","i","start","end","progress","wrapStageHandler","detectSeriseType","legacyFunc","ecModelMock","apiMock","e","mockMethods","eachSeriesByType","type","eachComponent","cond","mainType","subType","target","Clz","name","_default","module","exports"],"sources":["F:/Wechatfile/WeChat Files/wxid_cre715h75uat22/FileStorage/MsgAttach/843d799c0bb5fd5ab828b2371b6d88b0/File/2022-07/project/project/app/node_modules/echarts/lib/stream/Scheduler.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar each = _util.each;\nvar map = _util.map;\nvar isFunction = _util.isFunction;\nvar createHashMap = _util.createHashMap;\nvar noop = _util.noop;\n\nvar _task = require(\"./task\");\n\nvar createTask = _task.createTask;\n\nvar _component = require(\"../util/component\");\n\nvar getUID = _component.getUID;\n\nvar GlobalModel = require(\"../model/Global\");\n\nvar ExtensionAPI = require(\"../ExtensionAPI\");\n\nvar _model = require(\"../util/model\");\n\nvar normalizeToArray = _model.normalizeToArray;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * @module echarts/stream/Scheduler\n */\n\n/**\n * @constructor\n */\nfunction Scheduler(ecInstance, api, dataProcessorHandlers, visualHandlers) {\n  this.ecInstance = ecInstance;\n  this.api = api;\n  this.unfinished; // Fix current processors in case that in some rear cases that\n  // processors might be registered after echarts instance created.\n  // Register processors incrementally for a echarts instance is\n  // not supported by this stream architecture.\n\n  var dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice();\n  var visualHandlers = this._visualHandlers = visualHandlers.slice();\n  this._allHandlers = dataProcessorHandlers.concat(visualHandlers);\n  /**\n   * @private\n   * @type {\n   *     [handlerUID: string]: {\n   *         seriesTaskMap?: {\n   *             [seriesUID: string]: Task\n   *         },\n   *         overallTask?: Task\n   *     }\n   * }\n   */\n\n  this._stageTaskMap = createHashMap();\n}\n\nvar proto = Scheduler.prototype;\n/**\n * @param {module:echarts/model/Global} ecModel\n * @param {Object} payload\n */\n\nproto.restoreData = function (ecModel, payload) {\n  // TODO: Only restore needed series and components, but not all components.\n  // Currently `restoreData` of all of the series and component will be called.\n  // But some independent components like `title`, `legend`, `graphic`, `toolbox`,\n  // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,\n  // and some components like coordinate system, axes, dataZoom, visualMap only\n  // need their target series refresh.\n  // (1) If we are implementing this feature some day, we should consider these cases:\n  // if a data processor depends on a component (e.g., dataZoomProcessor depends\n  // on the settings of `dataZoom`), it should be re-performed if the component\n  // is modified by `setOption`.\n  // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,\n  // it should be re-performed when the result array of `getTargetSeries` changed.\n  // We use `dependencies` to cover these issues.\n  // (3) How to update target series when coordinate system related components modified.\n  // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,\n  // and this case all of the tasks will be set as dirty.\n  ecModel.restoreData(payload); // Theoretically an overall task not only depends on each of its target series, but also\n  // depends on all of the series.\n  // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks\n  // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure\n  // that the overall task is set as dirty and to be performed, otherwise it probably cause\n  // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it\n  // probably cause state chaos (consider `dataZoomProcessor`).\n\n  this._stageTaskMap.each(function (taskRecord) {\n    var overallTask = taskRecord.overallTask;\n    overallTask && overallTask.dirty();\n  });\n}; // If seriesModel provided, incremental threshold is check by series data.\n\n\nproto.getPerformArgs = function (task, isBlock) {\n  // For overall task\n  if (!task.__pipeline) {\n    return;\n  }\n\n  var pipeline = this._pipelineMap.get(task.__pipeline.id);\n\n  var pCtx = pipeline.context;\n  var incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex;\n  var step = incremental ? pipeline.step : null;\n  var modDataCount = pCtx && pCtx.modDataCount;\n  var modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null;\n  return {\n    step: step,\n    modBy: modBy,\n    modDataCount: modDataCount\n  };\n};\n\nproto.getPipeline = function (pipelineId) {\n  return this._pipelineMap.get(pipelineId);\n};\n/**\n * Current, progressive rendering starts from visual and layout.\n * Always detect render mode in the same stage, avoiding that incorrect\n * detection caused by data filtering.\n * Caution:\n * `updateStreamModes` use `seriesModel.getData()`.\n */\n\n\nproto.updateStreamModes = function (seriesModel, view) {\n  var pipeline = this._pipelineMap.get(seriesModel.uid);\n\n  var data = seriesModel.getData();\n  var dataLen = data.count(); // `progressiveRender` means that can render progressively in each\n  // animation frame. Note that some types of series do not provide\n  // `view.incrementalPrepareRender` but support `chart.appendData`. We\n  // use the term `incremental` but not `progressive` to describe the\n  // case that `chart.appendData`.\n\n  var progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold;\n  var large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold'); // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.\n  // see `test/candlestick-large3.html`\n\n  var modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null;\n  seriesModel.pipelineContext = pipeline.context = {\n    progressiveRender: progressiveRender,\n    modDataCount: modDataCount,\n    large: large\n  };\n};\n\nproto.restorePipelines = function (ecModel) {\n  var scheduler = this;\n  var pipelineMap = scheduler._pipelineMap = createHashMap();\n  ecModel.eachSeries(function (seriesModel) {\n    var progressive = seriesModel.getProgressive();\n    var pipelineId = seriesModel.uid;\n    pipelineMap.set(pipelineId, {\n      id: pipelineId,\n      head: null,\n      tail: null,\n      threshold: seriesModel.getProgressiveThreshold(),\n      progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),\n      blockIndex: -1,\n      step: Math.round(progressive || 700),\n      count: 0\n    });\n    pipe(scheduler, seriesModel, seriesModel.dataTask);\n  });\n};\n\nproto.prepareStageTasks = function () {\n  var stageTaskMap = this._stageTaskMap;\n  var ecModel = this.ecInstance.getModel();\n  var api = this.api;\n  each(this._allHandlers, function (handler) {\n    var record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, []);\n    handler.reset && createSeriesStageTask(this, handler, record, ecModel, api);\n    handler.overallReset && createOverallStageTask(this, handler, record, ecModel, api);\n  }, this);\n};\n\nproto.prepareView = function (view, model, ecModel, api) {\n  var renderTask = view.renderTask;\n  var context = renderTask.context;\n  context.model = model;\n  context.ecModel = ecModel;\n  context.api = api;\n  renderTask.__block = !view.incrementalPrepareRender;\n  pipe(this, model, renderTask);\n};\n\nproto.performDataProcessorTasks = function (ecModel, payload) {\n  // If we do not use `block` here, it should be considered when to update modes.\n  performStageTasks(this, this._dataProcessorHandlers, ecModel, payload, {\n    block: true\n  });\n}; // opt\n// opt.visualType: 'visual' or 'layout'\n// opt.setDirty\n\n\nproto.performVisualTasks = function (ecModel, payload, opt) {\n  performStageTasks(this, this._visualHandlers, ecModel, payload, opt);\n};\n\nfunction performStageTasks(scheduler, stageHandlers, ecModel, payload, opt) {\n  opt = opt || {};\n  var unfinished;\n  each(stageHandlers, function (stageHandler, idx) {\n    if (opt.visualType && opt.visualType !== stageHandler.visualType) {\n      return;\n    }\n\n    var stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid);\n\n    var seriesTaskMap = stageHandlerRecord.seriesTaskMap;\n    var overallTask = stageHandlerRecord.overallTask;\n\n    if (overallTask) {\n      var overallNeedDirty;\n      var agentStubMap = overallTask.agentStubMap;\n      agentStubMap.each(function (stub) {\n        if (needSetDirty(opt, stub)) {\n          stub.dirty();\n          overallNeedDirty = true;\n        }\n      });\n      overallNeedDirty && overallTask.dirty();\n      updatePayload(overallTask, payload);\n      var performArgs = scheduler.getPerformArgs(overallTask, opt.block); // Execute stubs firstly, which may set the overall task dirty,\n      // then execute the overall task. And stub will call seriesModel.setData,\n      // which ensures that in the overallTask seriesModel.getData() will not\n      // return incorrect data.\n\n      agentStubMap.each(function (stub) {\n        stub.perform(performArgs);\n      });\n      unfinished |= overallTask.perform(performArgs);\n    } else if (seriesTaskMap) {\n      seriesTaskMap.each(function (task, pipelineId) {\n        if (needSetDirty(opt, task)) {\n          task.dirty();\n        }\n\n        var performArgs = scheduler.getPerformArgs(task, opt.block); // FIXME\n        // if intending to decalare `performRawSeries` in handlers, only\n        // stream-independent (specifically, data item independent) operations can be\n        // performed. Because is a series is filtered, most of the tasks will not\n        // be performed. A stream-dependent operation probably cause wrong biz logic.\n        // Perhaps we should not provide a separate callback for this case instead\n        // of providing the config `performRawSeries`. The stream-dependent operaions\n        // and stream-independent operations should better not be mixed.\n\n        performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model);\n        updatePayload(task, payload);\n        unfinished |= task.perform(performArgs);\n      });\n    }\n  });\n\n  function needSetDirty(opt, task) {\n    return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id));\n  }\n\n  scheduler.unfinished |= unfinished;\n}\n\nproto.performSeriesTasks = function (ecModel) {\n  var unfinished;\n  ecModel.eachSeries(function (seriesModel) {\n    // Progress to the end for dataInit and dataRestore.\n    unfinished |= seriesModel.dataTask.perform();\n  });\n  this.unfinished |= unfinished;\n};\n\nproto.plan = function () {\n  // Travel pipelines, check block.\n  this._pipelineMap.each(function (pipeline) {\n    var task = pipeline.tail;\n\n    do {\n      if (task.__block) {\n        pipeline.blockIndex = task.__idxInPipeline;\n        break;\n      }\n\n      task = task.getUpstream();\n    } while (task);\n  });\n};\n\nvar updatePayload = proto.updatePayload = function (task, payload) {\n  payload !== 'remain' && (task.context.payload = payload);\n};\n\nfunction createSeriesStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var seriesTaskMap = stageHandlerRecord.seriesTaskMap || (stageHandlerRecord.seriesTaskMap = createHashMap());\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries; // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,\n  // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,\n  // it works but it may cause other irrelevant charts blocked.\n\n  if (stageHandler.createOnAllSeries) {\n    ecModel.eachRawSeries(create);\n  } else if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, create);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(create);\n  }\n\n  function create(seriesModel) {\n    var pipelineId = seriesModel.uid; // Init tasks for each seriesModel only once.\n    // Reuse original task instance.\n\n    var task = seriesTaskMap.get(pipelineId) || seriesTaskMap.set(pipelineId, createTask({\n      plan: seriesTaskPlan,\n      reset: seriesTaskReset,\n      count: seriesTaskCount\n    }));\n    task.context = {\n      model: seriesModel,\n      ecModel: ecModel,\n      api: api,\n      useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,\n      plan: stageHandler.plan,\n      reset: stageHandler.reset,\n      scheduler: scheduler\n    };\n    pipe(scheduler, seriesModel, task);\n  } // Clear unused series tasks.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  seriesTaskMap.each(function (task, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      task.dispose();\n      seriesTaskMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction createOverallStageTask(scheduler, stageHandler, stageHandlerRecord, ecModel, api) {\n  var overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask // For overall task, the function only be called on reset stage.\n  || createTask({\n    reset: overallTaskReset\n  });\n  overallTask.context = {\n    ecModel: ecModel,\n    api: api,\n    overallReset: stageHandler.overallReset,\n    scheduler: scheduler\n  }; // Reuse orignal stubs.\n\n  var agentStubMap = overallTask.agentStubMap = overallTask.agentStubMap || createHashMap();\n  var seriesType = stageHandler.seriesType;\n  var getTargetSeries = stageHandler.getTargetSeries;\n  var overallProgress = true;\n  var modifyOutputEnd = stageHandler.modifyOutputEnd; // An overall task with seriesType detected or has `getTargetSeries`, we add\n  // stub in each pipelines, it will set the overall task dirty when the pipeline\n  // progress. Moreover, to avoid call the overall task each frame (too frequent),\n  // we set the pipeline block.\n\n  if (seriesType) {\n    ecModel.eachRawSeriesByType(seriesType, createStub);\n  } else if (getTargetSeries) {\n    getTargetSeries(ecModel, api).each(createStub);\n  } // Otherwise, (usually it is legancy case), the overall task will only be\n  // executed when upstream dirty. Otherwise the progressive rendering of all\n  // pipelines will be disabled unexpectedly. But it still needs stubs to receive\n  // dirty info from upsteam.\n  else {\n      overallProgress = false;\n      each(ecModel.getSeries(), createStub);\n    }\n\n  function createStub(seriesModel) {\n    var pipelineId = seriesModel.uid;\n    var stub = agentStubMap.get(pipelineId);\n\n    if (!stub) {\n      stub = agentStubMap.set(pipelineId, createTask({\n        reset: stubReset,\n        onDirty: stubOnDirty\n      })); // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n\n      overallTask.dirty();\n    }\n\n    stub.context = {\n      model: seriesModel,\n      overallProgress: overallProgress,\n      modifyOutputEnd: modifyOutputEnd\n    };\n    stub.agent = overallTask;\n    stub.__block = overallProgress;\n    pipe(scheduler, seriesModel, stub);\n  } // Clear unused stubs.\n\n\n  var pipelineMap = scheduler._pipelineMap;\n  agentStubMap.each(function (stub, pipelineId) {\n    if (!pipelineMap.get(pipelineId)) {\n      stub.dispose(); // When the result of `getTargetSeries` changed, the overallTask\n      // should be set as dirty and re-performed.\n\n      overallTask.dirty();\n      agentStubMap.removeKey(pipelineId);\n    }\n  });\n}\n\nfunction overallTaskReset(context) {\n  context.overallReset(context.ecModel, context.api, context.payload);\n}\n\nfunction stubReset(context, upstreamContext) {\n  return context.overallProgress && stubProgress;\n}\n\nfunction stubProgress() {\n  this.agent.dirty();\n  this.getDownstream().dirty();\n}\n\nfunction stubOnDirty() {\n  this.agent && this.agent.dirty();\n}\n\nfunction seriesTaskPlan(context) {\n  return context.plan && context.plan(context.model, context.ecModel, context.api, context.payload);\n}\n\nfunction seriesTaskReset(context) {\n  if (context.useClearVisual) {\n    context.data.clearAllVisual();\n  }\n\n  var resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload));\n  return resetDefines.length > 1 ? map(resetDefines, function (v, idx) {\n    return makeSeriesTaskProgress(idx);\n  }) : singleSeriesTaskProgress;\n}\n\nvar singleSeriesTaskProgress = makeSeriesTaskProgress(0);\n\nfunction makeSeriesTaskProgress(resetDefineIdx) {\n  return function (params, context) {\n    var data = context.data;\n    var resetDefine = context.resetDefines[resetDefineIdx];\n\n    if (resetDefine && resetDefine.dataEach) {\n      for (var i = params.start; i < params.end; i++) {\n        resetDefine.dataEach(data, i);\n      }\n    } else if (resetDefine && resetDefine.progress) {\n      resetDefine.progress(params, data);\n    }\n  };\n}\n\nfunction seriesTaskCount(context) {\n  return context.data.count();\n}\n\nfunction pipe(scheduler, seriesModel, task) {\n  var pipelineId = seriesModel.uid;\n\n  var pipeline = scheduler._pipelineMap.get(pipelineId);\n\n  !pipeline.head && (pipeline.head = task);\n  pipeline.tail && pipeline.tail.pipe(task);\n  pipeline.tail = task;\n  task.__idxInPipeline = pipeline.count++;\n  task.__pipeline = pipeline;\n}\n\nScheduler.wrapStageHandler = function (stageHandler, visualType) {\n  if (isFunction(stageHandler)) {\n    stageHandler = {\n      overallReset: stageHandler,\n      seriesType: detectSeriseType(stageHandler)\n    };\n  }\n\n  stageHandler.uid = getUID('stageHandler');\n  visualType && (stageHandler.visualType = visualType);\n  return stageHandler;\n};\n/**\n * Only some legacy stage handlers (usually in echarts extensions) are pure function.\n * To ensure that they can work normally, they should work in block mode, that is,\n * they should not be started util the previous tasks finished. So they cause the\n * progressive rendering disabled. We try to detect the series type, to narrow down\n * the block range to only the series type they concern, but not all series.\n */\n\n\nfunction detectSeriseType(legacyFunc) {\n  seriesType = null;\n\n  try {\n    // Assume there is no async when calling `eachSeriesByType`.\n    legacyFunc(ecModelMock, apiMock);\n  } catch (e) {}\n\n  return seriesType;\n}\n\nvar ecModelMock = {};\nvar apiMock = {};\nvar seriesType;\nmockMethods(ecModelMock, GlobalModel);\nmockMethods(apiMock, ExtensionAPI);\n\necModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {\n  seriesType = type;\n};\n\necModelMock.eachComponent = function (cond) {\n  if (cond.mainType === 'series' && cond.subType) {\n    seriesType = cond.subType;\n  }\n};\n\nfunction mockMethods(target, Clz) {\n  /* eslint-disable */\n  for (var name in Clz.prototype) {\n    // Do not use hasOwnProperty\n    target[name] = noop;\n  }\n  /* eslint-enable */\n\n}\n\nvar _default = Scheduler;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}