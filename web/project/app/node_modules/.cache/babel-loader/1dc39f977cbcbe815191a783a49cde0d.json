{"ast":null,"code":"var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  // This item default to be false. But in map series in echarts,\n  // in order to improve performance, it should be set to true,\n  // so the shorty segment won't draw.\n  segmentIgnoreThreshold: 0,\n\n  /**\n   * See `module:zrender/src/graphic/helper/subPixelOptimize`.\n   * @type {boolean}\n   */\n  subPixelOptimize: false,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    if (hasFill) {\n      if (style.fillOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.fillOpacity * style.opacity;\n        path.fill(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.fill(ctx);\n      }\n    }\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    if (hasStroke) {\n      if (style.strokeOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.strokeOpacity * style.opacity;\n        path.stroke(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.stroke(ctx);\n      }\n    }\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    } // Draw rect text\n\n\n    if (style.text != null) {\n      // Only restore transform when needs draw text.\n      this.restoreTransform(ctx);\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = this.__dirtyText = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;","map":{"version":3,"names":["Displayable","require","zrUtil","PathProxy","pathContain","Pattern","getCanvasPattern","prototype","abs","Math","pathProxyForDraw","Path","opts","call","path","constructor","type","__dirtyPath","strokeContainThreshold","segmentIgnoreThreshold","subPixelOptimize","brush","ctx","prevEl","style","hasStroke","hasFill","fill","stroke","hasFillGradient","colorStops","hasStrokeGradient","hasFillPattern","image","hasStrokePattern","bind","setTransform","__dirty","rect","getBoundingRect","_fillGradient","getGradient","_strokeGradient","fillStyle","strokeStyle","lineDash","lineDashOffset","ctxLineDash","setLineDash","scale","getGlobalScale","setScale","beginPath","setLineDashOffset","buildPath","shape","rebuildPath","fillOpacity","originalGlobalAlpha","globalAlpha","opacity","strokeOpacity","text","restoreTransform","drawRectText","shapeCfg","inBundle","createPathProxy","_rect","needsUpdateRect","rectWithStroke","_rectWithStroke","clone","copy","w","lineWidth","lineScale","strokeNoScale","getLineScale","max","width","height","x","y","contain","localPos","transformCoordToLocal","pathData","data","containStroke","dirty","dirtyPath","__dirtyText","__zr","refresh","__clipTarget","animateShape","loop","animate","attrKV","key","value","setShape","isObject","name","hasOwnProperty","m","transform","sqrt","extend","defaults","Sub","extendFrom","defaultShape","thisShape","init","inherits","_default","module","exports"],"sources":["C:/Users/XiaoAn1/Desktop/project/app/node_modules/zrender/lib/graphic/Path.js"],"sourcesContent":["var Displayable = require(\"./Displayable\");\n\nvar zrUtil = require(\"../core/util\");\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar pathContain = require(\"../contain/path\");\n\nvar Pattern = require(\"./Pattern\");\n\nvar getCanvasPattern = Pattern.prototype.getCanvasPattern;\nvar abs = Math.abs;\nvar pathProxyForDraw = new PathProxy(true);\n/**\n * @alias module:zrender/graphic/Path\n * @extends module:zrender/graphic/Displayable\n * @constructor\n * @param {Object} opts\n */\n\nfunction Path(opts) {\n  Displayable.call(this, opts);\n  /**\n   * @type {module:zrender/core/PathProxy}\n   * @readOnly\n   */\n\n  this.path = null;\n}\n\nPath.prototype = {\n  constructor: Path,\n  type: 'path',\n  __dirtyPath: true,\n  strokeContainThreshold: 5,\n  // This item default to be false. But in map series in echarts,\n  // in order to improve performance, it should be set to true,\n  // so the shorty segment won't draw.\n  segmentIgnoreThreshold: 0,\n\n  /**\n   * See `module:zrender/src/graphic/helper/subPixelOptimize`.\n   * @type {boolean}\n   */\n  subPixelOptimize: false,\n  brush: function (ctx, prevEl) {\n    var style = this.style;\n    var path = this.path || pathProxyForDraw;\n    var hasStroke = style.hasStroke();\n    var hasFill = style.hasFill();\n    var fill = style.fill;\n    var stroke = style.stroke;\n    var hasFillGradient = hasFill && !!fill.colorStops;\n    var hasStrokeGradient = hasStroke && !!stroke.colorStops;\n    var hasFillPattern = hasFill && !!fill.image;\n    var hasStrokePattern = hasStroke && !!stroke.image;\n    style.bind(ctx, this, prevEl);\n    this.setTransform(ctx);\n\n    if (this.__dirty) {\n      var rect; // Update gradient because bounding rect may changed\n\n      if (hasFillGradient) {\n        rect = rect || this.getBoundingRect();\n        this._fillGradient = style.getGradient(ctx, fill, rect);\n      }\n\n      if (hasStrokeGradient) {\n        rect = rect || this.getBoundingRect();\n        this._strokeGradient = style.getGradient(ctx, stroke, rect);\n      }\n    } // Use the gradient or pattern\n\n\n    if (hasFillGradient) {\n      // PENDING If may have affect the state\n      ctx.fillStyle = this._fillGradient;\n    } else if (hasFillPattern) {\n      ctx.fillStyle = getCanvasPattern.call(fill, ctx);\n    }\n\n    if (hasStrokeGradient) {\n      ctx.strokeStyle = this._strokeGradient;\n    } else if (hasStrokePattern) {\n      ctx.strokeStyle = getCanvasPattern.call(stroke, ctx);\n    }\n\n    var lineDash = style.lineDash;\n    var lineDashOffset = style.lineDashOffset;\n    var ctxLineDash = !!ctx.setLineDash; // Update path sx, sy\n\n    var scale = this.getGlobalScale();\n    path.setScale(scale[0], scale[1], this.segmentIgnoreThreshold); // Proxy context\n    // Rebuild path in following 2 cases\n    // 1. Path is dirty\n    // 2. Path needs javascript implemented lineDash stroking.\n    //    In this case, lineDash information will not be saved in PathProxy\n\n    if (this.__dirtyPath || lineDash && !ctxLineDash && hasStroke) {\n      path.beginPath(ctx); // Setting line dash before build path\n\n      if (lineDash && !ctxLineDash) {\n        path.setLineDash(lineDash);\n        path.setLineDashOffset(lineDashOffset);\n      }\n\n      this.buildPath(path, this.shape, false); // Clear path dirty flag\n\n      if (this.path) {\n        this.__dirtyPath = false;\n      }\n    } else {\n      // Replay path building\n      ctx.beginPath();\n      this.path.rebuildPath(ctx);\n    }\n\n    if (hasFill) {\n      if (style.fillOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.fillOpacity * style.opacity;\n        path.fill(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.fill(ctx);\n      }\n    }\n\n    if (lineDash && ctxLineDash) {\n      ctx.setLineDash(lineDash);\n      ctx.lineDashOffset = lineDashOffset;\n    }\n\n    if (hasStroke) {\n      if (style.strokeOpacity != null) {\n        var originalGlobalAlpha = ctx.globalAlpha;\n        ctx.globalAlpha = style.strokeOpacity * style.opacity;\n        path.stroke(ctx);\n        ctx.globalAlpha = originalGlobalAlpha;\n      } else {\n        path.stroke(ctx);\n      }\n    }\n\n    if (lineDash && ctxLineDash) {\n      // PENDING\n      // Remove lineDash\n      ctx.setLineDash([]);\n    } // Draw rect text\n\n\n    if (style.text != null) {\n      // Only restore transform when needs draw text.\n      this.restoreTransform(ctx);\n      this.drawRectText(ctx, this.getBoundingRect());\n    }\n  },\n  // When bundling path, some shape may decide if use moveTo to begin a new subpath or closePath\n  // Like in circle\n  buildPath: function (ctx, shapeCfg, inBundle) {},\n  createPathProxy: function () {\n    this.path = new PathProxy();\n  },\n  getBoundingRect: function () {\n    var rect = this._rect;\n    var style = this.style;\n    var needsUpdateRect = !rect;\n\n    if (needsUpdateRect) {\n      var path = this.path;\n\n      if (!path) {\n        // Create path on demand.\n        path = this.path = new PathProxy();\n      }\n\n      if (this.__dirtyPath) {\n        path.beginPath();\n        this.buildPath(path, this.shape, false);\n      }\n\n      rect = path.getBoundingRect();\n    }\n\n    this._rect = rect;\n\n    if (style.hasStroke()) {\n      // Needs update rect with stroke lineWidth when\n      // 1. Element changes scale or lineWidth\n      // 2. Shape is changed\n      var rectWithStroke = this._rectWithStroke || (this._rectWithStroke = rect.clone());\n\n      if (this.__dirty || needsUpdateRect) {\n        rectWithStroke.copy(rect); // FIXME Must after updateTransform\n\n        var w = style.lineWidth; // PENDING, Min line width is needed when line is horizontal or vertical\n\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Only add extra hover lineWidth when there are no fill\n\n        if (!style.hasFill()) {\n          w = Math.max(w, this.strokeContainThreshold || 4);\n        } // Consider line width\n        // Line scale can't be 0;\n\n\n        if (lineScale > 1e-10) {\n          rectWithStroke.width += w / lineScale;\n          rectWithStroke.height += w / lineScale;\n          rectWithStroke.x -= w / lineScale / 2;\n          rectWithStroke.y -= w / lineScale / 2;\n        }\n      } // Return rect with stroke\n\n\n      return rectWithStroke;\n    }\n\n    return rect;\n  },\n  contain: function (x, y) {\n    var localPos = this.transformCoordToLocal(x, y);\n    var rect = this.getBoundingRect();\n    var style = this.style;\n    x = localPos[0];\n    y = localPos[1];\n\n    if (rect.contain(x, y)) {\n      var pathData = this.path.data;\n\n      if (style.hasStroke()) {\n        var lineWidth = style.lineWidth;\n        var lineScale = style.strokeNoScale ? this.getLineScale() : 1; // Line scale can't be 0;\n\n        if (lineScale > 1e-10) {\n          // Only add extra hover lineWidth when there are no fill\n          if (!style.hasFill()) {\n            lineWidth = Math.max(lineWidth, this.strokeContainThreshold);\n          }\n\n          if (pathContain.containStroke(pathData, lineWidth / lineScale, x, y)) {\n            return true;\n          }\n        }\n      }\n\n      if (style.hasFill()) {\n        return pathContain.contain(pathData, x, y);\n      }\n    }\n\n    return false;\n  },\n\n  /**\n   * @param  {boolean} dirtyPath\n   */\n  dirty: function (dirtyPath) {\n    if (dirtyPath == null) {\n      dirtyPath = true;\n    } // Only mark dirty, not mark clean\n\n\n    if (dirtyPath) {\n      this.__dirtyPath = dirtyPath;\n      this._rect = null;\n    }\n\n    this.__dirty = this.__dirtyText = true;\n    this.__zr && this.__zr.refresh(); // Used as a clipping path\n\n    if (this.__clipTarget) {\n      this.__clipTarget.dirty();\n    }\n  },\n\n  /**\n   * Alias for animate('shape')\n   * @param {boolean} loop\n   */\n  animateShape: function (loop) {\n    return this.animate('shape', loop);\n  },\n  // Overwrite attrKV\n  attrKV: function (key, value) {\n    // FIXME\n    if (key === 'shape') {\n      this.setShape(value);\n      this.__dirtyPath = true;\n      this._rect = null;\n    } else {\n      Displayable.prototype.attrKV.call(this, key, value);\n    }\n  },\n\n  /**\n   * @param {Object|string} key\n   * @param {*} value\n   */\n  setShape: function (key, value) {\n    var shape = this.shape; // Path from string may not have shape\n\n    if (shape) {\n      if (zrUtil.isObject(key)) {\n        for (var name in key) {\n          if (key.hasOwnProperty(name)) {\n            shape[name] = key[name];\n          }\n        }\n      } else {\n        shape[key] = value;\n      }\n\n      this.dirty(true);\n    }\n\n    return this;\n  },\n  getLineScale: function () {\n    var m = this.transform; // Get the line scale.\n    // Determinant of `m` means how much the area is enlarged by the\n    // transformation. So its square root can be used as a scale factor\n    // for width.\n\n    return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10 ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1])) : 1;\n  }\n};\n/**\n * 扩展一个 Path element, 比如星形，圆等。\n * Extend a path element\n * @param {Object} props\n * @param {string} props.type Path type\n * @param {Function} props.init Initialize\n * @param {Function} props.buildPath Overwrite buildPath method\n * @param {Object} [props.style] Extended default style config\n * @param {Object} [props.shape] Extended default shape config\n */\n\nPath.extend = function (defaults) {\n  var Sub = function (opts) {\n    Path.call(this, opts);\n\n    if (defaults.style) {\n      // Extend default style\n      this.style.extendFrom(defaults.style, false);\n    } // Extend default shape\n\n\n    var defaultShape = defaults.shape;\n\n    if (defaultShape) {\n      this.shape = this.shape || {};\n      var thisShape = this.shape;\n\n      for (var name in defaultShape) {\n        if (!thisShape.hasOwnProperty(name) && defaultShape.hasOwnProperty(name)) {\n          thisShape[name] = defaultShape[name];\n        }\n      }\n    }\n\n    defaults.init && defaults.init.call(this, opts);\n  };\n\n  zrUtil.inherits(Sub, Path); // FIXME 不能 extend position, rotation 等引用对象\n\n  for (var name in defaults) {\n    // Extending prototype values and methods\n    if (name !== 'style' && name !== 'shape') {\n      Sub.prototype[name] = defaults[name];\n    }\n  }\n\n  return Sub;\n};\n\nzrUtil.inherits(Path, Displayable);\nvar _default = Path;\nmodule.exports = _default;"],"mappings":"AAAA,IAAIA,WAAW,GAAGC,OAAO,CAAC,eAAD,CAAzB;;AAEA,IAAIC,MAAM,GAAGD,OAAO,CAAC,cAAD,CAApB;;AAEA,IAAIE,SAAS,GAAGF,OAAO,CAAC,mBAAD,CAAvB;;AAEA,IAAIG,WAAW,GAAGH,OAAO,CAAC,iBAAD,CAAzB;;AAEA,IAAII,OAAO,GAAGJ,OAAO,CAAC,WAAD,CAArB;;AAEA,IAAIK,gBAAgB,GAAGD,OAAO,CAACE,SAAR,CAAkBD,gBAAzC;AACA,IAAIE,GAAG,GAAGC,IAAI,CAACD,GAAf;AACA,IAAIE,gBAAgB,GAAG,IAAIP,SAAJ,CAAc,IAAd,CAAvB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASQ,IAAT,CAAcC,IAAd,EAAoB;EAClBZ,WAAW,CAACa,IAAZ,CAAiB,IAAjB,EAAuBD,IAAvB;EACA;AACF;AACA;AACA;;EAEE,KAAKE,IAAL,GAAY,IAAZ;AACD;;AAEDH,IAAI,CAACJ,SAAL,GAAiB;EACfQ,WAAW,EAAEJ,IADE;EAEfK,IAAI,EAAE,MAFS;EAGfC,WAAW,EAAE,IAHE;EAIfC,sBAAsB,EAAE,CAJT;EAKf;EACA;EACA;EACAC,sBAAsB,EAAE,CART;;EAUf;AACF;AACA;AACA;EACEC,gBAAgB,EAAE,KAdH;EAefC,KAAK,EAAE,UAAUC,GAAV,EAAeC,MAAf,EAAuB;IAC5B,IAAIC,KAAK,GAAG,KAAKA,KAAjB;IACA,IAAIV,IAAI,GAAG,KAAKA,IAAL,IAAaJ,gBAAxB;IACA,IAAIe,SAAS,GAAGD,KAAK,CAACC,SAAN,EAAhB;IACA,IAAIC,OAAO,GAAGF,KAAK,CAACE,OAAN,EAAd;IACA,IAAIC,IAAI,GAAGH,KAAK,CAACG,IAAjB;IACA,IAAIC,MAAM,GAAGJ,KAAK,CAACI,MAAnB;IACA,IAAIC,eAAe,GAAGH,OAAO,IAAI,CAAC,CAACC,IAAI,CAACG,UAAxC;IACA,IAAIC,iBAAiB,GAAGN,SAAS,IAAI,CAAC,CAACG,MAAM,CAACE,UAA9C;IACA,IAAIE,cAAc,GAAGN,OAAO,IAAI,CAAC,CAACC,IAAI,CAACM,KAAvC;IACA,IAAIC,gBAAgB,GAAGT,SAAS,IAAI,CAAC,CAACG,MAAM,CAACK,KAA7C;IACAT,KAAK,CAACW,IAAN,CAAWb,GAAX,EAAgB,IAAhB,EAAsBC,MAAtB;IACA,KAAKa,YAAL,CAAkBd,GAAlB;;IAEA,IAAI,KAAKe,OAAT,EAAkB;MAChB,IAAIC,IAAJ,CADgB,CACN;;MAEV,IAAIT,eAAJ,EAAqB;QACnBS,IAAI,GAAGA,IAAI,IAAI,KAAKC,eAAL,EAAf;QACA,KAAKC,aAAL,GAAqBhB,KAAK,CAACiB,WAAN,CAAkBnB,GAAlB,EAAuBK,IAAvB,EAA6BW,IAA7B,CAArB;MACD;;MAED,IAAIP,iBAAJ,EAAuB;QACrBO,IAAI,GAAGA,IAAI,IAAI,KAAKC,eAAL,EAAf;QACA,KAAKG,eAAL,GAAuBlB,KAAK,CAACiB,WAAN,CAAkBnB,GAAlB,EAAuBM,MAAvB,EAA+BU,IAA/B,CAAvB;MACD;IACF,CA1B2B,CA0B1B;;;IAGF,IAAIT,eAAJ,EAAqB;MACnB;MACAP,GAAG,CAACqB,SAAJ,GAAgB,KAAKH,aAArB;IACD,CAHD,MAGO,IAAIR,cAAJ,EAAoB;MACzBV,GAAG,CAACqB,SAAJ,GAAgBrC,gBAAgB,CAACO,IAAjB,CAAsBc,IAAtB,EAA4BL,GAA5B,CAAhB;IACD;;IAED,IAAIS,iBAAJ,EAAuB;MACrBT,GAAG,CAACsB,WAAJ,GAAkB,KAAKF,eAAvB;IACD,CAFD,MAEO,IAAIR,gBAAJ,EAAsB;MAC3BZ,GAAG,CAACsB,WAAJ,GAAkBtC,gBAAgB,CAACO,IAAjB,CAAsBe,MAAtB,EAA8BN,GAA9B,CAAlB;IACD;;IAED,IAAIuB,QAAQ,GAAGrB,KAAK,CAACqB,QAArB;IACA,IAAIC,cAAc,GAAGtB,KAAK,CAACsB,cAA3B;IACA,IAAIC,WAAW,GAAG,CAAC,CAACzB,GAAG,CAAC0B,WAAxB,CA5C4B,CA4CS;;IAErC,IAAIC,KAAK,GAAG,KAAKC,cAAL,EAAZ;IACApC,IAAI,CAACqC,QAAL,CAAcF,KAAK,CAAC,CAAD,CAAnB,EAAwBA,KAAK,CAAC,CAAD,CAA7B,EAAkC,KAAK9B,sBAAvC,EA/C4B,CA+CoC;IAChE;IACA;IACA;IACA;;IAEA,IAAI,KAAKF,WAAL,IAAoB4B,QAAQ,IAAI,CAACE,WAAb,IAA4BtB,SAApD,EAA+D;MAC7DX,IAAI,CAACsC,SAAL,CAAe9B,GAAf,EAD6D,CACxC;;MAErB,IAAIuB,QAAQ,IAAI,CAACE,WAAjB,EAA8B;QAC5BjC,IAAI,CAACkC,WAAL,CAAiBH,QAAjB;QACA/B,IAAI,CAACuC,iBAAL,CAAuBP,cAAvB;MACD;;MAED,KAAKQ,SAAL,CAAexC,IAAf,EAAqB,KAAKyC,KAA1B,EAAiC,KAAjC,EAR6D,CAQpB;;MAEzC,IAAI,KAAKzC,IAAT,EAAe;QACb,KAAKG,WAAL,GAAmB,KAAnB;MACD;IACF,CAbD,MAaO;MACL;MACAK,GAAG,CAAC8B,SAAJ;MACA,KAAKtC,IAAL,CAAU0C,WAAV,CAAsBlC,GAAtB;IACD;;IAED,IAAII,OAAJ,EAAa;MACX,IAAIF,KAAK,CAACiC,WAAN,IAAqB,IAAzB,EAA+B;QAC7B,IAAIC,mBAAmB,GAAGpC,GAAG,CAACqC,WAA9B;QACArC,GAAG,CAACqC,WAAJ,GAAkBnC,KAAK,CAACiC,WAAN,GAAoBjC,KAAK,CAACoC,OAA5C;QACA9C,IAAI,CAACa,IAAL,CAAUL,GAAV;QACAA,GAAG,CAACqC,WAAJ,GAAkBD,mBAAlB;MACD,CALD,MAKO;QACL5C,IAAI,CAACa,IAAL,CAAUL,GAAV;MACD;IACF;;IAED,IAAIuB,QAAQ,IAAIE,WAAhB,EAA6B;MAC3BzB,GAAG,CAAC0B,WAAJ,CAAgBH,QAAhB;MACAvB,GAAG,CAACwB,cAAJ,GAAqBA,cAArB;IACD;;IAED,IAAIrB,SAAJ,EAAe;MACb,IAAID,KAAK,CAACqC,aAAN,IAAuB,IAA3B,EAAiC;QAC/B,IAAIH,mBAAmB,GAAGpC,GAAG,CAACqC,WAA9B;QACArC,GAAG,CAACqC,WAAJ,GAAkBnC,KAAK,CAACqC,aAAN,GAAsBrC,KAAK,CAACoC,OAA9C;QACA9C,IAAI,CAACc,MAAL,CAAYN,GAAZ;QACAA,GAAG,CAACqC,WAAJ,GAAkBD,mBAAlB;MACD,CALD,MAKO;QACL5C,IAAI,CAACc,MAAL,CAAYN,GAAZ;MACD;IACF;;IAED,IAAIuB,QAAQ,IAAIE,WAAhB,EAA6B;MAC3B;MACA;MACAzB,GAAG,CAAC0B,WAAJ,CAAgB,EAAhB;IACD,CAvG2B,CAuG1B;;;IAGF,IAAIxB,KAAK,CAACsC,IAAN,IAAc,IAAlB,EAAwB;MACtB;MACA,KAAKC,gBAAL,CAAsBzC,GAAtB;MACA,KAAK0C,YAAL,CAAkB1C,GAAlB,EAAuB,KAAKiB,eAAL,EAAvB;IACD;EACF,CA9Hc;EA+Hf;EACA;EACAe,SAAS,EAAE,UAAUhC,GAAV,EAAe2C,QAAf,EAAyBC,QAAzB,EAAmC,CAAE,CAjIjC;EAkIfC,eAAe,EAAE,YAAY;IAC3B,KAAKrD,IAAL,GAAY,IAAIX,SAAJ,EAAZ;EACD,CApIc;EAqIfoC,eAAe,EAAE,YAAY;IAC3B,IAAID,IAAI,GAAG,KAAK8B,KAAhB;IACA,IAAI5C,KAAK,GAAG,KAAKA,KAAjB;IACA,IAAI6C,eAAe,GAAG,CAAC/B,IAAvB;;IAEA,IAAI+B,eAAJ,EAAqB;MACnB,IAAIvD,IAAI,GAAG,KAAKA,IAAhB;;MAEA,IAAI,CAACA,IAAL,EAAW;QACT;QACAA,IAAI,GAAG,KAAKA,IAAL,GAAY,IAAIX,SAAJ,EAAnB;MACD;;MAED,IAAI,KAAKc,WAAT,EAAsB;QACpBH,IAAI,CAACsC,SAAL;QACA,KAAKE,SAAL,CAAexC,IAAf,EAAqB,KAAKyC,KAA1B,EAAiC,KAAjC;MACD;;MAEDjB,IAAI,GAAGxB,IAAI,CAACyB,eAAL,EAAP;IACD;;IAED,KAAK6B,KAAL,GAAa9B,IAAb;;IAEA,IAAId,KAAK,CAACC,SAAN,EAAJ,EAAuB;MACrB;MACA;MACA;MACA,IAAI6C,cAAc,GAAG,KAAKC,eAAL,KAAyB,KAAKA,eAAL,GAAuBjC,IAAI,CAACkC,KAAL,EAAhD,CAArB;;MAEA,IAAI,KAAKnC,OAAL,IAAgBgC,eAApB,EAAqC;QACnCC,cAAc,CAACG,IAAf,CAAoBnC,IAApB,EADmC,CACR;;QAE3B,IAAIoC,CAAC,GAAGlD,KAAK,CAACmD,SAAd,CAHmC,CAGV;;QAEzB,IAAIC,SAAS,GAAGpD,KAAK,CAACqD,aAAN,GAAsB,KAAKC,YAAL,EAAtB,GAA4C,CAA5D,CALmC,CAK4B;;QAE/D,IAAI,CAACtD,KAAK,CAACE,OAAN,EAAL,EAAsB;UACpBgD,CAAC,GAAGjE,IAAI,CAACsE,GAAL,CAASL,CAAT,EAAY,KAAKxD,sBAAL,IAA+B,CAA3C,CAAJ;QACD,CATkC,CASjC;QACF;;;QAGA,IAAI0D,SAAS,GAAG,KAAhB,EAAuB;UACrBN,cAAc,CAACU,KAAf,IAAwBN,CAAC,GAAGE,SAA5B;UACAN,cAAc,CAACW,MAAf,IAAyBP,CAAC,GAAGE,SAA7B;UACAN,cAAc,CAACY,CAAf,IAAoBR,CAAC,GAAGE,SAAJ,GAAgB,CAApC;UACAN,cAAc,CAACa,CAAf,IAAoBT,CAAC,GAAGE,SAAJ,GAAgB,CAApC;QACD;MACF,CAzBoB,CAyBnB;;;MAGF,OAAON,cAAP;IACD;;IAED,OAAOhC,IAAP;EACD,CA5Lc;EA6Lf8C,OAAO,EAAE,UAAUF,CAAV,EAAaC,CAAb,EAAgB;IACvB,IAAIE,QAAQ,GAAG,KAAKC,qBAAL,CAA2BJ,CAA3B,EAA8BC,CAA9B,CAAf;IACA,IAAI7C,IAAI,GAAG,KAAKC,eAAL,EAAX;IACA,IAAIf,KAAK,GAAG,KAAKA,KAAjB;IACA0D,CAAC,GAAGG,QAAQ,CAAC,CAAD,CAAZ;IACAF,CAAC,GAAGE,QAAQ,CAAC,CAAD,CAAZ;;IAEA,IAAI/C,IAAI,CAAC8C,OAAL,CAAaF,CAAb,EAAgBC,CAAhB,CAAJ,EAAwB;MACtB,IAAII,QAAQ,GAAG,KAAKzE,IAAL,CAAU0E,IAAzB;;MAEA,IAAIhE,KAAK,CAACC,SAAN,EAAJ,EAAuB;QACrB,IAAIkD,SAAS,GAAGnD,KAAK,CAACmD,SAAtB;QACA,IAAIC,SAAS,GAAGpD,KAAK,CAACqD,aAAN,GAAsB,KAAKC,YAAL,EAAtB,GAA4C,CAA5D,CAFqB,CAE0C;;QAE/D,IAAIF,SAAS,GAAG,KAAhB,EAAuB;UACrB;UACA,IAAI,CAACpD,KAAK,CAACE,OAAN,EAAL,EAAsB;YACpBiD,SAAS,GAAGlE,IAAI,CAACsE,GAAL,CAASJ,SAAT,EAAoB,KAAKzD,sBAAzB,CAAZ;UACD;;UAED,IAAId,WAAW,CAACqF,aAAZ,CAA0BF,QAA1B,EAAoCZ,SAAS,GAAGC,SAAhD,EAA2DM,CAA3D,EAA8DC,CAA9D,CAAJ,EAAsE;YACpE,OAAO,IAAP;UACD;QACF;MACF;;MAED,IAAI3D,KAAK,CAACE,OAAN,EAAJ,EAAqB;QACnB,OAAOtB,WAAW,CAACgF,OAAZ,CAAoBG,QAApB,EAA8BL,CAA9B,EAAiCC,CAAjC,CAAP;MACD;IACF;;IAED,OAAO,KAAP;EACD,CA7Nc;;EA+Nf;AACF;AACA;EACEO,KAAK,EAAE,UAAUC,SAAV,EAAqB;IAC1B,IAAIA,SAAS,IAAI,IAAjB,EAAuB;MACrBA,SAAS,GAAG,IAAZ;IACD,CAHyB,CAGxB;;;IAGF,IAAIA,SAAJ,EAAe;MACb,KAAK1E,WAAL,GAAmB0E,SAAnB;MACA,KAAKvB,KAAL,GAAa,IAAb;IACD;;IAED,KAAK/B,OAAL,GAAe,KAAKuD,WAAL,GAAmB,IAAlC;IACA,KAAKC,IAAL,IAAa,KAAKA,IAAL,CAAUC,OAAV,EAAb,CAZ0B,CAYQ;;IAElC,IAAI,KAAKC,YAAT,EAAuB;MACrB,KAAKA,YAAL,CAAkBL,KAAlB;IACD;EACF,CAnPc;;EAqPf;AACF;AACA;AACA;EACEM,YAAY,EAAE,UAAUC,IAAV,EAAgB;IAC5B,OAAO,KAAKC,OAAL,CAAa,OAAb,EAAsBD,IAAtB,CAAP;EACD,CA3Pc;EA4Pf;EACAE,MAAM,EAAE,UAAUC,GAAV,EAAeC,KAAf,EAAsB;IAC5B;IACA,IAAID,GAAG,KAAK,OAAZ,EAAqB;MACnB,KAAKE,QAAL,CAAcD,KAAd;MACA,KAAKpF,WAAL,GAAmB,IAAnB;MACA,KAAKmD,KAAL,GAAa,IAAb;IACD,CAJD,MAIO;MACLpE,WAAW,CAACO,SAAZ,CAAsB4F,MAAtB,CAA6BtF,IAA7B,CAAkC,IAAlC,EAAwCuF,GAAxC,EAA6CC,KAA7C;IACD;EACF,CAtQc;;EAwQf;AACF;AACA;AACA;EACEC,QAAQ,EAAE,UAAUF,GAAV,EAAeC,KAAf,EAAsB;IAC9B,IAAI9C,KAAK,GAAG,KAAKA,KAAjB,CAD8B,CACN;;IAExB,IAAIA,KAAJ,EAAW;MACT,IAAIrD,MAAM,CAACqG,QAAP,CAAgBH,GAAhB,CAAJ,EAA0B;QACxB,KAAK,IAAII,IAAT,IAAiBJ,GAAjB,EAAsB;UACpB,IAAIA,GAAG,CAACK,cAAJ,CAAmBD,IAAnB,CAAJ,EAA8B;YAC5BjD,KAAK,CAACiD,IAAD,CAAL,GAAcJ,GAAG,CAACI,IAAD,CAAjB;UACD;QACF;MACF,CAND,MAMO;QACLjD,KAAK,CAAC6C,GAAD,CAAL,GAAaC,KAAb;MACD;;MAED,KAAKX,KAAL,CAAW,IAAX;IACD;;IAED,OAAO,IAAP;EACD,CA9Rc;EA+RfZ,YAAY,EAAE,YAAY;IACxB,IAAI4B,CAAC,GAAG,KAAKC,SAAb,CADwB,CACA;IACxB;IACA;IACA;;IAEA,OAAOD,CAAC,IAAIlG,GAAG,CAACkG,CAAC,CAAC,CAAD,CAAD,GAAO,CAAR,CAAH,GAAgB,KAArB,IAA8BlG,GAAG,CAACkG,CAAC,CAAC,CAAD,CAAD,GAAO,CAAR,CAAH,GAAgB,KAA9C,GAAsDjG,IAAI,CAACmG,IAAL,CAAUpG,GAAG,CAACkG,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAR,GAAcA,CAAC,CAAC,CAAD,CAAD,GAAOA,CAAC,CAAC,CAAD,CAAvB,CAAb,CAAtD,GAAkG,CAAzG;EACD;AAtSc,CAAjB;AAwSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA/F,IAAI,CAACkG,MAAL,GAAc,UAAUC,QAAV,EAAoB;EAChC,IAAIC,GAAG,GAAG,UAAUnG,IAAV,EAAgB;IACxBD,IAAI,CAACE,IAAL,CAAU,IAAV,EAAgBD,IAAhB;;IAEA,IAAIkG,QAAQ,CAACtF,KAAb,EAAoB;MAClB;MACA,KAAKA,KAAL,CAAWwF,UAAX,CAAsBF,QAAQ,CAACtF,KAA/B,EAAsC,KAAtC;IACD,CANuB,CAMtB;;;IAGF,IAAIyF,YAAY,GAAGH,QAAQ,CAACvD,KAA5B;;IAEA,IAAI0D,YAAJ,EAAkB;MAChB,KAAK1D,KAAL,GAAa,KAAKA,KAAL,IAAc,EAA3B;MACA,IAAI2D,SAAS,GAAG,KAAK3D,KAArB;;MAEA,KAAK,IAAIiD,IAAT,IAAiBS,YAAjB,EAA+B;QAC7B,IAAI,CAACC,SAAS,CAACT,cAAV,CAAyBD,IAAzB,CAAD,IAAmCS,YAAY,CAACR,cAAb,CAA4BD,IAA5B,CAAvC,EAA0E;UACxEU,SAAS,CAACV,IAAD,CAAT,GAAkBS,YAAY,CAACT,IAAD,CAA9B;QACD;MACF;IACF;;IAEDM,QAAQ,CAACK,IAAT,IAAiBL,QAAQ,CAACK,IAAT,CAActG,IAAd,CAAmB,IAAnB,EAAyBD,IAAzB,CAAjB;EACD,CAvBD;;EAyBAV,MAAM,CAACkH,QAAP,CAAgBL,GAAhB,EAAqBpG,IAArB,EA1BgC,CA0BJ;;EAE5B,KAAK,IAAI6F,IAAT,IAAiBM,QAAjB,EAA2B;IACzB;IACA,IAAIN,IAAI,KAAK,OAAT,IAAoBA,IAAI,KAAK,OAAjC,EAA0C;MACxCO,GAAG,CAACxG,SAAJ,CAAciG,IAAd,IAAsBM,QAAQ,CAACN,IAAD,CAA9B;IACD;EACF;;EAED,OAAOO,GAAP;AACD,CApCD;;AAsCA7G,MAAM,CAACkH,QAAP,CAAgBzG,IAAhB,EAAsBX,WAAtB;AACA,IAAIqH,QAAQ,GAAG1G,IAAf;AACA2G,MAAM,CAACC,OAAP,GAAiBF,QAAjB"},"metadata":{},"sourceType":"script"}