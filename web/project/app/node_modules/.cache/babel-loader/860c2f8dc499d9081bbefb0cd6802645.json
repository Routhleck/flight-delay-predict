{"ast":null,"code":"/**\n * Event Mixin\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\nvar arrySlice = Array.prototype.slice;\n/**\n * Event dispatcher.\n *\n * @alias module:zrender/mixin/Eventful\n * @constructor\n * @param {Object} [eventProcessor] The object eventProcessor is the scope when\n *        `eventProcessor.xxx` called.\n * @param {Function} [eventProcessor.normalizeQuery]\n *        param: {string|Object} Raw query.\n *        return: {string|Object} Normalized query.\n * @param {Function} [eventProcessor.filter] Event will be dispatched only\n *        if it returns `true`.\n *        param: {string} eventType\n *        param: {string|Object} query\n *        return: {boolean}\n * @param {Function} [eventProcessor.afterTrigger] Called after all handlers called.\n *        param: {string} eventType\n */\n\nvar Eventful = function (eventProcessor) {\n  this._$handlers = {};\n  this._$eventProcessor = eventProcessor;\n};\n\nEventful.prototype = {\n  constructor: Eventful,\n\n  /**\n   * The handler can only be triggered once, then removed.\n   *\n   * @param {string} event The event name.\n   * @param {string|Object} [query] Condition used on event filter.\n   * @param {Function} handler The event handler.\n   * @param {Object} context\n   */\n  one: function (event, query, handler, context) {\n    return on(this, event, query, handler, context, true);\n  },\n\n  /**\n   * Bind a handler.\n   *\n   * @param {string} event The event name.\n   * @param {string|Object} [query] Condition used on event filter.\n   * @param {Function} handler The event handler.\n   * @param {Object} [context]\n   */\n  on: function (event, query, handler, context) {\n    return on(this, event, query, handler, context, false);\n  },\n\n  /**\n   * Whether any handler has bound.\n   *\n   * @param  {string}  event\n   * @return {boolean}\n   */\n  isSilent: function (event) {\n    var _h = this._$handlers;\n    return !_h[event] || !_h[event].length;\n  },\n\n  /**\n   * Unbind a event.\n   *\n   * @param {string} [event] The event name.\n   *        If no `event` input, \"off\" all listeners.\n   * @param {Function} [handler] The event handler.\n   *        If no `handler` input, \"off\" all listeners of the `event`.\n   */\n  off: function (event, handler) {\n    var _h = this._$handlers;\n\n    if (!event) {\n      this._$handlers = {};\n      return this;\n    }\n\n    if (handler) {\n      if (_h[event]) {\n        var newList = [];\n\n        for (var i = 0, l = _h[event].length; i < l; i++) {\n          if (_h[event][i].h !== handler) {\n            newList.push(_h[event][i]);\n          }\n        }\n\n        _h[event] = newList;\n      }\n\n      if (_h[event] && _h[event].length === 0) {\n        delete _h[event];\n      }\n    } else {\n      delete _h[event];\n    }\n\n    return this;\n  },\n\n  /**\n   * Dispatch a event.\n   *\n   * @param {string} type The event name.\n   */\n  trigger: function (type) {\n    var _h = this._$handlers[type];\n    var eventProcessor = this._$eventProcessor;\n\n    if (_h) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 3) {\n        args = arrySlice.call(args, 1);\n      }\n\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        var hItem = _h[i];\n\n        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {\n          i++;\n          continue;\n        } // Optimize advise from backbone\n\n\n        switch (argLen) {\n          case 1:\n            hItem.h.call(hItem.ctx);\n            break;\n\n          case 2:\n            hItem.h.call(hItem.ctx, args[1]);\n            break;\n\n          case 3:\n            hItem.h.call(hItem.ctx, args[1], args[2]);\n            break;\n\n          default:\n            // have more than 2 given arguments\n            hItem.h.apply(hItem.ctx, args);\n            break;\n        }\n\n        if (hItem.one) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);\n    return this;\n  },\n\n  /**\n   * Dispatch a event with context, which is specified at the last parameter.\n   *\n   * @param {string} type The event name.\n   */\n  triggerWithContext: function (type) {\n    var _h = this._$handlers[type];\n    var eventProcessor = this._$eventProcessor;\n\n    if (_h) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 4) {\n        args = arrySlice.call(args, 1, args.length - 1);\n      }\n\n      var ctx = args[args.length - 1];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        var hItem = _h[i];\n\n        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {\n          i++;\n          continue;\n        } // Optimize advise from backbone\n\n\n        switch (argLen) {\n          case 1:\n            hItem.h.call(ctx);\n            break;\n\n          case 2:\n            hItem.h.call(ctx, args[1]);\n            break;\n\n          case 3:\n            hItem.h.call(ctx, args[1], args[2]);\n            break;\n\n          default:\n            // have more than 2 given arguments\n            hItem.h.apply(ctx, args);\n            break;\n        }\n\n        if (hItem.one) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);\n    return this;\n  }\n};\n\nfunction normalizeQuery(host, query) {\n  var eventProcessor = host._$eventProcessor;\n\n  if (query != null && eventProcessor && eventProcessor.normalizeQuery) {\n    query = eventProcessor.normalizeQuery(query);\n  }\n\n  return query;\n}\n\nfunction on(eventful, event, query, handler, context, isOnce) {\n  var _h = eventful._$handlers;\n\n  if (typeof query === 'function') {\n    context = handler;\n    handler = query;\n    query = null;\n  }\n\n  if (!handler || !event) {\n    return eventful;\n  }\n\n  query = normalizeQuery(eventful, query);\n\n  if (!_h[event]) {\n    _h[event] = [];\n  }\n\n  for (var i = 0; i < _h[event].length; i++) {\n    if (_h[event][i].h === handler) {\n      return eventful;\n    }\n  }\n\n  var wrap = {\n    h: handler,\n    one: isOnce,\n    query: query,\n    ctx: context || eventful,\n    // FIXME\n    // Do not publish this feature util it is proved that it makes sense.\n    callAtLast: handler.zrEventfulCallAtLast\n  };\n  var lastIndex = _h[event].length - 1;\n  var lastWrap = _h[event][lastIndex];\n  lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);\n  return eventful;\n} // ----------------------\n// The events in zrender\n// ----------------------\n\n/**\n * @event module:zrender/mixin/Eventful#onclick\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseout\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousemove\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousewheel\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousedown\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseup\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrag\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragstart\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragend\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragenter\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragleave\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrop\n * @type {Function}\n * @default null\n */\n\n\nvar _default = Eventful;\nmodule.exports = _default;","map":{"version":3,"names":["arrySlice","Array","prototype","slice","Eventful","eventProcessor","_$handlers","_$eventProcessor","constructor","one","event","query","handler","context","on","isSilent","_h","length","off","newList","i","l","h","push","trigger","type","args","arguments","argLen","call","len","hItem","filter","ctx","apply","splice","afterTrigger","triggerWithContext","normalizeQuery","host","eventful","isOnce","wrap","callAtLast","zrEventfulCallAtLast","lastIndex","lastWrap","_default","module","exports"],"sources":["C:/Users/XiaoAn1/Desktop/project/app/node_modules/zrender/lib/mixin/Eventful.js"],"sourcesContent":["/**\n * Event Mixin\n * @module zrender/mixin/Eventful\n * @author Kener (@Kener-林峰, kener.linfeng@gmail.com)\n *         pissang (https://www.github.com/pissang)\n */\nvar arrySlice = Array.prototype.slice;\n/**\n * Event dispatcher.\n *\n * @alias module:zrender/mixin/Eventful\n * @constructor\n * @param {Object} [eventProcessor] The object eventProcessor is the scope when\n *        `eventProcessor.xxx` called.\n * @param {Function} [eventProcessor.normalizeQuery]\n *        param: {string|Object} Raw query.\n *        return: {string|Object} Normalized query.\n * @param {Function} [eventProcessor.filter] Event will be dispatched only\n *        if it returns `true`.\n *        param: {string} eventType\n *        param: {string|Object} query\n *        return: {boolean}\n * @param {Function} [eventProcessor.afterTrigger] Called after all handlers called.\n *        param: {string} eventType\n */\n\nvar Eventful = function (eventProcessor) {\n  this._$handlers = {};\n  this._$eventProcessor = eventProcessor;\n};\n\nEventful.prototype = {\n  constructor: Eventful,\n\n  /**\n   * The handler can only be triggered once, then removed.\n   *\n   * @param {string} event The event name.\n   * @param {string|Object} [query] Condition used on event filter.\n   * @param {Function} handler The event handler.\n   * @param {Object} context\n   */\n  one: function (event, query, handler, context) {\n    return on(this, event, query, handler, context, true);\n  },\n\n  /**\n   * Bind a handler.\n   *\n   * @param {string} event The event name.\n   * @param {string|Object} [query] Condition used on event filter.\n   * @param {Function} handler The event handler.\n   * @param {Object} [context]\n   */\n  on: function (event, query, handler, context) {\n    return on(this, event, query, handler, context, false);\n  },\n\n  /**\n   * Whether any handler has bound.\n   *\n   * @param  {string}  event\n   * @return {boolean}\n   */\n  isSilent: function (event) {\n    var _h = this._$handlers;\n    return !_h[event] || !_h[event].length;\n  },\n\n  /**\n   * Unbind a event.\n   *\n   * @param {string} [event] The event name.\n   *        If no `event` input, \"off\" all listeners.\n   * @param {Function} [handler] The event handler.\n   *        If no `handler` input, \"off\" all listeners of the `event`.\n   */\n  off: function (event, handler) {\n    var _h = this._$handlers;\n\n    if (!event) {\n      this._$handlers = {};\n      return this;\n    }\n\n    if (handler) {\n      if (_h[event]) {\n        var newList = [];\n\n        for (var i = 0, l = _h[event].length; i < l; i++) {\n          if (_h[event][i].h !== handler) {\n            newList.push(_h[event][i]);\n          }\n        }\n\n        _h[event] = newList;\n      }\n\n      if (_h[event] && _h[event].length === 0) {\n        delete _h[event];\n      }\n    } else {\n      delete _h[event];\n    }\n\n    return this;\n  },\n\n  /**\n   * Dispatch a event.\n   *\n   * @param {string} type The event name.\n   */\n  trigger: function (type) {\n    var _h = this._$handlers[type];\n    var eventProcessor = this._$eventProcessor;\n\n    if (_h) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 3) {\n        args = arrySlice.call(args, 1);\n      }\n\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        var hItem = _h[i];\n\n        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {\n          i++;\n          continue;\n        } // Optimize advise from backbone\n\n\n        switch (argLen) {\n          case 1:\n            hItem.h.call(hItem.ctx);\n            break;\n\n          case 2:\n            hItem.h.call(hItem.ctx, args[1]);\n            break;\n\n          case 3:\n            hItem.h.call(hItem.ctx, args[1], args[2]);\n            break;\n\n          default:\n            // have more than 2 given arguments\n            hItem.h.apply(hItem.ctx, args);\n            break;\n        }\n\n        if (hItem.one) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);\n    return this;\n  },\n\n  /**\n   * Dispatch a event with context, which is specified at the last parameter.\n   *\n   * @param {string} type The event name.\n   */\n  triggerWithContext: function (type) {\n    var _h = this._$handlers[type];\n    var eventProcessor = this._$eventProcessor;\n\n    if (_h) {\n      var args = arguments;\n      var argLen = args.length;\n\n      if (argLen > 4) {\n        args = arrySlice.call(args, 1, args.length - 1);\n      }\n\n      var ctx = args[args.length - 1];\n      var len = _h.length;\n\n      for (var i = 0; i < len;) {\n        var hItem = _h[i];\n\n        if (eventProcessor && eventProcessor.filter && hItem.query != null && !eventProcessor.filter(type, hItem.query)) {\n          i++;\n          continue;\n        } // Optimize advise from backbone\n\n\n        switch (argLen) {\n          case 1:\n            hItem.h.call(ctx);\n            break;\n\n          case 2:\n            hItem.h.call(ctx, args[1]);\n            break;\n\n          case 3:\n            hItem.h.call(ctx, args[1], args[2]);\n            break;\n\n          default:\n            // have more than 2 given arguments\n            hItem.h.apply(ctx, args);\n            break;\n        }\n\n        if (hItem.one) {\n          _h.splice(i, 1);\n\n          len--;\n        } else {\n          i++;\n        }\n      }\n    }\n\n    eventProcessor && eventProcessor.afterTrigger && eventProcessor.afterTrigger(type);\n    return this;\n  }\n};\n\nfunction normalizeQuery(host, query) {\n  var eventProcessor = host._$eventProcessor;\n\n  if (query != null && eventProcessor && eventProcessor.normalizeQuery) {\n    query = eventProcessor.normalizeQuery(query);\n  }\n\n  return query;\n}\n\nfunction on(eventful, event, query, handler, context, isOnce) {\n  var _h = eventful._$handlers;\n\n  if (typeof query === 'function') {\n    context = handler;\n    handler = query;\n    query = null;\n  }\n\n  if (!handler || !event) {\n    return eventful;\n  }\n\n  query = normalizeQuery(eventful, query);\n\n  if (!_h[event]) {\n    _h[event] = [];\n  }\n\n  for (var i = 0; i < _h[event].length; i++) {\n    if (_h[event][i].h === handler) {\n      return eventful;\n    }\n  }\n\n  var wrap = {\n    h: handler,\n    one: isOnce,\n    query: query,\n    ctx: context || eventful,\n    // FIXME\n    // Do not publish this feature util it is proved that it makes sense.\n    callAtLast: handler.zrEventfulCallAtLast\n  };\n  var lastIndex = _h[event].length - 1;\n  var lastWrap = _h[event][lastIndex];\n  lastWrap && lastWrap.callAtLast ? _h[event].splice(lastIndex, 0, wrap) : _h[event].push(wrap);\n  return eventful;\n} // ----------------------\n// The events in zrender\n// ----------------------\n\n/**\n * @event module:zrender/mixin/Eventful#onclick\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseout\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousemove\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousewheel\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmousedown\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#onmouseup\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrag\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragstart\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragend\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragenter\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragleave\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondragover\n * @type {Function}\n * @default null\n */\n\n/**\n * @event module:zrender/mixin/Eventful#ondrop\n * @type {Function}\n * @default null\n */\n\n\nvar _default = Eventful;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}