{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Poly path support NaN point\n\n\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  // if (smoothMonotone == null) {\n  //     if (isMono(points, 'x')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n  //     }\n  //     else if (isMono(points, 'y')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n  //     }\n  //     else {\n  //         return drawNonMono.apply(this, arguments);\n  //     }\n  // }\n  // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n  //     return drawMono.apply(this, arguments);\n  // }\n  // else {\n  //     return drawNonMono.apply(this, arguments);\n  // }\n  if (smoothMonotone === 'none' || !smoothMonotone) {\n    return drawNonMono.apply(this, arguments);\n  } else {\n    return drawMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n// function isMono(points, smoothMonotone) {\n//     if (points.length <= 1) {\n//         return true;\n//     }\n//     var dim = smoothMonotone === 'x' ? 0 : 1;\n//     var last = points[0][dim];\n//     var lastDiff = 0;\n//     for (var i = 1; i < points.length; ++i) {\n//         var diff = points[i][dim] - last;\n//         if (!isNaN(diff) && !isNaN(lastDiff)\n//             && diff !== 0 && lastDiff !== 0\n//             && ((diff >= 0) !== (lastDiff >= 0))\n//         ) {\n//             return false;\n//         }\n//         if (!isNaN(diff) && diff !== 0) {\n//             lastDiff = diff;\n//             last = points[i][dim];\n//         }\n//     }\n//     return true;\n// }\n\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;","map":{"version":3,"names":["Path","require","vec2","fixClipWithShadow","vec2Min","min","vec2Max","max","scaleAndAdd","v2Copy","copy","v","cp0","cp1","isPointNull","p","isNaN","drawSegment","ctx","points","start","segLen","allLen","dir","smoothMin","smoothMax","smooth","smoothMonotone","connectNulls","drawNonMono","apply","arguments","drawMono","prevIdx","idx","k","prevP","dim","ctrlLen","bezierCurveTo","lineTo","nextIdx","nextP","ratioNextSeg","sub","lenPrevSeg","lenNextSeg","Math","abs","dist","getBoundingBox","smoothConstraint","ptMin","Infinity","ptMax","i","length","pt","Polyline","extend","type","shape","style","fill","stroke","brush","prototype","buildPath","len","result","Polygon","stackedOnPoints","stackedOnSmooth","bbox","stackedOnBBox","closePath","exports"],"sources":["C:/Users/XiaoAn1/Desktop/project/app/node_modules/echarts/lib/chart/line/poly.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar Path = require(\"zrender/lib/graphic/Path\");\n\nvar vec2 = require(\"zrender/lib/core/vector\");\n\nvar fixClipWithShadow = require(\"zrender/lib/graphic/helper/fixClipWithShadow\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// Poly path support NaN point\nvar vec2Min = vec2.min;\nvar vec2Max = vec2.max;\nvar scaleAndAdd = vec2.scaleAndAdd;\nvar v2Copy = vec2.copy; // Temporary variable\n\nvar v = [];\nvar cp0 = [];\nvar cp1 = [];\n\nfunction isPointNull(p) {\n  return isNaN(p[0]) || isNaN(p[1]);\n}\n\nfunction drawSegment(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  // if (smoothMonotone == null) {\n  //     if (isMono(points, 'x')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'x', connectNulls);\n  //     }\n  //     else if (isMono(points, 'y')) {\n  //         return drawMono(ctx, points, start, segLen, allLen,\n  //             dir, smoothMin, smoothMax, smooth, 'y', connectNulls);\n  //     }\n  //     else {\n  //         return drawNonMono.apply(this, arguments);\n  //     }\n  // }\n  // else if (smoothMonotone !== 'none' && isMono(points, smoothMonotone)) {\n  //     return drawMono.apply(this, arguments);\n  // }\n  // else {\n  //     return drawNonMono.apply(this, arguments);\n  // }\n  if (smoothMonotone === 'none' || !smoothMonotone) {\n    return drawNonMono.apply(this, arguments);\n  } else {\n    return drawMono.apply(this, arguments);\n  }\n}\n/**\n * Check if points is in monotone.\n *\n * @param {number[][]} points         Array of points which is in [x, y] form\n * @param {string}     smoothMonotone 'x', 'y', or 'none', stating for which\n *                                    dimension that is checking.\n *                                    If is 'none', `drawNonMono` should be\n *                                    called.\n *                                    If is undefined, either being monotone\n *                                    in 'x' or 'y' will call `drawMono`.\n */\n// function isMono(points, smoothMonotone) {\n//     if (points.length <= 1) {\n//         return true;\n//     }\n//     var dim = smoothMonotone === 'x' ? 0 : 1;\n//     var last = points[0][dim];\n//     var lastDiff = 0;\n//     for (var i = 1; i < points.length; ++i) {\n//         var diff = points[i][dim] - last;\n//         if (!isNaN(diff) && !isNaN(lastDiff)\n//             && diff !== 0 && lastDiff !== 0\n//             && ((diff >= 0) !== (lastDiff >= 0))\n//         ) {\n//             return false;\n//         }\n//         if (!isNaN(diff) && diff !== 0) {\n//             lastDiff = diff;\n//             last = points[i][dim];\n//         }\n//     }\n//     return true;\n// }\n\n/**\n * Draw smoothed line in monotone, in which only vertical or horizontal bezier\n * control points will be used. This should be used when points are monotone\n * either in x or y dimension.\n */\n\n\nfunction drawMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n    } else {\n      if (smooth > 0) {\n        var prevP = points[prevIdx];\n        var dim = smoothMonotone === 'y' ? 1 : 0; // Length of control point to p, either in x or y, but not both\n\n        var ctrlLen = (p[dim] - prevP[dim]) * smooth;\n        v2Copy(cp0, prevP);\n        cp0[dim] = prevP[dim] + ctrlLen;\n        v2Copy(cp1, p);\n        cp1[dim] = p[dim] - ctrlLen;\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n/**\n * Draw smoothed line in non-monotone, in may cause undesired curve in extreme\n * situations. This should be used when points are non-monotone neither in x or\n * y dimension.\n */\n\n\nfunction drawNonMono(ctx, points, start, segLen, allLen, dir, smoothMin, smoothMax, smooth, smoothMonotone, connectNulls) {\n  var prevIdx = 0;\n  var idx = start;\n\n  for (var k = 0; k < segLen; k++) {\n    var p = points[idx];\n\n    if (idx >= allLen || idx < 0) {\n      break;\n    }\n\n    if (isPointNull(p)) {\n      if (connectNulls) {\n        idx += dir;\n        continue;\n      }\n\n      break;\n    }\n\n    if (idx === start) {\n      ctx[dir > 0 ? 'moveTo' : 'lineTo'](p[0], p[1]);\n      v2Copy(cp0, p);\n    } else {\n      if (smooth > 0) {\n        var nextIdx = idx + dir;\n        var nextP = points[nextIdx];\n\n        if (connectNulls) {\n          // Find next point not null\n          while (nextP && isPointNull(points[nextIdx])) {\n            nextIdx += dir;\n            nextP = points[nextIdx];\n          }\n        }\n\n        var ratioNextSeg = 0.5;\n        var prevP = points[prevIdx];\n        var nextP = points[nextIdx]; // Last point\n\n        if (!nextP || isPointNull(nextP)) {\n          v2Copy(cp1, p);\n        } else {\n          // If next data is null in not connect case\n          if (isPointNull(nextP) && !connectNulls) {\n            nextP = p;\n          }\n\n          vec2.sub(v, nextP, prevP);\n          var lenPrevSeg;\n          var lenNextSeg;\n\n          if (smoothMonotone === 'x' || smoothMonotone === 'y') {\n            var dim = smoothMonotone === 'x' ? 0 : 1;\n            lenPrevSeg = Math.abs(p[dim] - prevP[dim]);\n            lenNextSeg = Math.abs(p[dim] - nextP[dim]);\n          } else {\n            lenPrevSeg = vec2.dist(p, prevP);\n            lenNextSeg = vec2.dist(p, nextP);\n          } // Use ratio of seg length\n\n\n          ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg);\n          scaleAndAdd(cp1, p, v, -smooth * (1 - ratioNextSeg));\n        } // Smooth constraint\n\n\n        vec2Min(cp0, cp0, smoothMax);\n        vec2Max(cp0, cp0, smoothMin);\n        vec2Min(cp1, cp1, smoothMax);\n        vec2Max(cp1, cp1, smoothMin);\n        ctx.bezierCurveTo(cp0[0], cp0[1], cp1[0], cp1[1], p[0], p[1]); // cp0 of next segment\n\n        scaleAndAdd(cp0, p, v, smooth * ratioNextSeg);\n      } else {\n        ctx.lineTo(p[0], p[1]);\n      }\n    }\n\n    prevIdx = idx;\n    idx += dir;\n  }\n\n  return k;\n}\n\nfunction getBoundingBox(points, smoothConstraint) {\n  var ptMin = [Infinity, Infinity];\n  var ptMax = [-Infinity, -Infinity];\n\n  if (smoothConstraint) {\n    for (var i = 0; i < points.length; i++) {\n      var pt = points[i];\n\n      if (pt[0] < ptMin[0]) {\n        ptMin[0] = pt[0];\n      }\n\n      if (pt[1] < ptMin[1]) {\n        ptMin[1] = pt[1];\n      }\n\n      if (pt[0] > ptMax[0]) {\n        ptMax[0] = pt[0];\n      }\n\n      if (pt[1] > ptMax[1]) {\n        ptMax[1] = pt[1];\n      }\n    }\n  }\n\n  return {\n    min: smoothConstraint ? ptMin : ptMax,\n    max: smoothConstraint ? ptMax : ptMin\n  };\n}\n\nvar Polyline = Path.extend({\n  type: 'ec-polyline',\n  shape: {\n    points: [],\n    smooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  style: {\n    fill: null,\n    stroke: '#000'\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var i = 0;\n    var len = points.length;\n    var result = getBoundingBox(points, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      i += drawSegment(ctx, points, i, len, len, 1, result.min, result.max, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1;\n    }\n  }\n});\nvar Polygon = Path.extend({\n  type: 'ec-polygon',\n  shape: {\n    points: [],\n    // Offset between stacked base points and points\n    stackedOnPoints: [],\n    smooth: 0,\n    stackedOnSmooth: 0,\n    smoothConstraint: true,\n    smoothMonotone: null,\n    connectNulls: false\n  },\n  brush: fixClipWithShadow(Path.prototype.brush),\n  buildPath: function (ctx, shape) {\n    var points = shape.points;\n    var stackedOnPoints = shape.stackedOnPoints;\n    var i = 0;\n    var len = points.length;\n    var smoothMonotone = shape.smoothMonotone;\n    var bbox = getBoundingBox(points, shape.smoothConstraint);\n    var stackedOnBBox = getBoundingBox(stackedOnPoints, shape.smoothConstraint);\n\n    if (shape.connectNulls) {\n      // Must remove first and last null values avoid draw error in polygon\n      for (; len > 0; len--) {\n        if (!isPointNull(points[len - 1])) {\n          break;\n        }\n      }\n\n      for (; i < len; i++) {\n        if (!isPointNull(points[i])) {\n          break;\n        }\n      }\n    }\n\n    while (i < len) {\n      var k = drawSegment(ctx, points, i, len, len, 1, bbox.min, bbox.max, shape.smooth, smoothMonotone, shape.connectNulls);\n      drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, stackedOnBBox.min, stackedOnBBox.max, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls);\n      i += k + 1;\n      ctx.closePath();\n    }\n  }\n});\nexports.Polyline = Polyline;\nexports.Polygon = Polygon;"],"mappings":"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"},"metadata":{},"sourceType":"script"}