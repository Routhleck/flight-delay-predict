{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../util/model\");\n\nvar ComponentModel = require(\"./Component\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\n\n\nvar each = zrUtil.each;\nvar clone = zrUtil.clone;\nvar map = zrUtil.map;\nvar merge = zrUtil.merge;\nvar QUERY_REG = /^(min|max)?(.+)$/;\n/**\n * TERM EXPLANATIONS:\n *\n * [option]:\n *\n *     An object that contains definitions of components. For example:\n *     var option = {\n *         title: {...},\n *         legend: {...},\n *         visualMap: {...},\n *         series: [\n *             {data: [...]},\n *             {data: [...]},\n *             ...\n *         ]\n *     };\n *\n * [rawOption]:\n *\n *     An object input to echarts.setOption. 'rawOption' may be an\n *     'option', or may be an object contains multi-options. For example:\n *     var option = {\n *         baseOption: {\n *             title: {...},\n *             legend: {...},\n *             series: [\n *                 {data: [...]},\n *                 {data: [...]},\n *                 ...\n *             ]\n *         },\n *         timeline: {...},\n *         options: [\n *             {title: {...}, series: {data: [...]}},\n *             {title: {...}, series: {data: [...]}},\n *             ...\n *         ],\n *         media: [\n *             {\n *                 query: {maxWidth: 320},\n *                 option: {series: {x: 20}, visualMap: {show: false}}\n *             },\n *             {\n *                 query: {minWidth: 320, maxWidth: 720},\n *                 option: {series: {x: 500}, visualMap: {show: true}}\n *             },\n *             {\n *                 option: {series: {x: 1200}, visualMap: {show: true}}\n *             }\n *         ]\n *     };\n *\n * @alias module:echarts/model/OptionManager\n * @param {module:echarts/ExtensionAPI} api\n */\n\nfunction OptionManager(api) {\n  /**\n   * @private\n   * @type {module:echarts/ExtensionAPI}\n   */\n  this._api = api;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._timelineOptions = [];\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n\n  this._mediaList = [];\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._mediaDefault;\n  /**\n   * -1, means default.\n   * empty means no media.\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._currentMediaIndices = [];\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._optionBackup;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._newBaseOption;\n} // timeline.notMerge is not supported in ec3. Firstly there is rearly\n// case that notMerge is needed. Secondly supporting 'notMerge' requires\n// rawOption cloned and backuped when timeline changed, which does no\n// good to performance. What's more, that both timeline and setOption\n// method supply 'notMerge' brings complex and some problems.\n// Consider this case:\n// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n\nOptionManager.prototype = {\n  constructor: OptionManager,\n\n  /**\n   * @public\n   * @param {Object} rawOption Raw option.\n   * @param {module:echarts/model/Global} ecModel\n   * @param {Array.<Function>} optionPreprocessorFuncs\n   * @return {Object} Init option\n   */\n  setOption: function (rawOption, optionPreprocessorFuncs) {\n    if (rawOption) {\n      // That set dat primitive is dangerous if user reuse the data when setOption again.\n      zrUtil.each(modelUtil.normalizeToArray(rawOption.series), function (series) {\n        series && series.data && zrUtil.isTypedArray(series.data) && zrUtil.setAsPrimitive(series.data);\n      });\n    } // Caution: some series modify option data, if do not clone,\n    // it should ensure that the repeat modify correctly\n    // (create a new object when modify itself).\n\n\n    rawOption = clone(rawOption); // FIXME\n    // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n\n    var oldOptionBackup = this._optionBackup;\n    var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);\n\n    if (oldOptionBackup) {\n      // Only baseOption can be merged.\n      mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge,\n      // that is, if you `setOption` twice and both has timeline options, the latter\n      // timeline opitons will not be merged to the formers, but just substitude them.\n\n      if (newParsedOption.timelineOptions.length) {\n        oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n      }\n\n      if (newParsedOption.mediaList.length) {\n        oldOptionBackup.mediaList = newParsedOption.mediaList;\n      }\n\n      if (newParsedOption.mediaDefault) {\n        oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n      }\n    } else {\n      this._optionBackup = newParsedOption;\n    }\n  },\n\n  /**\n   * @param {boolean} isRecreate\n   * @return {Object}\n   */\n  mountOption: function (isRecreate) {\n    var optionBackup = this._optionBackup; // TODO\n    // 如果没有reset功能则不clone。\n\n    this._timelineOptions = map(optionBackup.timelineOptions, clone);\n    this._mediaList = map(optionBackup.mediaList, clone);\n    this._mediaDefault = clone(optionBackup.mediaDefault);\n    this._currentMediaIndices = [];\n    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`\n    // called, and is merged into every new option by inner method `mergeOption`\n    // each time `setOption` called, can be only used in `isRecreate`, because\n    // its reliability is under suspicion. In other cases option merge is\n    // performed by `model.mergeOption`.\n    ? optionBackup.baseOption : this._newBaseOption);\n  },\n\n  /**\n   * @param {module:echarts/model/Global} ecModel\n   * @return {Object}\n   */\n  getTimelineOption: function (ecModel) {\n    var option;\n    var timelineOptions = this._timelineOptions;\n\n    if (timelineOptions.length) {\n      // getTimelineOption can only be called after ecModel inited,\n      // so we can get currentIndex from timelineModel.\n      var timelineModel = ecModel.getComponent('timeline');\n\n      if (timelineModel) {\n        option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n      }\n    }\n\n    return option;\n  },\n\n  /**\n   * @param {module:echarts/model/Global} ecModel\n   * @return {Array.<Object>}\n   */\n  getMediaOption: function (ecModel) {\n    var ecWidth = this._api.getWidth();\n\n    var ecHeight = this._api.getHeight();\n\n    var mediaList = this._mediaList;\n    var mediaDefault = this._mediaDefault;\n    var indices = [];\n    var result = []; // No media defined.\n\n    if (!mediaList.length && !mediaDefault) {\n      return result;\n    } // Multi media may be applied, the latter defined media has higher priority.\n\n\n    for (var i = 0, len = mediaList.length; i < len; i++) {\n      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n        indices.push(i);\n      }\n    } // FIXME\n    // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n\n\n    if (!indices.length && mediaDefault) {\n      indices = [-1];\n    }\n\n    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n      result = map(indices, function (index) {\n        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n      });\n    } // Otherwise return nothing.\n\n\n    this._currentMediaIndices = indices;\n    return result;\n  }\n};\n\nfunction parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n  var timelineOptions = [];\n  var mediaList = [];\n  var mediaDefault;\n  var baseOption; // Compatible with ec2.\n\n  var timelineOpt = rawOption.timeline;\n\n  if (rawOption.baseOption) {\n    baseOption = rawOption.baseOption;\n  } // For timeline\n\n\n  if (timelineOpt || rawOption.options) {\n    baseOption = baseOption || {};\n    timelineOptions = (rawOption.options || []).slice();\n  } // For media query\n\n\n  if (rawOption.media) {\n    baseOption = baseOption || {};\n    var media = rawOption.media;\n    each(media, function (singleMedia) {\n      if (singleMedia && singleMedia.option) {\n        if (singleMedia.query) {\n          mediaList.push(singleMedia);\n        } else if (!mediaDefault) {\n          // Use the first media default.\n          mediaDefault = singleMedia;\n        }\n      }\n    });\n  } // For normal option\n\n\n  if (!baseOption) {\n    baseOption = rawOption;\n  } // Set timelineOpt to baseOption in ec3,\n  // which is convenient for merge option.\n\n\n  if (!baseOption.timeline) {\n    baseOption.timeline = timelineOpt;\n  } // Preprocess.\n\n\n  each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n    return media.option;\n  })), function (option) {\n    each(optionPreprocessorFuncs, function (preProcess) {\n      preProcess(option, isNew);\n    });\n  });\n  return {\n    baseOption: baseOption,\n    timelineOptions: timelineOptions,\n    mediaDefault: mediaDefault,\n    mediaList: mediaList\n  };\n}\n/**\n * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n * Support: width, height, aspectRatio\n * Can use max or min as prefix.\n */\n\n\nfunction applyMediaQuery(query, ecWidth, ecHeight) {\n  var realMap = {\n    width: ecWidth,\n    height: ecHeight,\n    aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n\n  };\n  var applicatable = true;\n  zrUtil.each(query, function (value, attr) {\n    var matched = attr.match(QUERY_REG);\n\n    if (!matched || !matched[1] || !matched[2]) {\n      return;\n    }\n\n    var operator = matched[1];\n    var realAttr = matched[2].toLowerCase();\n\n    if (!compare(realMap[realAttr], value, operator)) {\n      applicatable = false;\n    }\n  });\n  return applicatable;\n}\n\nfunction compare(real, expect, operator) {\n  if (operator === 'min') {\n    return real >= expect;\n  } else if (operator === 'max') {\n    return real <= expect;\n  } else {\n    // Equals\n    return real === expect;\n  }\n}\n\nfunction indicesEquals(indices1, indices2) {\n  // indices is always order by asc and has only finite number.\n  return indices1.join(',') === indices2.join(',');\n}\n/**\n * Consider case:\n * `chart.setOption(opt1);`\n * Then user do some interaction like dataZoom, dataView changing.\n * `chart.setOption(opt2);`\n * Then user press 'reset button' in toolbox.\n *\n * After doing that all of the interaction effects should be reset, the\n * chart should be the same as the result of invoke\n * `chart.setOption(opt1); chart.setOption(opt2);`.\n *\n * Although it is not able ensure that\n * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n * `chart.setOption(merge(opt1, opt2));` exactly,\n * this might be the only simple way to implement that feature.\n *\n * MEMO: We've considered some other approaches:\n * 1. Each model handle its self restoration but not uniform treatment.\n *     (Too complex in logic and error-prone)\n * 2. Use a shadow ecModel. (Performace expensive)\n */\n\n\nfunction mergeOption(oldOption, newOption) {\n  newOption = newOption || {};\n  each(newOption, function (newCptOpt, mainType) {\n    if (newCptOpt == null) {\n      return;\n    }\n\n    var oldCptOpt = oldOption[mainType];\n\n    if (!ComponentModel.hasClass(mainType)) {\n      oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n    } else {\n      newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n      oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n      var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n      oldOption[mainType] = map(mapResult, function (item) {\n        return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n      });\n    }\n  });\n}\n\nvar _default = OptionManager;\nmodule.exports = _default;","map":{"version":3,"names":["zrUtil","require","modelUtil","ComponentModel","each","clone","map","merge","QUERY_REG","OptionManager","api","_api","_timelineOptions","_mediaList","_mediaDefault","_currentMediaIndices","_optionBackup","_newBaseOption","prototype","constructor","setOption","rawOption","optionPreprocessorFuncs","normalizeToArray","series","data","isTypedArray","setAsPrimitive","oldOptionBackup","newParsedOption","parseRawOption","call","baseOption","mergeOption","timelineOptions","length","mediaList","mediaDefault","mountOption","isRecreate","optionBackup","getTimelineOption","ecModel","option","timelineModel","getComponent","getCurrentIndex","getMediaOption","ecWidth","getWidth","ecHeight","getHeight","indices","result","i","len","applyMediaQuery","query","push","indicesEquals","index","isNew","timelineOpt","timeline","options","slice","media","singleMedia","concat","preProcess","realMap","width","height","aspectratio","applicatable","value","attr","matched","match","operator","realAttr","toLowerCase","compare","real","expect","indices1","indices2","join","oldOption","newOption","newCptOpt","mainType","oldCptOpt","hasClass","mapResult","mappingToExists","item","exist","_default","module","exports"],"sources":["D:/Desktop/project/project/project/app/node_modules/echarts/lib/model/OptionManager.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar modelUtil = require(\"../util/model\");\n\nvar ComponentModel = require(\"./Component\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * ECharts option manager\n *\n * @module {echarts/model/OptionManager}\n */\nvar each = zrUtil.each;\nvar clone = zrUtil.clone;\nvar map = zrUtil.map;\nvar merge = zrUtil.merge;\nvar QUERY_REG = /^(min|max)?(.+)$/;\n/**\n * TERM EXPLANATIONS:\n *\n * [option]:\n *\n *     An object that contains definitions of components. For example:\n *     var option = {\n *         title: {...},\n *         legend: {...},\n *         visualMap: {...},\n *         series: [\n *             {data: [...]},\n *             {data: [...]},\n *             ...\n *         ]\n *     };\n *\n * [rawOption]:\n *\n *     An object input to echarts.setOption. 'rawOption' may be an\n *     'option', or may be an object contains multi-options. For example:\n *     var option = {\n *         baseOption: {\n *             title: {...},\n *             legend: {...},\n *             series: [\n *                 {data: [...]},\n *                 {data: [...]},\n *                 ...\n *             ]\n *         },\n *         timeline: {...},\n *         options: [\n *             {title: {...}, series: {data: [...]}},\n *             {title: {...}, series: {data: [...]}},\n *             ...\n *         ],\n *         media: [\n *             {\n *                 query: {maxWidth: 320},\n *                 option: {series: {x: 20}, visualMap: {show: false}}\n *             },\n *             {\n *                 query: {minWidth: 320, maxWidth: 720},\n *                 option: {series: {x: 500}, visualMap: {show: true}}\n *             },\n *             {\n *                 option: {series: {x: 1200}, visualMap: {show: true}}\n *             }\n *         ]\n *     };\n *\n * @alias module:echarts/model/OptionManager\n * @param {module:echarts/ExtensionAPI} api\n */\n\nfunction OptionManager(api) {\n  /**\n   * @private\n   * @type {module:echarts/ExtensionAPI}\n   */\n  this._api = api;\n  /**\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._timelineOptions = [];\n  /**\n   * @private\n   * @type {Array.<Object>}\n   */\n\n  this._mediaList = [];\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._mediaDefault;\n  /**\n   * -1, means default.\n   * empty means no media.\n   * @private\n   * @type {Array.<number>}\n   */\n\n  this._currentMediaIndices = [];\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._optionBackup;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._newBaseOption;\n} // timeline.notMerge is not supported in ec3. Firstly there is rearly\n// case that notMerge is needed. Secondly supporting 'notMerge' requires\n// rawOption cloned and backuped when timeline changed, which does no\n// good to performance. What's more, that both timeline and setOption\n// method supply 'notMerge' brings complex and some problems.\n// Consider this case:\n// (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);\n// (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);\n\n\nOptionManager.prototype = {\n  constructor: OptionManager,\n\n  /**\n   * @public\n   * @param {Object} rawOption Raw option.\n   * @param {module:echarts/model/Global} ecModel\n   * @param {Array.<Function>} optionPreprocessorFuncs\n   * @return {Object} Init option\n   */\n  setOption: function (rawOption, optionPreprocessorFuncs) {\n    if (rawOption) {\n      // That set dat primitive is dangerous if user reuse the data when setOption again.\n      zrUtil.each(modelUtil.normalizeToArray(rawOption.series), function (series) {\n        series && series.data && zrUtil.isTypedArray(series.data) && zrUtil.setAsPrimitive(series.data);\n      });\n    } // Caution: some series modify option data, if do not clone,\n    // it should ensure that the repeat modify correctly\n    // (create a new object when modify itself).\n\n\n    rawOption = clone(rawOption); // FIXME\n    // 如果 timeline options 或者 media 中设置了某个属性，而baseOption中没有设置，则进行警告。\n\n    var oldOptionBackup = this._optionBackup;\n    var newParsedOption = parseRawOption.call(this, rawOption, optionPreprocessorFuncs, !oldOptionBackup);\n    this._newBaseOption = newParsedOption.baseOption; // For setOption at second time (using merge mode);\n\n    if (oldOptionBackup) {\n      // Only baseOption can be merged.\n      mergeOption(oldOptionBackup.baseOption, newParsedOption.baseOption); // For simplicity, timeline options and media options do not support merge,\n      // that is, if you `setOption` twice and both has timeline options, the latter\n      // timeline opitons will not be merged to the formers, but just substitude them.\n\n      if (newParsedOption.timelineOptions.length) {\n        oldOptionBackup.timelineOptions = newParsedOption.timelineOptions;\n      }\n\n      if (newParsedOption.mediaList.length) {\n        oldOptionBackup.mediaList = newParsedOption.mediaList;\n      }\n\n      if (newParsedOption.mediaDefault) {\n        oldOptionBackup.mediaDefault = newParsedOption.mediaDefault;\n      }\n    } else {\n      this._optionBackup = newParsedOption;\n    }\n  },\n\n  /**\n   * @param {boolean} isRecreate\n   * @return {Object}\n   */\n  mountOption: function (isRecreate) {\n    var optionBackup = this._optionBackup; // TODO\n    // 如果没有reset功能则不clone。\n\n    this._timelineOptions = map(optionBackup.timelineOptions, clone);\n    this._mediaList = map(optionBackup.mediaList, clone);\n    this._mediaDefault = clone(optionBackup.mediaDefault);\n    this._currentMediaIndices = [];\n    return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`\n    // called, and is merged into every new option by inner method `mergeOption`\n    // each time `setOption` called, can be only used in `isRecreate`, because\n    // its reliability is under suspicion. In other cases option merge is\n    // performed by `model.mergeOption`.\n    ? optionBackup.baseOption : this._newBaseOption);\n  },\n\n  /**\n   * @param {module:echarts/model/Global} ecModel\n   * @return {Object}\n   */\n  getTimelineOption: function (ecModel) {\n    var option;\n    var timelineOptions = this._timelineOptions;\n\n    if (timelineOptions.length) {\n      // getTimelineOption can only be called after ecModel inited,\n      // so we can get currentIndex from timelineModel.\n      var timelineModel = ecModel.getComponent('timeline');\n\n      if (timelineModel) {\n        option = clone(timelineOptions[timelineModel.getCurrentIndex()], true);\n      }\n    }\n\n    return option;\n  },\n\n  /**\n   * @param {module:echarts/model/Global} ecModel\n   * @return {Array.<Object>}\n   */\n  getMediaOption: function (ecModel) {\n    var ecWidth = this._api.getWidth();\n\n    var ecHeight = this._api.getHeight();\n\n    var mediaList = this._mediaList;\n    var mediaDefault = this._mediaDefault;\n    var indices = [];\n    var result = []; // No media defined.\n\n    if (!mediaList.length && !mediaDefault) {\n      return result;\n    } // Multi media may be applied, the latter defined media has higher priority.\n\n\n    for (var i = 0, len = mediaList.length; i < len; i++) {\n      if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {\n        indices.push(i);\n      }\n    } // FIXME\n    // 是否mediaDefault应该强制用户设置，否则可能修改不能回归。\n\n\n    if (!indices.length && mediaDefault) {\n      indices = [-1];\n    }\n\n    if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {\n      result = map(indices, function (index) {\n        return clone(index === -1 ? mediaDefault.option : mediaList[index].option);\n      });\n    } // Otherwise return nothing.\n\n\n    this._currentMediaIndices = indices;\n    return result;\n  }\n};\n\nfunction parseRawOption(rawOption, optionPreprocessorFuncs, isNew) {\n  var timelineOptions = [];\n  var mediaList = [];\n  var mediaDefault;\n  var baseOption; // Compatible with ec2.\n\n  var timelineOpt = rawOption.timeline;\n\n  if (rawOption.baseOption) {\n    baseOption = rawOption.baseOption;\n  } // For timeline\n\n\n  if (timelineOpt || rawOption.options) {\n    baseOption = baseOption || {};\n    timelineOptions = (rawOption.options || []).slice();\n  } // For media query\n\n\n  if (rawOption.media) {\n    baseOption = baseOption || {};\n    var media = rawOption.media;\n    each(media, function (singleMedia) {\n      if (singleMedia && singleMedia.option) {\n        if (singleMedia.query) {\n          mediaList.push(singleMedia);\n        } else if (!mediaDefault) {\n          // Use the first media default.\n          mediaDefault = singleMedia;\n        }\n      }\n    });\n  } // For normal option\n\n\n  if (!baseOption) {\n    baseOption = rawOption;\n  } // Set timelineOpt to baseOption in ec3,\n  // which is convenient for merge option.\n\n\n  if (!baseOption.timeline) {\n    baseOption.timeline = timelineOpt;\n  } // Preprocess.\n\n\n  each([baseOption].concat(timelineOptions).concat(zrUtil.map(mediaList, function (media) {\n    return media.option;\n  })), function (option) {\n    each(optionPreprocessorFuncs, function (preProcess) {\n      preProcess(option, isNew);\n    });\n  });\n  return {\n    baseOption: baseOption,\n    timelineOptions: timelineOptions,\n    mediaDefault: mediaDefault,\n    mediaList: mediaList\n  };\n}\n/**\n * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>\n * Support: width, height, aspectRatio\n * Can use max or min as prefix.\n */\n\n\nfunction applyMediaQuery(query, ecWidth, ecHeight) {\n  var realMap = {\n    width: ecWidth,\n    height: ecHeight,\n    aspectratio: ecWidth / ecHeight // lowser case for convenientce.\n\n  };\n  var applicatable = true;\n  zrUtil.each(query, function (value, attr) {\n    var matched = attr.match(QUERY_REG);\n\n    if (!matched || !matched[1] || !matched[2]) {\n      return;\n    }\n\n    var operator = matched[1];\n    var realAttr = matched[2].toLowerCase();\n\n    if (!compare(realMap[realAttr], value, operator)) {\n      applicatable = false;\n    }\n  });\n  return applicatable;\n}\n\nfunction compare(real, expect, operator) {\n  if (operator === 'min') {\n    return real >= expect;\n  } else if (operator === 'max') {\n    return real <= expect;\n  } else {\n    // Equals\n    return real === expect;\n  }\n}\n\nfunction indicesEquals(indices1, indices2) {\n  // indices is always order by asc and has only finite number.\n  return indices1.join(',') === indices2.join(',');\n}\n/**\n * Consider case:\n * `chart.setOption(opt1);`\n * Then user do some interaction like dataZoom, dataView changing.\n * `chart.setOption(opt2);`\n * Then user press 'reset button' in toolbox.\n *\n * After doing that all of the interaction effects should be reset, the\n * chart should be the same as the result of invoke\n * `chart.setOption(opt1); chart.setOption(opt2);`.\n *\n * Although it is not able ensure that\n * `chart.setOption(opt1); chart.setOption(opt2);` is equivalents to\n * `chart.setOption(merge(opt1, opt2));` exactly,\n * this might be the only simple way to implement that feature.\n *\n * MEMO: We've considered some other approaches:\n * 1. Each model handle its self restoration but not uniform treatment.\n *     (Too complex in logic and error-prone)\n * 2. Use a shadow ecModel. (Performace expensive)\n */\n\n\nfunction mergeOption(oldOption, newOption) {\n  newOption = newOption || {};\n  each(newOption, function (newCptOpt, mainType) {\n    if (newCptOpt == null) {\n      return;\n    }\n\n    var oldCptOpt = oldOption[mainType];\n\n    if (!ComponentModel.hasClass(mainType)) {\n      oldOption[mainType] = merge(oldCptOpt, newCptOpt, true);\n    } else {\n      newCptOpt = modelUtil.normalizeToArray(newCptOpt);\n      oldCptOpt = modelUtil.normalizeToArray(oldCptOpt);\n      var mapResult = modelUtil.mappingToExists(oldCptOpt, newCptOpt);\n      oldOption[mainType] = map(mapResult, function (item) {\n        return item.option && item.exist ? merge(item.exist, item.option, true) : item.exist || item.option;\n      });\n    }\n  });\n}\n\nvar _default = OptionManager;\nmodule.exports = _default;"],"mappings":"AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,uBAAD,CAApB;;AAEA,IAAIC,SAAS,GAAGD,OAAO,CAAC,eAAD,CAAvB;;AAEA,IAAIE,cAAc,GAAGF,OAAO,CAAC,aAAD,CAA5B;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AACA,IAAIG,IAAI,GAAGJ,MAAM,CAACI,IAAlB;AACA,IAAIC,KAAK,GAAGL,MAAM,CAACK,KAAnB;AACA,IAAIC,GAAG,GAAGN,MAAM,CAACM,GAAjB;AACA,IAAIC,KAAK,GAAGP,MAAM,CAACO,KAAnB;AACA,IAAIC,SAAS,GAAG,kBAAhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,aAAT,CAAuBC,GAAvB,EAA4B;EAC1B;AACF;AACA;AACA;EACE,KAAKC,IAAL,GAAYD,GAAZ;EACA;AACF;AACA;AACA;;EAEE,KAAKE,gBAAL,GAAwB,EAAxB;EACA;AACF;AACA;AACA;;EAEE,KAAKC,UAAL,GAAkB,EAAlB;EACA;AACF;AACA;AACA;;EAEE,KAAKC,aAAL;EACA;AACF;AACA;AACA;AACA;AACA;;EAEE,KAAKC,oBAAL,GAA4B,EAA5B;EACA;AACF;AACA;AACA;;EAEE,KAAKC,aAAL;EACA;AACF;AACA;AACA;;EAEE,KAAKC,cAAL;AACD,C,CAAC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;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"},"metadata":{},"sourceType":"script"}