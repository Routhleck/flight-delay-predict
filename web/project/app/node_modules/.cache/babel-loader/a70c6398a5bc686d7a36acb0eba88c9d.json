{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar zrColor = require(\"zrender/lib/tool/color\");\n\nvar _number = require(\"../util/number\");\n\nvar linearMap = _number.linearMap;\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n/**\n * @param {Object} option\n * @param {string} [option.type] See visualHandlers.\n * @param {string} [option.mappingMethod] 'linear' or 'piecewise' or 'category' or 'fixed'\n * @param {Array.<number>=} [option.dataExtent] [minExtent, maxExtent],\n *                                              required when mappingMethod is 'linear'\n * @param {Array.<Object>=} [option.pieceList] [\n *                                             {value: someValue},\n *                                             {interval: [min1, max1], visual: {...}},\n *                                             {interval: [min2, max2]}\n *                                             ],\n *                                            required when mappingMethod is 'piecewise'.\n *                                            Visual for only each piece can be specified.\n * @param {Array.<string|Object>=} [option.categories] ['cate1', 'cate2']\n *                                            required when mappingMethod is 'category'.\n *                                            If no option.categories, categories is set\n *                                            as [0, 1, 2, ...].\n * @param {boolean} [option.loop=false] Whether loop mapping when mappingMethod is 'category'.\n * @param {(Array|Object|*)} [option.visual]  Visual data.\n *                                            when mappingMethod is 'category',\n *                                            visual data can be array or object\n *                                            (like: {cate1: '#222', none: '#fff'})\n *                                            or primary types (which represents\n *                                            default category visual), otherwise visual\n *                                            can be array or primary (which will be\n *                                            normalized to array).\n *\n */\n\nvar VisualMapping = function (option) {\n  var mappingMethod = option.mappingMethod;\n  var visualType = option.type;\n  /**\n   * @readOnly\n   * @type {Object}\n   */\n\n  var thisOption = this.option = zrUtil.clone(option);\n  /**\n   * @readOnly\n   * @type {string}\n   */\n\n  this.type = visualType;\n  /**\n   * @readOnly\n   * @type {string}\n   */\n\n  this.mappingMethod = mappingMethod;\n  /**\n   * @private\n   * @type {Function}\n   */\n\n  this._normalizeData = normalizers[mappingMethod];\n  var visualHandler = visualHandlers[visualType];\n  /**\n   * @public\n   * @type {Function}\n   */\n\n  this.applyVisual = visualHandler.applyVisual;\n  /**\n   * @public\n   * @type {Function}\n   */\n\n  this.getColorMapper = visualHandler.getColorMapper;\n  /**\n   * @private\n   * @type {Function}\n   */\n\n  this._doMap = visualHandler._doMap[mappingMethod];\n\n  if (mappingMethod === 'piecewise') {\n    normalizeVisualRange(thisOption);\n    preprocessForPiecewise(thisOption);\n  } else if (mappingMethod === 'category') {\n    thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n    // which need no more preprocess except normalize visual.\n    : normalizeVisualRange(thisOption, true);\n  } else {\n    // mappingMethod === 'linear' or 'fixed'\n    zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n    normalizeVisualRange(thisOption);\n  }\n};\n\nVisualMapping.prototype = {\n  constructor: VisualMapping,\n  mapValueToVisual: function (value) {\n    var normalized = this._normalizeData(value);\n\n    return this._doMap(normalized, value);\n  },\n  getNormalizer: function () {\n    return zrUtil.bind(this._normalizeData, this);\n  }\n};\nvar visualHandlers = VisualMapping.visualHandlers = {\n  color: {\n    applyVisual: makeApplyVisual('color'),\n\n    /**\n     * Create a mapper function\n     * @return {Function}\n     */\n    getColorMapper: function () {\n      var thisOption = this.option;\n      return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n        !isNormalized && (value = this._normalizeData(value));\n        return doMapCategory.call(this, value);\n      } : function (value, isNormalized, out) {\n        // If output rgb array\n        // which will be much faster and useful in pixel manipulation\n        var returnRGBArray = !!out;\n        !isNormalized && (value = this._normalizeData(value));\n        out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n        return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n      }, this);\n    },\n    _doMap: {\n      linear: function (normalized) {\n        return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n      },\n      category: doMapCategory,\n      piecewise: function (normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n\n        if (result == null) {\n          result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        }\n\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  colorHue: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, value);\n  }),\n  colorSaturation: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, value);\n  }),\n  colorLightness: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, null, value);\n  }),\n  colorAlpha: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyAlpha(color, value);\n  }),\n  opacity: {\n    applyVisual: makeApplyVisual('opacity'),\n    _doMap: makeDoMap([0, 1])\n  },\n  liftZ: {\n    applyVisual: makeApplyVisual('liftZ'),\n    _doMap: {\n      linear: doMapFixed,\n      category: doMapFixed,\n      piecewise: doMapFixed,\n      fixed: doMapFixed\n    }\n  },\n  symbol: {\n    applyVisual: function (value, getter, setter) {\n      var symbolCfg = this.mapValueToVisual(value);\n\n      if (zrUtil.isString(symbolCfg)) {\n        setter('symbol', symbolCfg);\n      } else if (isObject(symbolCfg)) {\n        for (var name in symbolCfg) {\n          if (symbolCfg.hasOwnProperty(name)) {\n            setter(name, symbolCfg[name]);\n          }\n        }\n      }\n    },\n    _doMap: {\n      linear: doMapToArray,\n      category: doMapCategory,\n      piecewise: function (normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n\n        if (result == null) {\n          result = doMapToArray.call(this, normalized);\n        }\n\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  symbolSize: {\n    applyVisual: makeApplyVisual('symbolSize'),\n    _doMap: makeDoMap([0, 1])\n  }\n};\n\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var visual = thisOption.visual;\n  var categoryMap = thisOption.categoryMap = {};\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr = [];\n\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n\n    visual = setVisualToOption(thisOption, visualArr);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n\n  setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function (value, getter, setter) {\n      value = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), value));\n    },\n    _doMap: makeDoMap([0, 1])\n  };\n}\n\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};\n}\n\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\n\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\n\nfunction doMapFixed() {\n  return this.option.visual[0];\n}\n\nfunction makeDoMap(sourceExtent) {\n  return {\n    linear: function (normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function (normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\n\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      return zrColor.parse(item);\n    });\n  }\n\n  return visualArr;\n}\n/**\n * Normalizers by mapping methods.\n */\n\n\nvar normalizers = {\n  linear: function (value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function (value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function (value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n/**\n * List available visual types.\n *\n * @public\n * @return {Array.<string>}\n */\n\nVisualMapping.listVisualTypes = function () {\n  var visualTypes = [];\n  zrUtil.each(visualHandlers, function (handler, key) {\n    visualTypes.push(key);\n  });\n  return visualTypes;\n};\n/**\n * @public\n */\n\n\nVisualMapping.addVisualHandler = function (name, handler) {\n  visualHandlers[name] = handler;\n};\n/**\n * @public\n */\n\n\nVisualMapping.isValidType = function (visualType) {\n  return visualHandlers.hasOwnProperty(visualType);\n};\n/**\n * Convinent method.\n * Visual can be Object or Array or primary type.\n *\n * @public\n */\n\n\nVisualMapping.eachVisual = function (visual, callback, context) {\n  if (zrUtil.isObject(visual)) {\n    zrUtil.each(visual, callback, context);\n  } else {\n    callback.call(context, visual);\n  }\n};\n\nVisualMapping.mapVisual = function (visual, callback, context) {\n  var isPrimary;\n  var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n  VisualMapping.eachVisual(visual, function (v, key) {\n    var newVal = callback.call(context, v, key);\n    isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n  });\n  return newVisual;\n};\n/**\n * @public\n * @param {Object} obj\n * @return {Object} new object containers visual values.\n *                 If no visuals, return null.\n */\n\n\nVisualMapping.retrieveVisuals = function (obj) {\n  var ret = {};\n  var hasVisual;\n  obj && each(visualHandlers, function (h, visualType) {\n    if (obj.hasOwnProperty(visualType)) {\n      ret[visualType] = obj[visualType];\n      hasVisual = true;\n    }\n  });\n  return hasVisual ? ret : null;\n};\n/**\n * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\n *\n * @public\n * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\n *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\n * @return {Array.<string>} Sorted visual types.\n */\n\n\nVisualMapping.prepareVisualTypes = function (visualTypes) {\n  if (isObject(visualTypes)) {\n    var types = [];\n    each(visualTypes, function (item, type) {\n      types.push(type);\n    });\n    visualTypes = types;\n  } else if (zrUtil.isArray(visualTypes)) {\n    visualTypes = visualTypes.slice();\n  } else {\n    return [];\n  }\n\n  visualTypes.sort(function (type1, type2) {\n    // color should be front of colorSaturation, colorAlpha, ...\n    // symbol and symbolSize do not matter.\n    return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n  });\n  return visualTypes;\n};\n/**\n * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\n * Other visuals are only depends on themself.\n *\n * @public\n * @param {string} visualType1\n * @param {string} visualType2\n * @return {boolean}\n */\n\n\nVisualMapping.dependsOn = function (visualType1, visualType2) {\n  return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n};\n/**\n * @param {number} value\n * @param {Array.<Object>} pieceList [{value: ..., interval: [min, max]}, ...]\n *                         Always from small to big.\n * @param {boolean} [findClosestWhenOutside=false]\n * @return {number} index\n */\n\n\nVisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n  var possibleI;\n  var abs = Infinity; // value has the higher priority.\n\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var pieceValue = pieceList[i].value;\n\n    if (pieceValue != null) {\n      if (pieceValue === value // FIXME\n      // It is supposed to compare value according to value type of dimension,\n      // but currently value type can exactly be string or number.\n      // Compromise for numeric-like string (like '12'), especially\n      // in the case that visualMap.categories is ['22', '33'].\n      || typeof pieceValue === 'string' && pieceValue === value + '') {\n        return i;\n      }\n\n      findClosestWhenOutside && updatePossible(pieceValue, i);\n    }\n  }\n\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var piece = pieceList[i];\n    var interval = piece.interval;\n    var close = piece.close;\n\n    if (interval) {\n      if (interval[0] === -Infinity) {\n        if (littleThan(close[1], value, interval[1])) {\n          return i;\n        }\n      } else if (interval[1] === Infinity) {\n        if (littleThan(close[0], interval[0], value)) {\n          return i;\n        }\n      } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {\n        return i;\n      }\n\n      findClosestWhenOutside && updatePossible(interval[0], i);\n      findClosestWhenOutside && updatePossible(interval[1], i);\n    }\n  }\n\n  if (findClosestWhenOutside) {\n    return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n  }\n\n  function updatePossible(val, index) {\n    var newAbs = Math.abs(val - value);\n\n    if (newAbs < abs) {\n      abs = newAbs;\n      possibleI = index;\n    }\n  }\n};\n\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\n\nvar _default = VisualMapping;\nmodule.exports = _default;","map":{"version":3,"names":["zrUtil","require","zrColor","_number","linearMap","each","isObject","CATEGORY_DEFAULT_VISUAL_INDEX","VisualMapping","option","mappingMethod","visualType","type","thisOption","clone","_normalizeData","normalizers","visualHandler","visualHandlers","applyVisual","getColorMapper","_doMap","normalizeVisualRange","preprocessForPiecewise","categories","preprocessForSpecifiedCategory","assert","dataExtent","prototype","constructor","mapValueToVisual","value","normalized","getNormalizer","bind","color","makeApplyVisual","isNormalized","doMapCategory","call","out","returnRGBArray","fastLerp","parsedVisual","stringify","linear","category","piecewise","result","getSpecifiedVisual","fixed","doMapFixed","colorHue","makePartialColorVisualHandler","modifyHSL","colorSaturation","colorLightness","colorAlpha","modifyAlpha","opacity","makeDoMap","liftZ","symbol","getter","setter","symbolCfg","isString","name","hasOwnProperty","doMapToArray","symbolSize","pieceList","hasSpecialVisual","piece","index","originIndex","visual","categoryMap","cate","isArray","visualArr","v","setVisualToOption","i","length","pop","isCategory","push","doNotNeedPair","applyValue","Math","round","loop","sourceExtent","pieceIndex","findPieceIndex","map","item","parse","noop","listVisualTypes","visualTypes","handler","key","addVisualHandler","isValidType","eachVisual","callback","context","mapVisual","isPrimary","newVisual","newVal","retrieveVisuals","obj","ret","hasVisual","h","prepareVisualTypes","types","slice","sort","type1","type2","indexOf","dependsOn","visualType1","visualType2","findClosestWhenOutside","possibleI","abs","Infinity","len","pieceValue","updatePossible","interval","close","littleThan","val","newAbs","a","b","_default","module","exports"],"sources":["F:/Wechatfile/WeChat Files/wxid_cre715h75uat22/FileStorage/MsgAttach/843d799c0bb5fd5ab828b2371b6d88b0/File/2022-07/project/project/app/node_modules/echarts/lib/visual/VisualMapping.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar zrColor = require(\"zrender/lib/tool/color\");\n\nvar _number = require(\"../util/number\");\n\nvar linearMap = _number.linearMap;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar each = zrUtil.each;\nvar isObject = zrUtil.isObject;\nvar CATEGORY_DEFAULT_VISUAL_INDEX = -1;\n/**\n * @param {Object} option\n * @param {string} [option.type] See visualHandlers.\n * @param {string} [option.mappingMethod] 'linear' or 'piecewise' or 'category' or 'fixed'\n * @param {Array.<number>=} [option.dataExtent] [minExtent, maxExtent],\n *                                              required when mappingMethod is 'linear'\n * @param {Array.<Object>=} [option.pieceList] [\n *                                             {value: someValue},\n *                                             {interval: [min1, max1], visual: {...}},\n *                                             {interval: [min2, max2]}\n *                                             ],\n *                                            required when mappingMethod is 'piecewise'.\n *                                            Visual for only each piece can be specified.\n * @param {Array.<string|Object>=} [option.categories] ['cate1', 'cate2']\n *                                            required when mappingMethod is 'category'.\n *                                            If no option.categories, categories is set\n *                                            as [0, 1, 2, ...].\n * @param {boolean} [option.loop=false] Whether loop mapping when mappingMethod is 'category'.\n * @param {(Array|Object|*)} [option.visual]  Visual data.\n *                                            when mappingMethod is 'category',\n *                                            visual data can be array or object\n *                                            (like: {cate1: '#222', none: '#fff'})\n *                                            or primary types (which represents\n *                                            default category visual), otherwise visual\n *                                            can be array or primary (which will be\n *                                            normalized to array).\n *\n */\n\nvar VisualMapping = function (option) {\n  var mappingMethod = option.mappingMethod;\n  var visualType = option.type;\n  /**\n   * @readOnly\n   * @type {Object}\n   */\n\n  var thisOption = this.option = zrUtil.clone(option);\n  /**\n   * @readOnly\n   * @type {string}\n   */\n\n  this.type = visualType;\n  /**\n   * @readOnly\n   * @type {string}\n   */\n\n  this.mappingMethod = mappingMethod;\n  /**\n   * @private\n   * @type {Function}\n   */\n\n  this._normalizeData = normalizers[mappingMethod];\n  var visualHandler = visualHandlers[visualType];\n  /**\n   * @public\n   * @type {Function}\n   */\n\n  this.applyVisual = visualHandler.applyVisual;\n  /**\n   * @public\n   * @type {Function}\n   */\n\n  this.getColorMapper = visualHandler.getColorMapper;\n  /**\n   * @private\n   * @type {Function}\n   */\n\n  this._doMap = visualHandler._doMap[mappingMethod];\n\n  if (mappingMethod === 'piecewise') {\n    normalizeVisualRange(thisOption);\n    preprocessForPiecewise(thisOption);\n  } else if (mappingMethod === 'category') {\n    thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,\n    // which need no more preprocess except normalize visual.\n    : normalizeVisualRange(thisOption, true);\n  } else {\n    // mappingMethod === 'linear' or 'fixed'\n    zrUtil.assert(mappingMethod !== 'linear' || thisOption.dataExtent);\n    normalizeVisualRange(thisOption);\n  }\n};\n\nVisualMapping.prototype = {\n  constructor: VisualMapping,\n  mapValueToVisual: function (value) {\n    var normalized = this._normalizeData(value);\n\n    return this._doMap(normalized, value);\n  },\n  getNormalizer: function () {\n    return zrUtil.bind(this._normalizeData, this);\n  }\n};\nvar visualHandlers = VisualMapping.visualHandlers = {\n  color: {\n    applyVisual: makeApplyVisual('color'),\n\n    /**\n     * Create a mapper function\n     * @return {Function}\n     */\n    getColorMapper: function () {\n      var thisOption = this.option;\n      return zrUtil.bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {\n        !isNormalized && (value = this._normalizeData(value));\n        return doMapCategory.call(this, value);\n      } : function (value, isNormalized, out) {\n        // If output rgb array\n        // which will be much faster and useful in pixel manipulation\n        var returnRGBArray = !!out;\n        !isNormalized && (value = this._normalizeData(value));\n        out = zrColor.fastLerp(value, thisOption.parsedVisual, out);\n        return returnRGBArray ? out : zrColor.stringify(out, 'rgba');\n      }, this);\n    },\n    _doMap: {\n      linear: function (normalized) {\n        return zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n      },\n      category: doMapCategory,\n      piecewise: function (normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n\n        if (result == null) {\n          result = zrColor.stringify(zrColor.fastLerp(normalized, this.option.parsedVisual), 'rgba');\n        }\n\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  colorHue: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, value);\n  }),\n  colorSaturation: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, value);\n  }),\n  colorLightness: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyHSL(color, null, null, value);\n  }),\n  colorAlpha: makePartialColorVisualHandler(function (color, value) {\n    return zrColor.modifyAlpha(color, value);\n  }),\n  opacity: {\n    applyVisual: makeApplyVisual('opacity'),\n    _doMap: makeDoMap([0, 1])\n  },\n  liftZ: {\n    applyVisual: makeApplyVisual('liftZ'),\n    _doMap: {\n      linear: doMapFixed,\n      category: doMapFixed,\n      piecewise: doMapFixed,\n      fixed: doMapFixed\n    }\n  },\n  symbol: {\n    applyVisual: function (value, getter, setter) {\n      var symbolCfg = this.mapValueToVisual(value);\n\n      if (zrUtil.isString(symbolCfg)) {\n        setter('symbol', symbolCfg);\n      } else if (isObject(symbolCfg)) {\n        for (var name in symbolCfg) {\n          if (symbolCfg.hasOwnProperty(name)) {\n            setter(name, symbolCfg[name]);\n          }\n        }\n      }\n    },\n    _doMap: {\n      linear: doMapToArray,\n      category: doMapCategory,\n      piecewise: function (normalized, value) {\n        var result = getSpecifiedVisual.call(this, value);\n\n        if (result == null) {\n          result = doMapToArray.call(this, normalized);\n        }\n\n        return result;\n      },\n      fixed: doMapFixed\n    }\n  },\n  symbolSize: {\n    applyVisual: makeApplyVisual('symbolSize'),\n    _doMap: makeDoMap([0, 1])\n  }\n};\n\nfunction preprocessForPiecewise(thisOption) {\n  var pieceList = thisOption.pieceList;\n  thisOption.hasSpecialVisual = false;\n  zrUtil.each(pieceList, function (piece, index) {\n    piece.originIndex = index; // piece.visual is \"result visual value\" but not\n    // a visual range, so it does not need to be normalized.\n\n    if (piece.visual != null) {\n      thisOption.hasSpecialVisual = true;\n    }\n  });\n}\n\nfunction preprocessForSpecifiedCategory(thisOption) {\n  // Hash categories.\n  var categories = thisOption.categories;\n  var visual = thisOption.visual;\n  var categoryMap = thisOption.categoryMap = {};\n  each(categories, function (cate, index) {\n    categoryMap[cate] = index;\n  }); // Process visual map input.\n\n  if (!zrUtil.isArray(visual)) {\n    var visualArr = [];\n\n    if (zrUtil.isObject(visual)) {\n      each(visual, function (v, cate) {\n        var index = categoryMap[cate];\n        visualArr[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v;\n      });\n    } else {\n      // Is primary type, represents default visual.\n      visualArr[CATEGORY_DEFAULT_VISUAL_INDEX] = visual;\n    }\n\n    visual = setVisualToOption(thisOption, visualArr);\n  } // Remove categories that has no visual,\n  // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.\n\n\n  for (var i = categories.length - 1; i >= 0; i--) {\n    if (visual[i] == null) {\n      delete categoryMap[categories[i]];\n      categories.pop();\n    }\n  }\n}\n\nfunction normalizeVisualRange(thisOption, isCategory) {\n  var visual = thisOption.visual;\n  var visualArr = [];\n\n  if (zrUtil.isObject(visual)) {\n    each(visual, function (v) {\n      visualArr.push(v);\n    });\n  } else if (visual != null) {\n    visualArr.push(visual);\n  }\n\n  var doNotNeedPair = {\n    color: 1,\n    symbol: 1\n  };\n\n  if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {\n    // Do not care visualArr.length === 0, which is illegal.\n    visualArr[1] = visualArr[0];\n  }\n\n  setVisualToOption(thisOption, visualArr);\n}\n\nfunction makePartialColorVisualHandler(applyValue) {\n  return {\n    applyVisual: function (value, getter, setter) {\n      value = this.mapValueToVisual(value); // Must not be array value\n\n      setter('color', applyValue(getter('color'), value));\n    },\n    _doMap: makeDoMap([0, 1])\n  };\n}\n\nfunction doMapToArray(normalized) {\n  var visual = this.option.visual;\n  return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {};\n}\n\nfunction makeApplyVisual(visualType) {\n  return function (value, getter, setter) {\n    setter(visualType, this.mapValueToVisual(value));\n  };\n}\n\nfunction doMapCategory(normalized) {\n  var visual = this.option.visual;\n  return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized];\n}\n\nfunction doMapFixed() {\n  return this.option.visual[0];\n}\n\nfunction makeDoMap(sourceExtent) {\n  return {\n    linear: function (normalized) {\n      return linearMap(normalized, sourceExtent, this.option.visual, true);\n    },\n    category: doMapCategory,\n    piecewise: function (normalized, value) {\n      var result = getSpecifiedVisual.call(this, value);\n\n      if (result == null) {\n        result = linearMap(normalized, sourceExtent, this.option.visual, true);\n      }\n\n      return result;\n    },\n    fixed: doMapFixed\n  };\n}\n\nfunction getSpecifiedVisual(value) {\n  var thisOption = this.option;\n  var pieceList = thisOption.pieceList;\n\n  if (thisOption.hasSpecialVisual) {\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList);\n    var piece = pieceList[pieceIndex];\n\n    if (piece && piece.visual) {\n      return piece.visual[this.type];\n    }\n  }\n}\n\nfunction setVisualToOption(thisOption, visualArr) {\n  thisOption.visual = visualArr;\n\n  if (thisOption.type === 'color') {\n    thisOption.parsedVisual = zrUtil.map(visualArr, function (item) {\n      return zrColor.parse(item);\n    });\n  }\n\n  return visualArr;\n}\n/**\n * Normalizers by mapping methods.\n */\n\n\nvar normalizers = {\n  linear: function (value) {\n    return linearMap(value, this.option.dataExtent, [0, 1], true);\n  },\n  piecewise: function (value) {\n    var pieceList = this.option.pieceList;\n    var pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true);\n\n    if (pieceIndex != null) {\n      return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true);\n    }\n  },\n  category: function (value) {\n    var index = this.option.categories ? this.option.categoryMap[value] : value; // ordinal\n\n    return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index;\n  },\n  fixed: zrUtil.noop\n};\n/**\n * List available visual types.\n *\n * @public\n * @return {Array.<string>}\n */\n\nVisualMapping.listVisualTypes = function () {\n  var visualTypes = [];\n  zrUtil.each(visualHandlers, function (handler, key) {\n    visualTypes.push(key);\n  });\n  return visualTypes;\n};\n/**\n * @public\n */\n\n\nVisualMapping.addVisualHandler = function (name, handler) {\n  visualHandlers[name] = handler;\n};\n/**\n * @public\n */\n\n\nVisualMapping.isValidType = function (visualType) {\n  return visualHandlers.hasOwnProperty(visualType);\n};\n/**\n * Convinent method.\n * Visual can be Object or Array or primary type.\n *\n * @public\n */\n\n\nVisualMapping.eachVisual = function (visual, callback, context) {\n  if (zrUtil.isObject(visual)) {\n    zrUtil.each(visual, callback, context);\n  } else {\n    callback.call(context, visual);\n  }\n};\n\nVisualMapping.mapVisual = function (visual, callback, context) {\n  var isPrimary;\n  var newVisual = zrUtil.isArray(visual) ? [] : zrUtil.isObject(visual) ? {} : (isPrimary = true, null);\n  VisualMapping.eachVisual(visual, function (v, key) {\n    var newVal = callback.call(context, v, key);\n    isPrimary ? newVisual = newVal : newVisual[key] = newVal;\n  });\n  return newVisual;\n};\n/**\n * @public\n * @param {Object} obj\n * @return {Object} new object containers visual values.\n *                 If no visuals, return null.\n */\n\n\nVisualMapping.retrieveVisuals = function (obj) {\n  var ret = {};\n  var hasVisual;\n  obj && each(visualHandlers, function (h, visualType) {\n    if (obj.hasOwnProperty(visualType)) {\n      ret[visualType] = obj[visualType];\n      hasVisual = true;\n    }\n  });\n  return hasVisual ? ret : null;\n};\n/**\n * Give order to visual types, considering colorSaturation, colorAlpha depends on color.\n *\n * @public\n * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}\n *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']\n * @return {Array.<string>} Sorted visual types.\n */\n\n\nVisualMapping.prepareVisualTypes = function (visualTypes) {\n  if (isObject(visualTypes)) {\n    var types = [];\n    each(visualTypes, function (item, type) {\n      types.push(type);\n    });\n    visualTypes = types;\n  } else if (zrUtil.isArray(visualTypes)) {\n    visualTypes = visualTypes.slice();\n  } else {\n    return [];\n  }\n\n  visualTypes.sort(function (type1, type2) {\n    // color should be front of colorSaturation, colorAlpha, ...\n    // symbol and symbolSize do not matter.\n    return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1;\n  });\n  return visualTypes;\n};\n/**\n * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.\n * Other visuals are only depends on themself.\n *\n * @public\n * @param {string} visualType1\n * @param {string} visualType2\n * @return {boolean}\n */\n\n\nVisualMapping.dependsOn = function (visualType1, visualType2) {\n  return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2;\n};\n/**\n * @param {number} value\n * @param {Array.<Object>} pieceList [{value: ..., interval: [min, max]}, ...]\n *                         Always from small to big.\n * @param {boolean} [findClosestWhenOutside=false]\n * @return {number} index\n */\n\n\nVisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {\n  var possibleI;\n  var abs = Infinity; // value has the higher priority.\n\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var pieceValue = pieceList[i].value;\n\n    if (pieceValue != null) {\n      if (pieceValue === value // FIXME\n      // It is supposed to compare value according to value type of dimension,\n      // but currently value type can exactly be string or number.\n      // Compromise for numeric-like string (like '12'), especially\n      // in the case that visualMap.categories is ['22', '33'].\n      || typeof pieceValue === 'string' && pieceValue === value + '') {\n        return i;\n      }\n\n      findClosestWhenOutside && updatePossible(pieceValue, i);\n    }\n  }\n\n  for (var i = 0, len = pieceList.length; i < len; i++) {\n    var piece = pieceList[i];\n    var interval = piece.interval;\n    var close = piece.close;\n\n    if (interval) {\n      if (interval[0] === -Infinity) {\n        if (littleThan(close[1], value, interval[1])) {\n          return i;\n        }\n      } else if (interval[1] === Infinity) {\n        if (littleThan(close[0], interval[0], value)) {\n          return i;\n        }\n      } else if (littleThan(close[0], interval[0], value) && littleThan(close[1], value, interval[1])) {\n        return i;\n      }\n\n      findClosestWhenOutside && updatePossible(interval[0], i);\n      findClosestWhenOutside && updatePossible(interval[1], i);\n    }\n  }\n\n  if (findClosestWhenOutside) {\n    return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI;\n  }\n\n  function updatePossible(val, index) {\n    var newAbs = Math.abs(val - value);\n\n    if (newAbs < abs) {\n      abs = newAbs;\n      possibleI = index;\n    }\n  }\n};\n\nfunction littleThan(close, a, b) {\n  return close ? a <= b : a < b;\n}\n\nvar _default = VisualMapping;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}