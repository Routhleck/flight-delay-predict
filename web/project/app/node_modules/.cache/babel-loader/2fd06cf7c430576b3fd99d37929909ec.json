{"ast":null,"code":"require(\"core-js/modules/es.typed-array.at.js\");\n\nrequire(\"core-js/modules/es.typed-array.set.js\");\n\nrequire(\"core-js/modules/esnext.typed-array.find-last.js\");\n\nrequire(\"core-js/modules/esnext.typed-array.find-last-index.js\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar DataDiffer = require(\"./DataDiffer\");\n\nvar Source = require(\"./Source\");\n\nvar _dataProvider = require(\"./helper/dataProvider\");\n\nvar defaultDimValueGetters = _dataProvider.defaultDimValueGetters;\nvar DefaultDataProvider = _dataProvider.DefaultDataProvider;\n\nvar _dimensionHelper = require(\"./helper/dimensionHelper\");\n\nvar summarizeDimensions = _dimensionHelper.summarizeDimensions;\n\nvar DataDimensionInfo = require(\"./DataDimensionInfo\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\n\n\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\n\nfunction getIndicesCtor(list) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\n\nfunction transferProperties(target, source) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n    if (source.hasOwnProperty(propName)) {\n      target[propName] = source[propName];\n    }\n  });\n  target.__wrappedMethods = source.__wrappedMethods;\n  zrUtil.each(CLONE_PROPERTIES, function (propName) {\n    target[propName] = zrUtil.clone(source[propName]);\n  });\n  target._calculationInfo = zrUtil.extend(source._calculationInfo);\n}\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object|module:data/DataDimensionInfo>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n  var invertedIndicesMap = {};\n\n  for (var i = 0; i < dimensions.length; i++) {\n    // Use the original dimensions[i], where other flag props may exists.\n    var dimensionInfo = dimensions[i];\n\n    if (zrUtil.isString(dimensionInfo)) {\n      dimensionInfo = new DataDimensionInfo({\n        name: dimensionInfo\n      });\n    } else if (!(dimensionInfo instanceof DataDimensionInfo)) {\n      dimensionInfo = new DataDimensionInfo(dimensionInfo);\n    }\n\n    var dimensionName = dimensionInfo.name;\n    dimensionInfo.type = dimensionInfo.type || 'float';\n\n    if (!dimensionInfo.coordDim) {\n      dimensionInfo.coordDim = dimensionName;\n      dimensionInfo.coordDimIndex = 0;\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n    dimensionInfo.index = i;\n\n    if (dimensionInfo.createInvertedIndices) {\n      invertedIndicesMap[dimensionName] = [];\n    }\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this._indices = null;\n  this._count = 0;\n  this._rawCount = 0;\n  /**\n   * Data storage\n   * @type {Object.<key, Array.<TypedArray|Array>>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Key: visual type, Value: boolean\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.hasItemVisual = {};\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * Max size of each chunk.\n   * @type {number}\n   * @private\n   */\n\n  this._chunkSize = 1e5;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this._chunkCount = 0;\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * Raw extent will not be cloned, but only transfered.\n   * It will not be calculated util needed.\n   * key: dim,\n   * value: {end: number, extent: Array.<number>}\n   * @type {Object}\n   * @private\n   */\n\n  this._rawExtent = {};\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent = {};\n  /**\n   * key: dim\n   * value: extent\n   * @type {Object}\n   * @private\n   */\n\n  this._approximateExtent = {};\n  /**\n   * Cache summary info for fast visit. See \"dimensionHelper\".\n   * @type {Object}\n   * @private\n   */\n\n  this._dimensionsSummary = summarizeDimensions(this);\n  /**\n   * @type {Object.<Array|TypedArray>}\n   * @private\n   */\n\n  this._invertedIndicesMap = invertedIndicesMap;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._calculationInfo = {};\n  /**\n   * User output info of this data.\n   * DO NOT use it in other places!\n   *\n   * When preparing user params for user callbacks, we have\n   * to clone these inner data structures to prevent users\n   * from modifying them to effect built-in logic. And for\n   * performance consideration we make this `userOutput` to\n   * avoid clone them too many times.\n   *\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.userOutput = this._dimensionsSummary.userOutput;\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * The meanings of the input parameter `dim`:\n *\n * + If dim is a number (e.g., `1`), it means the index of the dimension.\n *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n * + If dim is a number-like string (e.g., `\"1\"`):\n *     + If there is the same concrete dim name defined in `this.dimensions`, it means that concrete name.\n *     + If not, it will be converted to a number, which means the index of the dimension.\n *        (why? because of the backward compatbility. We have been tolerating number-like string in\n *        dimension setting, although now it seems that it is not a good idea.)\n *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n *     if no dimension name is defined as `\"1\"`.\n * + If dim is a not-number-like string, it means the concrete dim name.\n *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n *   or customized in `dimensions` property of option like `\"age\"`.\n *\n * Get dimension name\n * @param {string|number} dim See above.\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (typeof dim === 'number' // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n    dim = this.dimensions[dim];\n  }\n\n  return dim;\n};\n/**\n * Get type and calculation info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  // Do not clone, because there may be categories in dimInfo.\n  return this._dimensionInfos[this.getDimension(dim)];\n};\n/**\n * @return {Array.<string>} concrete dimension name list on coord.\n */\n\n\nlistProto.getDimensionsOnCoord = function () {\n  return this._dimensionsSummary.dataDimsOnCoord.slice();\n};\n/**\n * @param {string} coordDim\n * @param {number} [idx] A coordDim may map to more than one data dim.\n *        If idx is `true`, return a array of all mapped dims.\n *        If idx is not specified, return the first dim not extra.\n * @return {string|Array.<string>} concrete data dim.\n *        If idx is number, and not found, return null/undefined.\n *        If idx is `true`, and not found, return empty array (always return array).\n */\n\n\nlistProto.mapDimension = function (coordDim, idx) {\n  var dimensionsSummary = this._dimensionsSummary;\n\n  if (idx == null) {\n    return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n  }\n\n  var dims = dimensionsSummary.encode[coordDim];\n  return idx === true // always return array if idx is `true`\n  ? (dims || []).slice() : dims && dims[idx];\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data source or data or data provider.\n * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and\n *        default label/tooltip.\n *        A name can be specified in encode.itemName,\n *        or dataItem.name (only for series option data),\n *        or provided in nameList from outside.\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);\n\n  if (notProvider) {\n    data = new DefaultDataProvider(data, this.dimensions.length);\n  }\n\n  this._rawData = data; // Clear\n\n  this._storage = {};\n  this._indices = null;\n  this._nameList = nameList || [];\n  this._idList = [];\n  this._nameRepeatCount = {};\n\n  if (!dimValueGetter) {\n    this.hasItemOption = false;\n  }\n  /**\n   * @readOnly\n   */\n\n\n  this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat]; // Default dim value getter\n\n  this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n  this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows; // Reset raw extent.\n\n  this._rawExtent = {};\n\n  this._initDataFromProvider(0, data.count()); // If data has no item option.\n\n\n  if (data.pure) {\n    this.hasItemOption = false;\n  }\n};\n\nlistProto.getProvider = function () {\n  return this._rawData;\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n */\n\n\nlistProto.appendData = function (data) {\n  var rawData = this._rawData;\n  var start = this.count();\n  rawData.appendData(data);\n  var end = rawData.count();\n\n  if (!rawData.persistent) {\n    end += start;\n  }\n\n  this._initDataFromProvider(start, end);\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n * This method does not modify `rawData` (`dataProvider`), but only\n * add values to storage.\n *\n * The final count will be increased by `Math.max(values.length, names.length)`.\n *\n * @param {Array.<Array.<*>>} values That is the SourceType: 'arrayRows', like\n *        [\n *            [12, 33, 44],\n *            [NaN, 43, 1],\n *            ['-', 'asdf', 0]\n *        ]\n *        Each item is exaclty cooresponding to a dimension.\n * @param {Array.<string>} [names]\n */\n\n\nlistProto.appendValues = function (values, names) {\n  var chunkSize = this._chunkSize;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var rawExtent = this._rawExtent;\n  var start = this.count();\n  var end = start + Math.max(values.length, names ? names.length : 0);\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var emptyDataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    var sourceIdx = idx - start;\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n\n      var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);\n\n      storage[dim][chunkIndex][chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    }\n\n    if (names) {\n      this._nameList[idx] = names[sourceIdx];\n    }\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nlistProto._initDataFromProvider = function (start, end) {\n  // Optimize.\n  if (start >= end) {\n    return;\n  }\n\n  var chunkSize = this._chunkSize;\n  var rawData = this._rawData;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var dimensionInfoMap = this._dimensionInfos;\n  var nameList = this._nameList;\n  var idList = this._idList;\n  var rawExtent = this._rawExtent;\n  var nameRepeatCount = this._nameRepeatCount = {};\n  var nameDimIdx;\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    var dimInfo = dimensionInfoMap[dim];\n\n    if (dimInfo.otherDims.itemName === 0) {\n      nameDimIdx = this._nameDimIdx = i;\n    }\n\n    if (dimInfo.otherDims.itemId === 0) {\n      this._idDimIdx = i;\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var dataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    // NOTICE: Try not to write things into dataItem\n    dataItem = rawData.getItem(idx, dataItem); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero\n\n      var val = this._dimValueGetter(dataItem, dim, idx, k);\n\n      dimStorage[chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    } // ??? FIXME not check by pure but sourceFormat?\n    // TODO refactor these logic.\n\n\n    if (!rawData.pure) {\n      var name = nameList[idx];\n\n      if (dataItem && name == null) {\n        // If dataItem is {name: ...}, it has highest priority.\n        // That is appropriate for many common cases.\n        if (dataItem.name != null) {\n          // There is no other place to persistent dataItem.name,\n          // so save it to nameList.\n          nameList[idx] = name = dataItem.name;\n        } else if (nameDimIdx != null) {\n          var nameDim = dimensions[nameDimIdx];\n          var nameDimChunk = storage[nameDim][chunkIndex];\n\n          if (nameDimChunk) {\n            name = nameDimChunk[chunkOffset];\n            var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;\n\n            if (ordinalMeta && ordinalMeta.categories.length) {\n              name = ordinalMeta.categories[name];\n            }\n          }\n        }\n      } // Try using the id in option\n      // id or name is used on dynamical data, mapping old and new items.\n\n\n      var id = dataItem == null ? null : dataItem.id;\n\n      if (id == null && name != null) {\n        // Use name as id and add counter to avoid same name\n        nameRepeatCount[name] = nameRepeatCount[name] || 0;\n        id = name;\n\n        if (nameRepeatCount[name] > 0) {\n          id += '__ec__' + nameRepeatCount[name];\n        }\n\n        nameRepeatCount[name]++;\n      }\n\n      id != null && (idList[idx] = id);\n    }\n  }\n\n  if (!rawData.persistent && rawData.clean) {\n    // Clean unused data if data source is typed array.\n    rawData.clean();\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nfunction prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {\n  var DataCtor = dataCtors[dimInfo.type];\n  var lastChunkIndex = chunkCount - 1;\n  var dim = dimInfo.name;\n  var resizeChunkArray = storage[dim][lastChunkIndex];\n\n  if (resizeChunkArray && resizeChunkArray.length < chunkSize) {\n    var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable\n    // within the initial chunkSize.\n\n    for (var j = 0; j < resizeChunkArray.length; j++) {\n      newStore[j] = resizeChunkArray[j];\n    }\n\n    storage[dim][lastChunkIndex] = newStore;\n  } // Create new chunks.\n\n\n  for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {\n    storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));\n  }\n}\n\nfunction prepareInvertedIndex(list) {\n  var invertedIndicesMap = list._invertedIndicesMap;\n  zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n    var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n    var ordinalMeta = dimInfo.ordinalMeta;\n\n    if (ordinalMeta) {\n      invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n      // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n      for (var i = 0; i < invertedIndices.length; i++) {\n        invertedIndices[i] = INDEX_NOT_FOUND;\n      }\n\n      for (var i = 0; i < list._count; i++) {\n        // Only support the case that all values are distinct.\n        invertedIndices[list.get(dim, i)] = i;\n      }\n    }\n  });\n}\n\nfunction getRawValueFromStore(list, dimIndex, rawIndex) {\n  var val;\n\n  if (dimIndex != null) {\n    var chunkSize = list._chunkSize;\n    var chunkIndex = Math.floor(rawIndex / chunkSize);\n    var chunkOffset = rawIndex % chunkSize;\n    var dim = list.dimensions[dimIndex];\n    var chunk = list._storage[dim][chunkIndex];\n\n    if (chunk) {\n      val = chunk[chunkOffset];\n      var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;\n\n      if (ordinalMeta && ordinalMeta.categories.length) {\n        val = ordinalMeta.categories[val];\n      }\n    }\n  }\n\n  return val;\n}\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this._count;\n};\n\nlistProto.getIndices = function () {\n  var newIndices;\n  var indices = this._indices;\n\n  if (indices) {\n    var Ctor = indices.constructor;\n    var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n    if (Ctor === Array) {\n      newIndices = new Ctor(thisCount);\n\n      for (var i = 0; i < thisCount; i++) {\n        newIndices[i] = indices[i];\n      }\n    } else {\n      newIndices = new Ctor(indices.buffer, 0, thisCount);\n    }\n  } else {\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(this.count());\n\n    for (var i = 0; i < newIndices.length; i++) {\n      newIndices[i] = i;\n    }\n  }\n\n  return newIndices;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx\n/*, stack */\n) {\n  if (!(idx >= 0 && idx < this._count)) {\n    return NaN;\n  }\n\n  var storage = this._storage;\n\n  if (!storage[dim]) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  idx = this.getRawIndex(idx);\n  var chunkIndex = Math.floor(idx / this._chunkSize);\n  var chunkOffset = idx % this._chunkSize;\n  var chunkStore = storage[dim][chunkIndex];\n  var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable\n  // if (stack) {\n  //     var dimensionInfo = this._dimensionInfos[dim];\n  //     if (dimensionInfo && dimensionInfo.stackable) {\n  //         var stackedOn = this.stackedOn;\n  //         while (stackedOn) {\n  //             // Get no stacked data of stacked on\n  //             var stackedValue = stackedOn.get(dim, idx);\n  //             // Considering positive stack, negative stack and empty data\n  //             if ((value >= 0 && stackedValue > 0)  // Positive stack\n  //                 || (value <= 0 && stackedValue < 0) // Negative stack\n  //             ) {\n  //                 value += stackedValue;\n  //             }\n  //             stackedOn = stackedOn.stackedOn;\n  //         }\n  //     }\n  // }\n\n  return value;\n};\n/**\n * @param {string} dim concrete dim\n * @param {number} rawIndex\n * @return {number|string}\n */\n\n\nlistProto.getByRawIndex = function (dim, rawIdx) {\n  if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n    return NaN;\n  }\n\n  var dimStore = this._storage[dim];\n\n  if (!dimStore) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = dimStore[chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).\n * Hack a much simpler _getFast\n * @private\n */\n\n\nlistProto._getFast = function (dim, rawIdx) {\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = this._storage[dim][chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx\n/*, stack */\n) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    // stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx\n    /*, stack */\n    ));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * Only check the coord dimensions.\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n\n  for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n    // Ordinal type originally can be string or number.\n    // But when an ordinal type is used on coord, it can\n    // not be string but only number. So we can also use isNaN.\n    if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getDataExtent = function (dim\n/*, stack */\n) {\n  // Make sure use concrete dim as cache name.\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));\n\n  if (!dimData) {\n    return initialExtent;\n  } // Make more strict checkings to ensure hitting cache.\n\n\n  var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');\n  // var cacheName = dim;\n  // Consider the most cases when using data zoom, `getDataExtent`\n  // happened before filtering. We cache raw extent, which is not\n  // necessary to be cleared and recalculated when restore data.\n\n  var useRaw = !this._indices; // && !stack;\n\n  var dimExtent;\n\n  if (useRaw) {\n    return this._rawExtent[dim].slice();\n  }\n\n  dimExtent = this._extent[dim];\n\n  if (dimExtent) {\n    return dimExtent.slice();\n  }\n\n  dimExtent = initialExtent;\n  var min = dimExtent[0];\n  var max = dimExtent[1];\n\n  for (var i = 0; i < currEnd; i++) {\n    // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));\n    var value = this._getFast(dim, this.getRawIndex(i));\n\n    value < min && (min = value);\n    value > max && (max = value);\n  }\n\n  dimExtent = [min, max];\n  this._extent[dim] = dimExtent;\n  return dimExtent;\n};\n/**\n * Optimize for the scenario that data is filtered by a given extent.\n * Consider that if data amount is more than hundreds of thousand,\n * extent calculation will cost more than 10ms and the cache will\n * be erased because of the filtering.\n */\n\n\nlistProto.getApproximateExtent = function (dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  return this._approximateExtent[dim] || this.getDataExtent(dim\n  /*, stack */\n  );\n};\n\nlistProto.setApproximateExtent = function (extent, dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  this._approximateExtent[dim] = extent.slice();\n};\n/**\n * @param {string} key\n * @return {*}\n */\n\n\nlistProto.getCalculationInfo = function (key) {\n  return this._calculationInfo[key];\n};\n/**\n * @param {string|Object} key or k-v object\n * @param {*} [value]\n */\n\n\nlistProto.setCalculationInfo = function (key, value) {\n  isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getSum = function (dim\n/*, stack */\n) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i\n      /*, stack */\n      );\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Get median of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getMedian = function (dim\n/*, stack */\n) {\n  var dimDataArray = []; // map all data of one dimension\n\n  this.each(dim, function (val, idx) {\n    if (!isNaN(val)) {\n      dimDataArray.push(val);\n    }\n  }); // TODO\n  // Use quick select?\n  // immutability & sort\n\n  var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {\n    return a - b;\n  });\n  var len = this.count(); // calculate median\n\n  return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n}; // /**\n//  * Retreive the index with given value\n//  * @param {string} dim Concrete dimension.\n//  * @param {number} value\n//  * @return {number}\n//  */\n// Currently incorrect: should return dataIndex but not rawIndex.\n// Do not fix it until this method is to be used somewhere.\n// FIXME Precision of float value\n// listProto.indexOf = function (dim, value) {\n//     var storage = this._storage;\n//     var dimData = storage[dim];\n//     var chunkSize = this._chunkSize;\n//     if (dimData) {\n//         for (var i = 0, len = this.count(); i < len; i++) {\n//             var chunkIndex = Math.floor(i / chunkSize);\n//             var chunkOffset = i % chunkSize;\n//             if (dimData[chunkIndex][chunkOffset] === value) {\n//                 return i;\n//             }\n//         }\n//     }\n//     return -1;\n// };\n\n/**\n * Only support the dimension which inverted index created.\n * Do not support other cases until required.\n * @param {string} concrete dim\n * @param {number|string} value\n * @return {number} rawIndex\n */\n\n\nlistProto.rawIndexOf = function (dim, value) {\n  var invertedIndices = dim && this._invertedIndicesMap[dim];\n  var rawIndex = invertedIndices[value];\n\n  if (rawIndex == null || isNaN(rawIndex)) {\n    return INDEX_NOT_FOUND;\n  }\n\n  return rawIndex;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  for (var i = 0, len = this.count(); i < len; i++) {\n    if (this.getName(i) === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  if (rawIndex >= this._rawCount || rawIndex < 0) {\n    return -1;\n  }\n\n  if (!this._indices) {\n    return rawIndex;\n  } // Indices are ascending\n\n\n  var indices = this._indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = this._count - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} If and only if multiple indices has\n *        the same value, they are put to the result.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Infinity;\n  var minDiff = -1;\n  var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/List.js`.\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i);\n    var dist = Math.abs(diff);\n\n    if (dist <= maxDistance) {\n      // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n      // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n      // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n      // So we chose the one that `diff >= 0` in this csae.\n      // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n      // should be push to `nearestIndices`.\n      if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndicesLen = 0;\n      }\n\n      if (diff === minDiff) {\n        nearestIndices[nearestIndicesLen++] = i;\n      }\n    }\n  }\n\n  nearestIndices.length = nearestIndicesLen;\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = getRawIndexWithoutIndices;\n\nfunction getRawIndexWithoutIndices(idx) {\n  return idx;\n}\n\nfunction getRawIndexWithIndices(idx) {\n  if (idx < this._count && idx >= 0) {\n    return this._indices[idx];\n  }\n\n  return -1;\n}\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  if (!this._rawData.persistent) {\n    var val = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      var dim = this.dimensions[i];\n      val.push(this.get(dim, idx));\n    }\n\n    return val;\n  } else {\n    return this._rawData.getItem(this.getRawIndex(idx));\n  }\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  var rawIndex = this.getRawIndex(idx);\n  return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return getId(this, this.getRawIndex(idx));\n};\n\nfunction getId(list, rawIndex) {\n  var id = list._idList[rawIndex];\n\n  if (id == null) {\n    id = getRawValueFromStore(list, list._idDimIdx, rawIndex);\n  }\n\n  if (id == null) {\n    // FIXME Check the usage in graph, should not use prefix.\n    id = ID_PREFIX + rawIndex;\n  }\n\n  return id;\n}\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n\nfunction validateDimensions(list, dims) {\n  for (var i = 0; i < dims.length; i++) {\n    // stroage may be empty when no data, so use\n    // dimensionInfos to check.\n    if (!list._dimensionInfos[dims[i]]) {\n      console.error('Unkown dimension ' + dims[i]);\n    }\n  }\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dims === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dims;\n    dims = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var dimSize = dims.length;\n\n  for (var i = 0; i < this.count(); i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);\n        break;\n\n      default:\n        var k = 0;\n        var value = [];\n\n        for (; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var count = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(count);\n  var value = [];\n  var dimSize = dimensions.length;\n  var offset = 0;\n  var dim0 = dimensions[0];\n\n  for (var i = 0; i < count; i++) {\n    var keep;\n    var rawIdx = this.getRawIndex(i); // Simple optimization\n\n    if (dimSize === 0) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      var val = this._getFast(dim0, rawIdx);\n\n      keep = cb.call(context, val, i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this._getFast(dim0, rawIdx);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices[offset++] = rawIdx;\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < count) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Select data in range. (For optimization of filter)\n * (Manually inline code, support 5 million data filtering in data zoom.)\n */\n\n\nlistProto.selectRange = function (range) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  var dimensions = [];\n\n  for (var dim in range) {\n    if (range.hasOwnProperty(dim)) {\n      dimensions.push(dim);\n    }\n  }\n\n  var dimSize = dimensions.length;\n\n  if (!dimSize) {\n    return;\n  }\n\n  var originalCount = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(originalCount);\n  var offset = 0;\n  var dim0 = dimensions[0];\n  var min = range[dim0][0];\n  var max = range[dim0][1];\n  var quickFinished = false;\n\n  if (!this._indices) {\n    // Extreme optimization for common case. About 2x faster in chrome.\n    var idx = 0;\n\n    if (dimSize === 1) {\n      var dimStorage = this._storage[dimensions[0]];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    } else if (dimSize === 2) {\n      var dimStorage = this._storage[dim0];\n      var dimStorage2 = this._storage[dimensions[1]];\n      var min2 = range[dimensions[1]][0];\n      var max2 = range[dimensions[1]][1];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var chunkStorage2 = dimStorage2[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i];\n          var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    }\n  }\n\n  if (!quickFinished) {\n    if (dimSize === 1) {\n      for (var i = 0; i < originalCount; i++) {\n        var rawIndex = this.getRawIndex(i);\n\n        var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.\n\n\n        if (val >= min && val <= max || isNaN(val)) {\n          newIndices[offset++] = rawIndex;\n        }\n      }\n    } else {\n      for (var i = 0; i < originalCount; i++) {\n        var keep = true;\n        var rawIndex = this.getRawIndex(i);\n\n        for (var k = 0; k < dimSize; k++) {\n          var dimk = dimensions[k];\n\n          var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.\n\n\n          if (val < range[dimk][0] || val > range[dimk][1]) {\n            keep = false;\n          }\n        }\n\n        if (keep) {\n          newIndices[offset++] = this.getRawIndex(i);\n        }\n      }\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < originalCount) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, context);\n  return result;\n}; // Data in excludeDimensions is copied, otherwise transfered.\n\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n\n    if (originalStorage[dim]) {\n      // Notice that we do not reset invertedIndicesMap here, becuase\n      // there is no scenario of mapping or sampling ordinal dimension.\n      if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n        storage[dim] = cloneDimStore(originalStorage[dim]);\n        list._rawExtent[dim] = getInitialExtent();\n        list._extent[dim] = null;\n      } else {\n        // Direct reference for other dimensions\n        storage[dim] = originalStorage[dim];\n      }\n    }\n  }\n\n  return list;\n}\n\nfunction cloneDimStore(originalDimStore) {\n  var newDimStore = new Array(originalDimStore.length);\n\n  for (var j = 0; j < originalDimStore.length; j++) {\n    newDimStore[j] = cloneChunk(originalDimStore[j]);\n  }\n\n  return newDimStore;\n}\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, context, contextCompat) {\n  'use strict'; // contextCompat just for compat echarts3\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  list._indices = this._indices;\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  var chunkSize = this._chunkSize;\n  var dimSize = dimensions.length;\n  var dataCount = this.count();\n  var values = [];\n  var rawExtent = list._rawExtent;\n\n  for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n    for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n      values[dimIndex] = this.get(dimensions[dimIndex], dataIndex\n      /*, stack */\n      );\n    }\n\n    values[dimSize] = dataIndex;\n    var retValue = cb && cb.apply(context, values);\n\n    if (retValue != null) {\n      // a number or string (in oridinal dimension)?\n      if (typeof retValue !== 'object') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      var rawIndex = this.getRawIndex(dataIndex);\n      var chunkIndex = Math.floor(rawIndex / chunkSize);\n      var chunkOffset = rawIndex % chunkSize;\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var val = retValue[i];\n        var rawExtentOnDim = rawExtent[dim];\n        var dimStore = storage[dim];\n\n        if (dimStore) {\n          dimStore[chunkIndex][chunkOffset] = val;\n        }\n\n        if (val < rawExtentOnDim[0]) {\n          rawExtentOnDim[0] = val;\n        }\n\n        if (val > rawExtentOnDim[1]) {\n          rawExtentOnDim[1] = val;\n        }\n      }\n    }\n  }\n\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var targetStorage = list._storage;\n  var frameValues = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count();\n  var chunkSize = this._chunkSize;\n  var rawExtentOnDim = list._rawExtent[dimension];\n  var newIndices = new (getIndicesCtor(this))(len);\n  var offset = 0;\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var dataIdx = this.getRawIndex(i + k);\n      var originalChunkIndex = Math.floor(dataIdx / chunkSize);\n      var originalChunkOffset = dataIdx % chunkSize;\n      frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];\n    }\n\n    var value = sampleValue(frameValues);\n    var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n    var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);\n    var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data\n\n    dimStore[sampleChunkIndex][sampleChunkOffset] = value;\n\n    if (value < rawExtentOnDim[0]) {\n      rawExtentOnDim[0] = value;\n    }\n\n    if (value > rawExtentOnDim[1]) {\n      rawExtentOnDim[1] = value;\n    }\n\n    newIndices[offset++] = sampleFrameIdx;\n  }\n\n  list._count = offset;\n  list._indices = newIndices;\n  list.getRawIndex = getRawIndexWithIndices;\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var thisList = this;\n  return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n    return getId(otherList, idx);\n  }, function (idx) {\n    return getId(thisList, idx);\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  var hasItemVisual = this.hasItemVisual;\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n        hasItemVisual[name] = true;\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n  hasItemVisual[key] = true;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n  this.hasItemVisual = {};\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function (list) {\n  if (!list) {\n    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n    list = new List(dimensionInfoList, this.hostModel);\n  } // FIXME\n\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  if (this._indices) {\n    var Ctor = this._indices.constructor;\n    list._indices = new Ctor(this._indices);\n  } else {\n    list._indices = null;\n  }\n\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\nvar _default = List;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","__DEV__","zrUtil","Model","DataDiffer","Source","_dataProvider","defaultDimValueGetters","DefaultDataProvider","_dimensionHelper","summarizeDimensions","DataDimensionInfo","isObject","UNDEFINED","INDEX_NOT_FOUND","ID_PREFIX","dataCtors","Float64Array","Array","Int32Array","CtorUint32Array","Uint32Array","CtorInt32Array","CtorUint16Array","Uint16Array","getIndicesCtor","list","_rawCount","cloneChunk","originalChunk","Ctor","constructor","slice","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","transferProperties","target","source","each","concat","__wrappedMethods","propName","hasOwnProperty","clone","_calculationInfo","extend","List","dimensions","hostModel","dimensionInfos","dimensionNames","invertedIndicesMap","i","length","dimensionInfo","isString","name","dimensionName","type","coordDim","coordDimIndex","otherDims","push","index","createInvertedIndices","_dimensionInfos","dataType","_indices","_count","_storage","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","hasItemVisual","_itemLayouts","_graphicEls","_chunkSize","_chunkCount","_rawData","_rawExtent","_extent","_approximateExtent","_dimensionsSummary","_invertedIndicesMap","userOutput","listProto","prototype","hasItemOption","getDimension","dim","isNaN","getDimensionInfo","getDimensionsOnCoord","dataDimsOnCoord","mapDimension","idx","dimensionsSummary","encodeFirstDimNotExtra","dims","encode","initData","data","nameList","dimValueGetter","notProvider","isInstance","isArrayLike","_nameRepeatCount","defaultDimValueGetter","getSource","sourceFormat","_dimValueGetter","_dimValueGetterArrayRows","arrayRows","_initDataFromProvider","count","pure","getProvider","appendData","rawData","start","end","persistent","appendValues","values","names","chunkSize","storage","dimLen","rawExtent","Math","max","originalChunkCount","getInitialExtent","prepareChunks","emptyDataItem","sourceIdx","chunkIndex","floor","chunkOffset","k","val","dimRawExtent","prepareInvertedIndex","dimensionInfoMap","idList","nameRepeatCount","nameDimIdx","dimInfo","itemName","_nameDimIdx","itemId","_idDimIdx","dataItem","getItem","dimStorage","nameDim","nameDimChunk","ordinalMeta","categories","id","clean","chunkCount","DataCtor","lastChunkIndex","resizeChunkArray","newStore","min","j","invertedIndices","get","getRawValueFromStore","dimIndex","rawIndex","chunk","getIndices","newIndices","indices","thisCount","buffer","NaN","getRawIndex","chunkStore","value","getByRawIndex","rawIdx","dimStore","_getFast","getValues","isArray","len","hasValue","getDataExtent","dimData","initialExtent","currEnd","useRaw","dimExtent","getApproximateExtent","setApproximateExtent","extent","getCalculationInfo","key","setCalculationInfo","getSum","sum","getMedian","dimDataArray","sortedDimDataArray","sort","a","b","rawIndexOf","indexOfName","getName","indexOfRawIndex","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","Infinity","minDist","minDiff","nearestIndicesLen","diff","dist","abs","getRawIndexWithoutIndices","getRawIndexWithIndices","getRawDataItem","getId","normalizeDimensions","validateDimensions","console","error","cb","context","contextCompat","map","dimSize","call","apply","filterSelf","offset","dim0","keep","selectRange","range","originalCount","quickFinished","chunkStorage","dimStorage2","min2","max2","chunkStorage2","val2","dimk","mapArray","result","arguments","cloneListForMapAndSample","original","excludeDimensions","allDimensions","originalStorage","indexOf","cloneDimStore","originalDimStore","newDimStore","tmpRetValue","dataCount","dataIndex","retValue","rawExtentOnDim","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","frameValues","frameSize","dataIdx","originalChunkIndex","originalChunkOffset","sampleFrameIdx","sampleChunkIndex","sampleChunkOffset","getItemModel","ecModel","otherList","thisList","getVisual","visual","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","layout","merge","clearItemLayouts","getItemVisual","ignoreParent","itemVisual","setItemVisual","clearAllVisual","setItemDataAndSeriesIndex","child","seriesIndex","setItemGraphicEl","el","traverse","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","wrapMethod","methodName","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","_default","module","exports"],"sources":["D:/Desktop/project/app/node_modules/echarts/lib/data/List.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar DataDiffer = require(\"./DataDiffer\");\n\nvar Source = require(\"./Source\");\n\nvar _dataProvider = require(\"./helper/dataProvider\");\n\nvar defaultDimValueGetters = _dataProvider.defaultDimValueGetters;\nvar DefaultDataProvider = _dataProvider.DefaultDataProvider;\n\nvar _dimensionHelper = require(\"./helper/dimensionHelper\");\n\nvar summarizeDimensions = _dimensionHelper.summarizeDimensions;\n\nvar DataDimensionInfo = require(\"./DataDimensionInfo\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\n\nfunction getIndicesCtor(list) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\n\nfunction transferProperties(target, source) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n    if (source.hasOwnProperty(propName)) {\n      target[propName] = source[propName];\n    }\n  });\n  target.__wrappedMethods = source.__wrappedMethods;\n  zrUtil.each(CLONE_PROPERTIES, function (propName) {\n    target[propName] = zrUtil.clone(source[propName]);\n  });\n  target._calculationInfo = zrUtil.extend(source._calculationInfo);\n}\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object|module:data/DataDimensionInfo>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n  var invertedIndicesMap = {};\n\n  for (var i = 0; i < dimensions.length; i++) {\n    // Use the original dimensions[i], where other flag props may exists.\n    var dimensionInfo = dimensions[i];\n\n    if (zrUtil.isString(dimensionInfo)) {\n      dimensionInfo = new DataDimensionInfo({\n        name: dimensionInfo\n      });\n    } else if (!(dimensionInfo instanceof DataDimensionInfo)) {\n      dimensionInfo = new DataDimensionInfo(dimensionInfo);\n    }\n\n    var dimensionName = dimensionInfo.name;\n    dimensionInfo.type = dimensionInfo.type || 'float';\n\n    if (!dimensionInfo.coordDim) {\n      dimensionInfo.coordDim = dimensionName;\n      dimensionInfo.coordDimIndex = 0;\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n    dimensionInfo.index = i;\n\n    if (dimensionInfo.createInvertedIndices) {\n      invertedIndicesMap[dimensionName] = [];\n    }\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this._indices = null;\n  this._count = 0;\n  this._rawCount = 0;\n  /**\n   * Data storage\n   * @type {Object.<key, Array.<TypedArray|Array>>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Key: visual type, Value: boolean\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.hasItemVisual = {};\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * Max size of each chunk.\n   * @type {number}\n   * @private\n   */\n\n  this._chunkSize = 1e5;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this._chunkCount = 0;\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * Raw extent will not be cloned, but only transfered.\n   * It will not be calculated util needed.\n   * key: dim,\n   * value: {end: number, extent: Array.<number>}\n   * @type {Object}\n   * @private\n   */\n\n  this._rawExtent = {};\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent = {};\n  /**\n   * key: dim\n   * value: extent\n   * @type {Object}\n   * @private\n   */\n\n  this._approximateExtent = {};\n  /**\n   * Cache summary info for fast visit. See \"dimensionHelper\".\n   * @type {Object}\n   * @private\n   */\n\n  this._dimensionsSummary = summarizeDimensions(this);\n  /**\n   * @type {Object.<Array|TypedArray>}\n   * @private\n   */\n\n  this._invertedIndicesMap = invertedIndicesMap;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._calculationInfo = {};\n  /**\n   * User output info of this data.\n   * DO NOT use it in other places!\n   *\n   * When preparing user params for user callbacks, we have\n   * to clone these inner data structures to prevent users\n   * from modifying them to effect built-in logic. And for\n   * performance consideration we make this `userOutput` to\n   * avoid clone them too many times.\n   *\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.userOutput = this._dimensionsSummary.userOutput;\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * The meanings of the input parameter `dim`:\n *\n * + If dim is a number (e.g., `1`), it means the index of the dimension.\n *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n * + If dim is a number-like string (e.g., `\"1\"`):\n *     + If there is the same concrete dim name defined in `this.dimensions`, it means that concrete name.\n *     + If not, it will be converted to a number, which means the index of the dimension.\n *        (why? because of the backward compatbility. We have been tolerating number-like string in\n *        dimension setting, although now it seems that it is not a good idea.)\n *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n *     if no dimension name is defined as `\"1\"`.\n * + If dim is a not-number-like string, it means the concrete dim name.\n *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n *   or customized in `dimensions` property of option like `\"age\"`.\n *\n * Get dimension name\n * @param {string|number} dim See above.\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (typeof dim === 'number' // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n    dim = this.dimensions[dim];\n  }\n\n  return dim;\n};\n/**\n * Get type and calculation info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  // Do not clone, because there may be categories in dimInfo.\n  return this._dimensionInfos[this.getDimension(dim)];\n};\n/**\n * @return {Array.<string>} concrete dimension name list on coord.\n */\n\n\nlistProto.getDimensionsOnCoord = function () {\n  return this._dimensionsSummary.dataDimsOnCoord.slice();\n};\n/**\n * @param {string} coordDim\n * @param {number} [idx] A coordDim may map to more than one data dim.\n *        If idx is `true`, return a array of all mapped dims.\n *        If idx is not specified, return the first dim not extra.\n * @return {string|Array.<string>} concrete data dim.\n *        If idx is number, and not found, return null/undefined.\n *        If idx is `true`, and not found, return empty array (always return array).\n */\n\n\nlistProto.mapDimension = function (coordDim, idx) {\n  var dimensionsSummary = this._dimensionsSummary;\n\n  if (idx == null) {\n    return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n  }\n\n  var dims = dimensionsSummary.encode[coordDim];\n  return idx === true // always return array if idx is `true`\n  ? (dims || []).slice() : dims && dims[idx];\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data source or data or data provider.\n * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and\n *        default label/tooltip.\n *        A name can be specified in encode.itemName,\n *        or dataItem.name (only for series option data),\n *        or provided in nameList from outside.\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);\n\n  if (notProvider) {\n    data = new DefaultDataProvider(data, this.dimensions.length);\n  }\n\n  this._rawData = data; // Clear\n\n  this._storage = {};\n  this._indices = null;\n  this._nameList = nameList || [];\n  this._idList = [];\n  this._nameRepeatCount = {};\n\n  if (!dimValueGetter) {\n    this.hasItemOption = false;\n  }\n  /**\n   * @readOnly\n   */\n\n\n  this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat]; // Default dim value getter\n\n  this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n  this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows; // Reset raw extent.\n\n  this._rawExtent = {};\n\n  this._initDataFromProvider(0, data.count()); // If data has no item option.\n\n\n  if (data.pure) {\n    this.hasItemOption = false;\n  }\n};\n\nlistProto.getProvider = function () {\n  return this._rawData;\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n */\n\n\nlistProto.appendData = function (data) {\n  var rawData = this._rawData;\n  var start = this.count();\n  rawData.appendData(data);\n  var end = rawData.count();\n\n  if (!rawData.persistent) {\n    end += start;\n  }\n\n  this._initDataFromProvider(start, end);\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n * This method does not modify `rawData` (`dataProvider`), but only\n * add values to storage.\n *\n * The final count will be increased by `Math.max(values.length, names.length)`.\n *\n * @param {Array.<Array.<*>>} values That is the SourceType: 'arrayRows', like\n *        [\n *            [12, 33, 44],\n *            [NaN, 43, 1],\n *            ['-', 'asdf', 0]\n *        ]\n *        Each item is exaclty cooresponding to a dimension.\n * @param {Array.<string>} [names]\n */\n\n\nlistProto.appendValues = function (values, names) {\n  var chunkSize = this._chunkSize;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var rawExtent = this._rawExtent;\n  var start = this.count();\n  var end = start + Math.max(values.length, names ? names.length : 0);\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var emptyDataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    var sourceIdx = idx - start;\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n\n      var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);\n\n      storage[dim][chunkIndex][chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    }\n\n    if (names) {\n      this._nameList[idx] = names[sourceIdx];\n    }\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nlistProto._initDataFromProvider = function (start, end) {\n  // Optimize.\n  if (start >= end) {\n    return;\n  }\n\n  var chunkSize = this._chunkSize;\n  var rawData = this._rawData;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var dimensionInfoMap = this._dimensionInfos;\n  var nameList = this._nameList;\n  var idList = this._idList;\n  var rawExtent = this._rawExtent;\n  var nameRepeatCount = this._nameRepeatCount = {};\n  var nameDimIdx;\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    var dimInfo = dimensionInfoMap[dim];\n\n    if (dimInfo.otherDims.itemName === 0) {\n      nameDimIdx = this._nameDimIdx = i;\n    }\n\n    if (dimInfo.otherDims.itemId === 0) {\n      this._idDimIdx = i;\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var dataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    // NOTICE: Try not to write things into dataItem\n    dataItem = rawData.getItem(idx, dataItem); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero\n\n      var val = this._dimValueGetter(dataItem, dim, idx, k);\n\n      dimStorage[chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    } // ??? FIXME not check by pure but sourceFormat?\n    // TODO refactor these logic.\n\n\n    if (!rawData.pure) {\n      var name = nameList[idx];\n\n      if (dataItem && name == null) {\n        // If dataItem is {name: ...}, it has highest priority.\n        // That is appropriate for many common cases.\n        if (dataItem.name != null) {\n          // There is no other place to persistent dataItem.name,\n          // so save it to nameList.\n          nameList[idx] = name = dataItem.name;\n        } else if (nameDimIdx != null) {\n          var nameDim = dimensions[nameDimIdx];\n          var nameDimChunk = storage[nameDim][chunkIndex];\n\n          if (nameDimChunk) {\n            name = nameDimChunk[chunkOffset];\n            var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;\n\n            if (ordinalMeta && ordinalMeta.categories.length) {\n              name = ordinalMeta.categories[name];\n            }\n          }\n        }\n      } // Try using the id in option\n      // id or name is used on dynamical data, mapping old and new items.\n\n\n      var id = dataItem == null ? null : dataItem.id;\n\n      if (id == null && name != null) {\n        // Use name as id and add counter to avoid same name\n        nameRepeatCount[name] = nameRepeatCount[name] || 0;\n        id = name;\n\n        if (nameRepeatCount[name] > 0) {\n          id += '__ec__' + nameRepeatCount[name];\n        }\n\n        nameRepeatCount[name]++;\n      }\n\n      id != null && (idList[idx] = id);\n    }\n  }\n\n  if (!rawData.persistent && rawData.clean) {\n    // Clean unused data if data source is typed array.\n    rawData.clean();\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nfunction prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {\n  var DataCtor = dataCtors[dimInfo.type];\n  var lastChunkIndex = chunkCount - 1;\n  var dim = dimInfo.name;\n  var resizeChunkArray = storage[dim][lastChunkIndex];\n\n  if (resizeChunkArray && resizeChunkArray.length < chunkSize) {\n    var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable\n    // within the initial chunkSize.\n\n    for (var j = 0; j < resizeChunkArray.length; j++) {\n      newStore[j] = resizeChunkArray[j];\n    }\n\n    storage[dim][lastChunkIndex] = newStore;\n  } // Create new chunks.\n\n\n  for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {\n    storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));\n  }\n}\n\nfunction prepareInvertedIndex(list) {\n  var invertedIndicesMap = list._invertedIndicesMap;\n  zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n    var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n    var ordinalMeta = dimInfo.ordinalMeta;\n\n    if (ordinalMeta) {\n      invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n      // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n      for (var i = 0; i < invertedIndices.length; i++) {\n        invertedIndices[i] = INDEX_NOT_FOUND;\n      }\n\n      for (var i = 0; i < list._count; i++) {\n        // Only support the case that all values are distinct.\n        invertedIndices[list.get(dim, i)] = i;\n      }\n    }\n  });\n}\n\nfunction getRawValueFromStore(list, dimIndex, rawIndex) {\n  var val;\n\n  if (dimIndex != null) {\n    var chunkSize = list._chunkSize;\n    var chunkIndex = Math.floor(rawIndex / chunkSize);\n    var chunkOffset = rawIndex % chunkSize;\n    var dim = list.dimensions[dimIndex];\n    var chunk = list._storage[dim][chunkIndex];\n\n    if (chunk) {\n      val = chunk[chunkOffset];\n      var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;\n\n      if (ordinalMeta && ordinalMeta.categories.length) {\n        val = ordinalMeta.categories[val];\n      }\n    }\n  }\n\n  return val;\n}\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this._count;\n};\n\nlistProto.getIndices = function () {\n  var newIndices;\n  var indices = this._indices;\n\n  if (indices) {\n    var Ctor = indices.constructor;\n    var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n    if (Ctor === Array) {\n      newIndices = new Ctor(thisCount);\n\n      for (var i = 0; i < thisCount; i++) {\n        newIndices[i] = indices[i];\n      }\n    } else {\n      newIndices = new Ctor(indices.buffer, 0, thisCount);\n    }\n  } else {\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(this.count());\n\n    for (var i = 0; i < newIndices.length; i++) {\n      newIndices[i] = i;\n    }\n  }\n\n  return newIndices;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx\n/*, stack */\n) {\n  if (!(idx >= 0 && idx < this._count)) {\n    return NaN;\n  }\n\n  var storage = this._storage;\n\n  if (!storage[dim]) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  idx = this.getRawIndex(idx);\n  var chunkIndex = Math.floor(idx / this._chunkSize);\n  var chunkOffset = idx % this._chunkSize;\n  var chunkStore = storage[dim][chunkIndex];\n  var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable\n  // if (stack) {\n  //     var dimensionInfo = this._dimensionInfos[dim];\n  //     if (dimensionInfo && dimensionInfo.stackable) {\n  //         var stackedOn = this.stackedOn;\n  //         while (stackedOn) {\n  //             // Get no stacked data of stacked on\n  //             var stackedValue = stackedOn.get(dim, idx);\n  //             // Considering positive stack, negative stack and empty data\n  //             if ((value >= 0 && stackedValue > 0)  // Positive stack\n  //                 || (value <= 0 && stackedValue < 0) // Negative stack\n  //             ) {\n  //                 value += stackedValue;\n  //             }\n  //             stackedOn = stackedOn.stackedOn;\n  //         }\n  //     }\n  // }\n\n  return value;\n};\n/**\n * @param {string} dim concrete dim\n * @param {number} rawIndex\n * @return {number|string}\n */\n\n\nlistProto.getByRawIndex = function (dim, rawIdx) {\n  if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n    return NaN;\n  }\n\n  var dimStore = this._storage[dim];\n\n  if (!dimStore) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = dimStore[chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).\n * Hack a much simpler _getFast\n * @private\n */\n\n\nlistProto._getFast = function (dim, rawIdx) {\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = this._storage[dim][chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx\n/*, stack */\n) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    // stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx\n    /*, stack */\n    ));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * Only check the coord dimensions.\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n\n  for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n    // Ordinal type originally can be string or number.\n    // But when an ordinal type is used on coord, it can\n    // not be string but only number. So we can also use isNaN.\n    if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getDataExtent = function (dim\n/*, stack */\n) {\n  // Make sure use concrete dim as cache name.\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));\n\n  if (!dimData) {\n    return initialExtent;\n  } // Make more strict checkings to ensure hitting cache.\n\n\n  var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');\n  // var cacheName = dim;\n  // Consider the most cases when using data zoom, `getDataExtent`\n  // happened before filtering. We cache raw extent, which is not\n  // necessary to be cleared and recalculated when restore data.\n\n  var useRaw = !this._indices; // && !stack;\n\n  var dimExtent;\n\n  if (useRaw) {\n    return this._rawExtent[dim].slice();\n  }\n\n  dimExtent = this._extent[dim];\n\n  if (dimExtent) {\n    return dimExtent.slice();\n  }\n\n  dimExtent = initialExtent;\n  var min = dimExtent[0];\n  var max = dimExtent[1];\n\n  for (var i = 0; i < currEnd; i++) {\n    // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));\n    var value = this._getFast(dim, this.getRawIndex(i));\n\n    value < min && (min = value);\n    value > max && (max = value);\n  }\n\n  dimExtent = [min, max];\n  this._extent[dim] = dimExtent;\n  return dimExtent;\n};\n/**\n * Optimize for the scenario that data is filtered by a given extent.\n * Consider that if data amount is more than hundreds of thousand,\n * extent calculation will cost more than 10ms and the cache will\n * be erased because of the filtering.\n */\n\n\nlistProto.getApproximateExtent = function (dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  return this._approximateExtent[dim] || this.getDataExtent(dim\n  /*, stack */\n  );\n};\n\nlistProto.setApproximateExtent = function (extent, dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  this._approximateExtent[dim] = extent.slice();\n};\n/**\n * @param {string} key\n * @return {*}\n */\n\n\nlistProto.getCalculationInfo = function (key) {\n  return this._calculationInfo[key];\n};\n/**\n * @param {string|Object} key or k-v object\n * @param {*} [value]\n */\n\n\nlistProto.setCalculationInfo = function (key, value) {\n  isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getSum = function (dim\n/*, stack */\n) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i\n      /*, stack */\n      );\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Get median of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getMedian = function (dim\n/*, stack */\n) {\n  var dimDataArray = []; // map all data of one dimension\n\n  this.each(dim, function (val, idx) {\n    if (!isNaN(val)) {\n      dimDataArray.push(val);\n    }\n  }); // TODO\n  // Use quick select?\n  // immutability & sort\n\n  var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {\n    return a - b;\n  });\n  var len = this.count(); // calculate median\n\n  return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n}; // /**\n//  * Retreive the index with given value\n//  * @param {string} dim Concrete dimension.\n//  * @param {number} value\n//  * @return {number}\n//  */\n// Currently incorrect: should return dataIndex but not rawIndex.\n// Do not fix it until this method is to be used somewhere.\n// FIXME Precision of float value\n// listProto.indexOf = function (dim, value) {\n//     var storage = this._storage;\n//     var dimData = storage[dim];\n//     var chunkSize = this._chunkSize;\n//     if (dimData) {\n//         for (var i = 0, len = this.count(); i < len; i++) {\n//             var chunkIndex = Math.floor(i / chunkSize);\n//             var chunkOffset = i % chunkSize;\n//             if (dimData[chunkIndex][chunkOffset] === value) {\n//                 return i;\n//             }\n//         }\n//     }\n//     return -1;\n// };\n\n/**\n * Only support the dimension which inverted index created.\n * Do not support other cases until required.\n * @param {string} concrete dim\n * @param {number|string} value\n * @return {number} rawIndex\n */\n\n\nlistProto.rawIndexOf = function (dim, value) {\n  var invertedIndices = dim && this._invertedIndicesMap[dim];\n  var rawIndex = invertedIndices[value];\n\n  if (rawIndex == null || isNaN(rawIndex)) {\n    return INDEX_NOT_FOUND;\n  }\n\n  return rawIndex;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  for (var i = 0, len = this.count(); i < len; i++) {\n    if (this.getName(i) === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  if (rawIndex >= this._rawCount || rawIndex < 0) {\n    return -1;\n  }\n\n  if (!this._indices) {\n    return rawIndex;\n  } // Indices are ascending\n\n\n  var indices = this._indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = this._count - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} If and only if multiple indices has\n *        the same value, they are put to the result.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Infinity;\n  var minDiff = -1;\n  var nearestIndicesLen = 0; // Check the test case of `test/ut/spec/data/List.js`.\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i);\n    var dist = Math.abs(diff);\n\n    if (dist <= maxDistance) {\n      // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,\n      // we'd better not push both of them to `nearestIndices`, otherwise it is easy to\n      // get more than one item in `nearestIndices` (more specifically, in `tooltip`).\n      // So we chose the one that `diff >= 0` in this csae.\n      // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them\n      // should be push to `nearestIndices`.\n      if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndicesLen = 0;\n      }\n\n      if (diff === minDiff) {\n        nearestIndices[nearestIndicesLen++] = i;\n      }\n    }\n  }\n\n  nearestIndices.length = nearestIndicesLen;\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = getRawIndexWithoutIndices;\n\nfunction getRawIndexWithoutIndices(idx) {\n  return idx;\n}\n\nfunction getRawIndexWithIndices(idx) {\n  if (idx < this._count && idx >= 0) {\n    return this._indices[idx];\n  }\n\n  return -1;\n}\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  if (!this._rawData.persistent) {\n    var val = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      var dim = this.dimensions[i];\n      val.push(this.get(dim, idx));\n    }\n\n    return val;\n  } else {\n    return this._rawData.getItem(this.getRawIndex(idx));\n  }\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  var rawIndex = this.getRawIndex(idx);\n  return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return getId(this, this.getRawIndex(idx));\n};\n\nfunction getId(list, rawIndex) {\n  var id = list._idList[rawIndex];\n\n  if (id == null) {\n    id = getRawValueFromStore(list, list._idDimIdx, rawIndex);\n  }\n\n  if (id == null) {\n    // FIXME Check the usage in graph, should not use prefix.\n    id = ID_PREFIX + rawIndex;\n  }\n\n  return id;\n}\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n\nfunction validateDimensions(list, dims) {\n  for (var i = 0; i < dims.length; i++) {\n    // stroage may be empty when no data, so use\n    // dimensionInfos to check.\n    if (!list._dimensionInfos[dims[i]]) {\n      console.error('Unkown dimension ' + dims[i]);\n    }\n  }\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dims === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dims;\n    dims = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var dimSize = dims.length;\n\n  for (var i = 0; i < this.count(); i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);\n        break;\n\n      default:\n        var k = 0;\n        var value = [];\n\n        for (; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var count = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(count);\n  var value = [];\n  var dimSize = dimensions.length;\n  var offset = 0;\n  var dim0 = dimensions[0];\n\n  for (var i = 0; i < count; i++) {\n    var keep;\n    var rawIdx = this.getRawIndex(i); // Simple optimization\n\n    if (dimSize === 0) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      var val = this._getFast(dim0, rawIdx);\n\n      keep = cb.call(context, val, i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this._getFast(dim0, rawIdx);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices[offset++] = rawIdx;\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < count) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Select data in range. (For optimization of filter)\n * (Manually inline code, support 5 million data filtering in data zoom.)\n */\n\n\nlistProto.selectRange = function (range) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  var dimensions = [];\n\n  for (var dim in range) {\n    if (range.hasOwnProperty(dim)) {\n      dimensions.push(dim);\n    }\n  }\n\n  var dimSize = dimensions.length;\n\n  if (!dimSize) {\n    return;\n  }\n\n  var originalCount = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(originalCount);\n  var offset = 0;\n  var dim0 = dimensions[0];\n  var min = range[dim0][0];\n  var max = range[dim0][1];\n  var quickFinished = false;\n\n  if (!this._indices) {\n    // Extreme optimization for common case. About 2x faster in chrome.\n    var idx = 0;\n\n    if (dimSize === 1) {\n      var dimStorage = this._storage[dimensions[0]];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    } else if (dimSize === 2) {\n      var dimStorage = this._storage[dim0];\n      var dimStorage2 = this._storage[dimensions[1]];\n      var min2 = range[dimensions[1]][0];\n      var max2 = range[dimensions[1]][1];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var chunkStorage2 = dimStorage2[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i];\n          var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    }\n  }\n\n  if (!quickFinished) {\n    if (dimSize === 1) {\n      for (var i = 0; i < originalCount; i++) {\n        var rawIndex = this.getRawIndex(i);\n\n        var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.\n\n\n        if (val >= min && val <= max || isNaN(val)) {\n          newIndices[offset++] = rawIndex;\n        }\n      }\n    } else {\n      for (var i = 0; i < originalCount; i++) {\n        var keep = true;\n        var rawIndex = this.getRawIndex(i);\n\n        for (var k = 0; k < dimSize; k++) {\n          var dimk = dimensions[k];\n\n          var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.\n\n\n          if (val < range[dimk][0] || val > range[dimk][1]) {\n            keep = false;\n          }\n        }\n\n        if (keep) {\n          newIndices[offset++] = this.getRawIndex(i);\n        }\n      }\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < originalCount) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, context);\n  return result;\n}; // Data in excludeDimensions is copied, otherwise transfered.\n\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n\n    if (originalStorage[dim]) {\n      // Notice that we do not reset invertedIndicesMap here, becuase\n      // there is no scenario of mapping or sampling ordinal dimension.\n      if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n        storage[dim] = cloneDimStore(originalStorage[dim]);\n        list._rawExtent[dim] = getInitialExtent();\n        list._extent[dim] = null;\n      } else {\n        // Direct reference for other dimensions\n        storage[dim] = originalStorage[dim];\n      }\n    }\n  }\n\n  return list;\n}\n\nfunction cloneDimStore(originalDimStore) {\n  var newDimStore = new Array(originalDimStore.length);\n\n  for (var j = 0; j < originalDimStore.length; j++) {\n    newDimStore[j] = cloneChunk(originalDimStore[j]);\n  }\n\n  return newDimStore;\n}\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, context, contextCompat) {\n  'use strict'; // contextCompat just for compat echarts3\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  list._indices = this._indices;\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  var chunkSize = this._chunkSize;\n  var dimSize = dimensions.length;\n  var dataCount = this.count();\n  var values = [];\n  var rawExtent = list._rawExtent;\n\n  for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n    for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n      values[dimIndex] = this.get(dimensions[dimIndex], dataIndex\n      /*, stack */\n      );\n    }\n\n    values[dimSize] = dataIndex;\n    var retValue = cb && cb.apply(context, values);\n\n    if (retValue != null) {\n      // a number or string (in oridinal dimension)?\n      if (typeof retValue !== 'object') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      var rawIndex = this.getRawIndex(dataIndex);\n      var chunkIndex = Math.floor(rawIndex / chunkSize);\n      var chunkOffset = rawIndex % chunkSize;\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var val = retValue[i];\n        var rawExtentOnDim = rawExtent[dim];\n        var dimStore = storage[dim];\n\n        if (dimStore) {\n          dimStore[chunkIndex][chunkOffset] = val;\n        }\n\n        if (val < rawExtentOnDim[0]) {\n          rawExtentOnDim[0] = val;\n        }\n\n        if (val > rawExtentOnDim[1]) {\n          rawExtentOnDim[1] = val;\n        }\n      }\n    }\n  }\n\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var targetStorage = list._storage;\n  var frameValues = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count();\n  var chunkSize = this._chunkSize;\n  var rawExtentOnDim = list._rawExtent[dimension];\n  var newIndices = new (getIndicesCtor(this))(len);\n  var offset = 0;\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var dataIdx = this.getRawIndex(i + k);\n      var originalChunkIndex = Math.floor(dataIdx / chunkSize);\n      var originalChunkOffset = dataIdx % chunkSize;\n      frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];\n    }\n\n    var value = sampleValue(frameValues);\n    var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n    var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);\n    var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data\n\n    dimStore[sampleChunkIndex][sampleChunkOffset] = value;\n\n    if (value < rawExtentOnDim[0]) {\n      rawExtentOnDim[0] = value;\n    }\n\n    if (value > rawExtentOnDim[1]) {\n      rawExtentOnDim[1] = value;\n    }\n\n    newIndices[offset++] = sampleFrameIdx;\n  }\n\n  list._count = offset;\n  list._indices = newIndices;\n  list.getRawIndex = getRawIndexWithIndices;\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var thisList = this;\n  return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n    return getId(otherList, idx);\n  }, function (idx) {\n    return getId(thisList, idx);\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  var hasItemVisual = this.hasItemVisual;\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n        hasItemVisual[name] = true;\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n  hasItemVisual[key] = true;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n  this.hasItemVisual = {};\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function (list) {\n  if (!list) {\n    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n    list = new List(dimensionInfoList, this.hostModel);\n  } // FIXME\n\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  if (this._indices) {\n    var Ctor = this._indices.constructor;\n    list._indices = new Ctor(this._indices);\n  } else {\n    list._indices = null;\n  }\n\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\nvar _default = List;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}