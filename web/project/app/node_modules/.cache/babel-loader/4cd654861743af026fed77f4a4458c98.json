{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar each = _util.each;\nvar filter = _util.filter;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar indexOf = _util.indexOf;\nvar isObject = _util.isObject;\nvar isString = _util.isString;\nvar createHashMap = _util.createHashMap;\nvar assert = _util.assert;\nvar clone = _util.clone;\nvar merge = _util.merge;\nvar extend = _util.extend;\nvar mixin = _util.mixin;\n\nvar modelUtil = require(\"../util/model\");\n\nvar Model = require(\"./Model\");\n\nvar ComponentModel = require(\"./Component\");\n\nvar globalDefault = require(\"./globalDefault\");\n\nvar colorPaletteMixin = require(\"./mixin/colorPalette\");\n\nvar _sourceHelper = require(\"../data/helper/sourceHelper\");\n\nvar resetSourceDefaulter = _sourceHelper.resetSourceDefaulter;\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\n\nvar OPTION_INNER_KEY = '\\0_ec_inner';\n/**\n * @alias module:echarts/model/Global\n *\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {Object} theme\n */\n\nvar GlobalModel = Model.extend({\n  init: function (option, parentModel, theme, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    /**\n     * @type {module:echarts/model/Model}\n     * @private\n     */\n\n    this._theme = new Model(theme);\n    /**\n     * @type {module:echarts/model/OptionManager}\n     */\n\n    this._optionManager = optionManager;\n  },\n  setOption: function (option, optionPreprocessorFuncs) {\n    assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n    this.resetOption(null);\n  },\n\n  /**\n   * @param {string} type null/undefined: reset all.\n   *                      'recreate': force recreate all.\n   *                      'timeline': only reset timeline option\n   *                      'media': only reset media query option\n   * @return {boolean} Whether option changed.\n   */\n  resetOption: function (type) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (!this.option || type === 'recreate') {\n        initBase.call(this, baseOption);\n      } else {\n        this.restoreData();\n        this.mergeOption(baseOption);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    }\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this, this._api);\n\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          this.mergeOption(mediaOption, optionChanged = true);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  },\n\n  /**\n   * @protected\n   */\n  mergeOption: function (newOption) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var newCptTypes = [];\n    resetSourceDefaulter(this); // If no component class, merge directly.\n    // For example: color, animaiton options, etc.\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!ComponentModel.hasClass(mainType)) {\n        // globalSettingTask.dirty();\n        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);\n      } else if (mainType) {\n        newCptTypes.push(mainType);\n      }\n    });\n    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n\n    function visitComponent(mainType, dependencies) {\n      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);\n      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.\n\n      each(mapResult, function (item, index) {\n        var opt = item.option;\n\n        if (isObject(opt)) {\n          item.keyInfo.mainType = mainType;\n          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n        }\n      });\n      var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n      option[mainType] = [];\n      componentsMap.set(mainType, []);\n      each(mapResult, function (resultItem, index) {\n        var componentModel = resultItem.exist;\n        var newCptOption = resultItem.option;\n        assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},\n        // see removeEdgeAndAdd in topologicalTravel and\n        // ComponentModel.getAllClassMainTypes.\n\n        if (!newCptOption) {\n          componentModel.mergeOption({}, this);\n          componentModel.optionUpdated({}, false);\n        } else {\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\n          if (componentModel && componentModel.constructor === ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();\n\n            componentModel.mergeOption(newCptOption, this);\n            componentModel.optionUpdated(newCptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = extend({\n              dependentModels: dependentModels,\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n            extend(componentModel, extraOpt);\n            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.\n            // newCptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        componentsMap.get(mainType)[index] = componentModel;\n        option[mainType][index] = componentModel.option;\n      }, this); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        createSeriesIndices(this, componentsMap.get('series'));\n      }\n    }\n\n    this._seriesIndicesMap = createHashMap(this._seriesIndices = this._seriesIndices || []);\n  },\n\n  /**\n   * Get option for output (cloned option and inner info removed)\n   * @public\n   * @return {Object}\n   */\n  getOption: function () {\n    var option = clone(this.option);\n    each(option, function (opts, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(opts);\n\n        for (var i = opts.length - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (modelUtil.isIdInner(opts[i])) {\n            opts.splice(i, 1);\n          }\n        }\n\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  },\n\n  /**\n   * @return {module:echarts/model/Model}\n   */\n  getTheme: function () {\n    return this._theme;\n  },\n\n  /**\n   * @param {string} mainType\n   * @param {number} [idx=0]\n   * @return {module:echarts/model/Component}\n   */\n  getComponent: function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      return list[idx || 0];\n    }\n  },\n\n  /**\n   * If none of index and id and name used, return all components with mainType.\n   * @param {Object} condition\n   * @param {string} condition.mainType\n   * @param {string} [condition.subType] If ignore, only query by mainType\n   * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  queryComponents: function (condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cpts = this._componentsMap.get(mainType);\n\n    if (!cpts || !cpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      if (!isArray(index)) {\n        index = [index];\n      }\n\n      result = filter(map(index, function (idx) {\n        return cpts[idx];\n      }), function (val) {\n        return !!val;\n      });\n    } else if (id != null) {\n      var isIdArray = isArray(id);\n      result = filter(cpts, function (cpt) {\n        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n      });\n    } else if (name != null) {\n      var isNameArray = isArray(name);\n      result = filter(cpts, function (cpt) {\n        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n      });\n    } else {\n      // Return all components with mainType\n      result = cpts.slice();\n    }\n\n    return filterBySubType(result, condition);\n  },\n\n  /**\n   * The interface is different from queryComponents,\n   * which is convenient for inner usage.\n   *\n   * @usage\n   * var result = findComponents(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series',\n   *     filter: function (model, index) {...}}\n   * );\n   * // result like [component0, componnet1, ...]\n   *\n   * @param {Object} condition\n   * @param {string} condition.mainType Mandatory.\n   * @param {string} [condition.subType] Optional.\n   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n   *        where xxx is mainType.\n   *        If query attribute is null/undefined or has no index/id/name,\n   *        do not filtering by query conditions, which is convenient for\n   *        no-payload situations or when target of action is global.\n   * @param {Function} [condition.filter] parameter: component, return boolean.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  findComponents: function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  },\n\n  /**\n   * @usage\n   * eachComponent('legend', function (legendModel, index) {\n   *     ...\n   * });\n   * eachComponent(function (componentType, model, index) {\n   *     // componentType does not include subType\n   *     // (componentType is 'xxx' but not 'xxx.aa')\n   * });\n   * eachComponent(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n   *     function (model, index) {...}\n   * );\n   * eachComponent(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n   *     function (model, index) {...}\n   * );\n   *\n   * @param {string|Object=} mainType When mainType is object, the definition\n   *                                  is the same as the method 'findComponents'.\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachComponent: function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if (typeof mainType === 'function') {\n      context = cb;\n      cb = mainType;\n      componentsMap.each(function (components, componentType) {\n        each(components, function (component, index) {\n          cb.call(context, componentType, component, index);\n        });\n      });\n    } else if (isString(mainType)) {\n      each(componentsMap.get(mainType), cb, context);\n    } else if (isObject(mainType)) {\n      var queryResult = this.findComponents(mainType);\n      each(queryResult, cb, context);\n    }\n  },\n\n  /**\n   * @param {string} name\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByName: function (name) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.name === name;\n    });\n  },\n\n  /**\n   * @param {number} seriesIndex\n   * @return {module:echarts/model/Series}\n   */\n  getSeriesByIndex: function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  },\n\n  /**\n   * Get series list before filtered by type.\n   * FIXME: rename to getRawSeriesByType?\n   *\n   * @param {string} subType\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByType: function (subType) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.subType === subType;\n    });\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeries: function () {\n    return this._componentsMap.get('series').slice();\n  },\n\n  /**\n   * @return {number}\n   */\n  getSeriesCount: function () {\n    return this._componentsMap.get('series').length;\n  },\n\n  /**\n   * After filtering, series may be different\n   * frome raw series.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeries: function (cb, context) {\n    each(this._componentsMap.get('series'), cb, context);\n  },\n\n  /**\n   * After filtering, series may be different.\n   * frome raw series.\n   *\n   * @param {string} subType.\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeriesByType: function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered of given type.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeriesByType: function (subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  },\n\n  /**\n   * @param {module:echarts/model/Series} seriesModel\n   */\n  isSeriesFiltered: function (seriesModel) {\n    assertSeriesInitialized(this);\n    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getCurrentSeriesIndices: function () {\n    return (this._seriesIndices || []).slice();\n  },\n\n  /**\n   * @param {Function} cb\n   * @param {*} context\n   */\n  filterSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);\n    createSeriesIndices(this, filteredSeries);\n  },\n  restoreData: function (payload) {\n    var componentsMap = this._componentsMap;\n    createSeriesIndices(this, componentsMap.get('series'));\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      componentTypes.push(componentType);\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n      each(componentsMap.get(componentType), function (component) {\n        (componentType !== 'series' || !isNotTargetSeries(component, payload)) && component.restoreData();\n      });\n    });\n  }\n});\n\nfunction isNotTargetSeries(seriesModel, payload) {\n  if (payload) {\n    var index = payload.seiresIndex;\n    var id = payload.seriesId;\n    var name = payload.seriesName;\n    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name != null && seriesModel.name !== name;\n  }\n}\n/**\n * @inner\n */\n\n\nfunction mergeTheme(option, theme) {\n  // PENDING\n  // NOT use `colorLayer` in theme if option has `color`\n  var notMergeColorLayer = option.color && !option.colorLayer;\n  each(theme, function (themeItem, name) {\n    if (name === 'colorLayer' && notMergeColorLayer) {\n      return;\n    } // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n\n\n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction initBase(baseOption) {\n  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\n  this.option = {};\n  this.option[OPTION_INNER_KEY] = 1;\n  /**\n   * Init with series: [], in case of calling findSeries method\n   * before series initialized.\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\n   * @private\n   */\n\n  this._componentsMap = createHashMap({\n    series: []\n  });\n  /**\n   * Mapping between filtered series list and raw series list.\n   * key: filtered series indices, value: raw series indices.\n   * @type {Array.<nubmer>}\n   * @private\n   */\n\n  this._seriesIndices;\n  this._seriesIndicesMap;\n  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property\n\n  merge(baseOption, globalDefault, false);\n  this.mergeOption(baseOption);\n}\n/**\n * @inner\n * @param {Array.<string>|string} types model types\n * @return {Object} key: {string} type, value: {Array.<Object>} models\n */\n\n\nfunction getComponentsByTypes(componentsMap, types) {\n  if (!isArray(types)) {\n    types = types ? [types] : [];\n  }\n\n  var ret = {};\n  each(types, function (type) {\n    ret[type] = (componentsMap.get(type) || []).slice();\n  });\n  return ret;\n}\n/**\n * @inner\n */\n\n\nfunction determineSubType(mainType, newCptOption, existComponent) {\n  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * @inner\n */\n\n\nfunction createSeriesIndices(ecModel, seriesModels) {\n  ecModel._seriesIndicesMap = createHashMap(ecModel._seriesIndices = map(seriesModels, function (series) {\n    return series.componentIndex;\n  }) || []);\n}\n/**\n * @inner\n */\n\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n    return cpt.subType === condition.subType;\n  }) : components;\n}\n/**\n * @inner\n */\n\n\nfunction assertSeriesInitialized(ecModel) {}\n\nmixin(GlobalModel, colorPaletteMixin);\nvar _default = GlobalModel;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","__DEV__","_util","each","filter","map","isArray","indexOf","isObject","isString","createHashMap","assert","clone","merge","extend","mixin","modelUtil","Model","ComponentModel","globalDefault","colorPaletteMixin","_sourceHelper","resetSourceDefaulter","OPTION_INNER_KEY","GlobalModel","init","option","parentModel","theme","optionManager","_theme","_optionManager","setOption","optionPreprocessorFuncs","resetOption","type","optionChanged","baseOption","mountOption","initBase","call","restoreData","mergeOption","timelineOption","getTimelineOption","mediaOptions","getMediaOption","_api","length","mediaOption","newOption","componentsMap","_componentsMap","newCptTypes","componentOption","mainType","hasClass","push","topologicalTravel","getAllClassMainTypes","visitComponent","dependencies","newCptOptionList","normalizeToArray","mapResult","mappingToExists","get","makeIdAndName","item","index","opt","keyInfo","subType","determineSubType","exist","dependentModels","getComponentsByTypes","set","resultItem","componentModel","newCptOption","optionUpdated","ComponentModelClass","getClass","constructor","name","extraOpt","componentIndex","createSeriesIndices","_seriesIndicesMap","_seriesIndices","getOption","opts","i","isIdInner","splice","getTheme","getComponent","idx","list","queryComponents","condition","id","cpts","result","val","isIdArray","cpt","isNameArray","slice","filterBySubType","findComponents","query","queryCond","getQueryCond","doFilter","q","indexAttr","idAttr","nameAttr","res","eachComponent","cb","context","components","componentType","component","queryResult","getSeriesByName","series","oneSeries","getSeriesByIndex","seriesIndex","getSeriesByType","getSeries","getSeriesCount","eachSeries","assertSeriesInitialized","rawSeriesIndex","eachRawSeries","eachSeriesByType","eachRawSeriesByType","isSeriesFiltered","seriesModel","getCurrentSeriesIndices","filterSeries","filteredSeries","payload","componentTypes","isNotTargetSeries","seiresIndex","seriesId","seriesName","mergeTheme","notMergeColorLayer","color","colorLayer","themeItem","types","ret","existComponent","ecModel","seriesModels","hasOwnProperty","_default","module","exports"],"sources":["C:/Users/XiaoAn1/Desktop/project/app/node_modules/echarts/lib/model/Global.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar each = _util.each;\nvar filter = _util.filter;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar indexOf = _util.indexOf;\nvar isObject = _util.isObject;\nvar isString = _util.isString;\nvar createHashMap = _util.createHashMap;\nvar assert = _util.assert;\nvar clone = _util.clone;\nvar merge = _util.merge;\nvar extend = _util.extend;\nvar mixin = _util.mixin;\n\nvar modelUtil = require(\"../util/model\");\n\nvar Model = require(\"./Model\");\n\nvar ComponentModel = require(\"./Component\");\n\nvar globalDefault = require(\"./globalDefault\");\n\nvar colorPaletteMixin = require(\"./mixin/colorPalette\");\n\nvar _sourceHelper = require(\"../data/helper/sourceHelper\");\n\nvar resetSourceDefaulter = _sourceHelper.resetSourceDefaulter;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * ECharts global model\n *\n * @module {echarts/model/Global}\n */\n\n/**\n * Caution: If the mechanism should be changed some day, these cases\n * should be considered:\n *\n * (1) In `merge option` mode, if using the same option to call `setOption`\n * many times, the result should be the same (try our best to ensure that).\n * (2) In `merge option` mode, if a component has no id/name specified, it\n * will be merged by index, and the result sequence of the components is\n * consistent to the original sequence.\n * (3) `reset` feature (in toolbox). Find detailed info in comments about\n * `mergeOption` in module:echarts/model/OptionManager.\n */\nvar OPTION_INNER_KEY = '\\0_ec_inner';\n/**\n * @alias module:echarts/model/Global\n *\n * @param {Object} option\n * @param {module:echarts/model/Model} parentModel\n * @param {Object} theme\n */\n\nvar GlobalModel = Model.extend({\n  init: function (option, parentModel, theme, optionManager) {\n    theme = theme || {};\n    this.option = null; // Mark as not initialized.\n\n    /**\n     * @type {module:echarts/model/Model}\n     * @private\n     */\n\n    this._theme = new Model(theme);\n    /**\n     * @type {module:echarts/model/OptionManager}\n     */\n\n    this._optionManager = optionManager;\n  },\n  setOption: function (option, optionPreprocessorFuncs) {\n    assert(!(OPTION_INNER_KEY in option), 'please use chart.getOption()');\n\n    this._optionManager.setOption(option, optionPreprocessorFuncs);\n\n    this.resetOption(null);\n  },\n\n  /**\n   * @param {string} type null/undefined: reset all.\n   *                      'recreate': force recreate all.\n   *                      'timeline': only reset timeline option\n   *                      'media': only reset media query option\n   * @return {boolean} Whether option changed.\n   */\n  resetOption: function (type) {\n    var optionChanged = false;\n    var optionManager = this._optionManager;\n\n    if (!type || type === 'recreate') {\n      var baseOption = optionManager.mountOption(type === 'recreate');\n\n      if (!this.option || type === 'recreate') {\n        initBase.call(this, baseOption);\n      } else {\n        this.restoreData();\n        this.mergeOption(baseOption);\n      }\n\n      optionChanged = true;\n    }\n\n    if (type === 'timeline' || type === 'media') {\n      this.restoreData();\n    }\n\n    if (!type || type === 'recreate' || type === 'timeline') {\n      var timelineOption = optionManager.getTimelineOption(this);\n      timelineOption && (this.mergeOption(timelineOption), optionChanged = true);\n    }\n\n    if (!type || type === 'recreate' || type === 'media') {\n      var mediaOptions = optionManager.getMediaOption(this, this._api);\n\n      if (mediaOptions.length) {\n        each(mediaOptions, function (mediaOption) {\n          this.mergeOption(mediaOption, optionChanged = true);\n        }, this);\n      }\n    }\n\n    return optionChanged;\n  },\n\n  /**\n   * @protected\n   */\n  mergeOption: function (newOption) {\n    var option = this.option;\n    var componentsMap = this._componentsMap;\n    var newCptTypes = [];\n    resetSourceDefaulter(this); // If no component class, merge directly.\n    // For example: color, animaiton options, etc.\n\n    each(newOption, function (componentOption, mainType) {\n      if (componentOption == null) {\n        return;\n      }\n\n      if (!ComponentModel.hasClass(mainType)) {\n        // globalSettingTask.dirty();\n        option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true);\n      } else if (mainType) {\n        newCptTypes.push(mainType);\n      }\n    });\n    ComponentModel.topologicalTravel(newCptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this);\n\n    function visitComponent(mainType, dependencies) {\n      var newCptOptionList = modelUtil.normalizeToArray(newOption[mainType]);\n      var mapResult = modelUtil.mappingToExists(componentsMap.get(mainType), newCptOptionList);\n      modelUtil.makeIdAndName(mapResult); // Set mainType and complete subType.\n\n      each(mapResult, function (item, index) {\n        var opt = item.option;\n\n        if (isObject(opt)) {\n          item.keyInfo.mainType = mainType;\n          item.keyInfo.subType = determineSubType(mainType, opt, item.exist);\n        }\n      });\n      var dependentModels = getComponentsByTypes(componentsMap, dependencies);\n      option[mainType] = [];\n      componentsMap.set(mainType, []);\n      each(mapResult, function (resultItem, index) {\n        var componentModel = resultItem.exist;\n        var newCptOption = resultItem.option;\n        assert(isObject(newCptOption) || componentModel, 'Empty component definition'); // Consider where is no new option and should be merged using {},\n        // see removeEdgeAndAdd in topologicalTravel and\n        // ComponentModel.getAllClassMainTypes.\n\n        if (!newCptOption) {\n          componentModel.mergeOption({}, this);\n          componentModel.optionUpdated({}, false);\n        } else {\n          var ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, true);\n\n          if (componentModel && componentModel.constructor === ComponentModelClass) {\n            componentModel.name = resultItem.keyInfo.name; // componentModel.settingTask && componentModel.settingTask.dirty();\n\n            componentModel.mergeOption(newCptOption, this);\n            componentModel.optionUpdated(newCptOption, false);\n          } else {\n            // PENDING Global as parent ?\n            var extraOpt = extend({\n              dependentModels: dependentModels,\n              componentIndex: index\n            }, resultItem.keyInfo);\n            componentModel = new ComponentModelClass(newCptOption, this, this, extraOpt);\n            extend(componentModel, extraOpt);\n            componentModel.init(newCptOption, this, this, extraOpt); // Call optionUpdated after init.\n            // newCptOption has been used as componentModel.option\n            // and may be merged with theme and default, so pass null\n            // to avoid confusion.\n\n            componentModel.optionUpdated(null, true);\n          }\n        }\n\n        componentsMap.get(mainType)[index] = componentModel;\n        option[mainType][index] = componentModel.option;\n      }, this); // Backup series for filtering.\n\n      if (mainType === 'series') {\n        createSeriesIndices(this, componentsMap.get('series'));\n      }\n    }\n\n    this._seriesIndicesMap = createHashMap(this._seriesIndices = this._seriesIndices || []);\n  },\n\n  /**\n   * Get option for output (cloned option and inner info removed)\n   * @public\n   * @return {Object}\n   */\n  getOption: function () {\n    var option = clone(this.option);\n    each(option, function (opts, mainType) {\n      if (ComponentModel.hasClass(mainType)) {\n        var opts = modelUtil.normalizeToArray(opts);\n\n        for (var i = opts.length - 1; i >= 0; i--) {\n          // Remove options with inner id.\n          if (modelUtil.isIdInner(opts[i])) {\n            opts.splice(i, 1);\n          }\n        }\n\n        option[mainType] = opts;\n      }\n    });\n    delete option[OPTION_INNER_KEY];\n    return option;\n  },\n\n  /**\n   * @return {module:echarts/model/Model}\n   */\n  getTheme: function () {\n    return this._theme;\n  },\n\n  /**\n   * @param {string} mainType\n   * @param {number} [idx=0]\n   * @return {module:echarts/model/Component}\n   */\n  getComponent: function (mainType, idx) {\n    var list = this._componentsMap.get(mainType);\n\n    if (list) {\n      return list[idx || 0];\n    }\n  },\n\n  /**\n   * If none of index and id and name used, return all components with mainType.\n   * @param {Object} condition\n   * @param {string} condition.mainType\n   * @param {string} [condition.subType] If ignore, only query by mainType\n   * @param {number|Array.<number>} [condition.index] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.id] Either input index or id or name.\n   * @param {string|Array.<string>} [condition.name] Either input index or id or name.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  queryComponents: function (condition) {\n    var mainType = condition.mainType;\n\n    if (!mainType) {\n      return [];\n    }\n\n    var index = condition.index;\n    var id = condition.id;\n    var name = condition.name;\n\n    var cpts = this._componentsMap.get(mainType);\n\n    if (!cpts || !cpts.length) {\n      return [];\n    }\n\n    var result;\n\n    if (index != null) {\n      if (!isArray(index)) {\n        index = [index];\n      }\n\n      result = filter(map(index, function (idx) {\n        return cpts[idx];\n      }), function (val) {\n        return !!val;\n      });\n    } else if (id != null) {\n      var isIdArray = isArray(id);\n      result = filter(cpts, function (cpt) {\n        return isIdArray && indexOf(id, cpt.id) >= 0 || !isIdArray && cpt.id === id;\n      });\n    } else if (name != null) {\n      var isNameArray = isArray(name);\n      result = filter(cpts, function (cpt) {\n        return isNameArray && indexOf(name, cpt.name) >= 0 || !isNameArray && cpt.name === name;\n      });\n    } else {\n      // Return all components with mainType\n      result = cpts.slice();\n    }\n\n    return filterBySubType(result, condition);\n  },\n\n  /**\n   * The interface is different from queryComponents,\n   * which is convenient for inner usage.\n   *\n   * @usage\n   * var result = findComponents(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}\n   * );\n   * var result = findComponents(\n   *     {mainType: 'series',\n   *     filter: function (model, index) {...}}\n   * );\n   * // result like [component0, componnet1, ...]\n   *\n   * @param {Object} condition\n   * @param {string} condition.mainType Mandatory.\n   * @param {string} [condition.subType] Optional.\n   * @param {Object} [condition.query] like {xxxIndex, xxxId, xxxName},\n   *        where xxx is mainType.\n   *        If query attribute is null/undefined or has no index/id/name,\n   *        do not filtering by query conditions, which is convenient for\n   *        no-payload situations or when target of action is global.\n   * @param {Function} [condition.filter] parameter: component, return boolean.\n   * @return {Array.<module:echarts/model/Component>}\n   */\n  findComponents: function (condition) {\n    var query = condition.query;\n    var mainType = condition.mainType;\n    var queryCond = getQueryCond(query);\n    var result = queryCond ? this.queryComponents(queryCond) : this._componentsMap.get(mainType);\n    return doFilter(filterBySubType(result, condition));\n\n    function getQueryCond(q) {\n      var indexAttr = mainType + 'Index';\n      var idAttr = mainType + 'Id';\n      var nameAttr = mainType + 'Name';\n      return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {\n        mainType: mainType,\n        // subType will be filtered finally.\n        index: q[indexAttr],\n        id: q[idAttr],\n        name: q[nameAttr]\n      } : null;\n    }\n\n    function doFilter(res) {\n      return condition.filter ? filter(res, condition.filter) : res;\n    }\n  },\n\n  /**\n   * @usage\n   * eachComponent('legend', function (legendModel, index) {\n   *     ...\n   * });\n   * eachComponent(function (componentType, model, index) {\n   *     // componentType does not include subType\n   *     // (componentType is 'xxx' but not 'xxx.aa')\n   * });\n   * eachComponent(\n   *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}},\n   *     function (model, index) {...}\n   * );\n   * eachComponent(\n   *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}},\n   *     function (model, index) {...}\n   * );\n   *\n   * @param {string|Object=} mainType When mainType is object, the definition\n   *                                  is the same as the method 'findComponents'.\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachComponent: function (mainType, cb, context) {\n    var componentsMap = this._componentsMap;\n\n    if (typeof mainType === 'function') {\n      context = cb;\n      cb = mainType;\n      componentsMap.each(function (components, componentType) {\n        each(components, function (component, index) {\n          cb.call(context, componentType, component, index);\n        });\n      });\n    } else if (isString(mainType)) {\n      each(componentsMap.get(mainType), cb, context);\n    } else if (isObject(mainType)) {\n      var queryResult = this.findComponents(mainType);\n      each(queryResult, cb, context);\n    }\n  },\n\n  /**\n   * @param {string} name\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByName: function (name) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.name === name;\n    });\n  },\n\n  /**\n   * @param {number} seriesIndex\n   * @return {module:echarts/model/Series}\n   */\n  getSeriesByIndex: function (seriesIndex) {\n    return this._componentsMap.get('series')[seriesIndex];\n  },\n\n  /**\n   * Get series list before filtered by type.\n   * FIXME: rename to getRawSeriesByType?\n   *\n   * @param {string} subType\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeriesByType: function (subType) {\n    var series = this._componentsMap.get('series');\n\n    return filter(series, function (oneSeries) {\n      return oneSeries.subType === subType;\n    });\n  },\n\n  /**\n   * @return {Array.<module:echarts/model/Series>}\n   */\n  getSeries: function () {\n    return this._componentsMap.get('series').slice();\n  },\n\n  /**\n   * @return {number}\n   */\n  getSeriesCount: function () {\n    return this._componentsMap.get('series').length;\n  },\n\n  /**\n   * After filtering, series may be different\n   * frome raw series.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      cb.call(context, series, rawSeriesIndex);\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered.\n   *\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeries: function (cb, context) {\n    each(this._componentsMap.get('series'), cb, context);\n  },\n\n  /**\n   * After filtering, series may be different.\n   * frome raw series.\n   *\n   * @param {string} subType.\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachSeriesByType: function (subType, cb, context) {\n    assertSeriesInitialized(this);\n    each(this._seriesIndices, function (rawSeriesIndex) {\n      var series = this._componentsMap.get('series')[rawSeriesIndex];\n\n      if (series.subType === subType) {\n        cb.call(context, series, rawSeriesIndex);\n      }\n    }, this);\n  },\n\n  /**\n   * Iterate raw series before filtered of given type.\n   *\n   * @parma {string} subType\n   * @param {Function} cb\n   * @param {*} context\n   */\n  eachRawSeriesByType: function (subType, cb, context) {\n    return each(this.getSeriesByType(subType), cb, context);\n  },\n\n  /**\n   * @param {module:echarts/model/Series} seriesModel\n   */\n  isSeriesFiltered: function (seriesModel) {\n    assertSeriesInitialized(this);\n    return this._seriesIndicesMap.get(seriesModel.componentIndex) == null;\n  },\n\n  /**\n   * @return {Array.<number>}\n   */\n  getCurrentSeriesIndices: function () {\n    return (this._seriesIndices || []).slice();\n  },\n\n  /**\n   * @param {Function} cb\n   * @param {*} context\n   */\n  filterSeries: function (cb, context) {\n    assertSeriesInitialized(this);\n    var filteredSeries = filter(this._componentsMap.get('series'), cb, context);\n    createSeriesIndices(this, filteredSeries);\n  },\n  restoreData: function (payload) {\n    var componentsMap = this._componentsMap;\n    createSeriesIndices(this, componentsMap.get('series'));\n    var componentTypes = [];\n    componentsMap.each(function (components, componentType) {\n      componentTypes.push(componentType);\n    });\n    ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType, dependencies) {\n      each(componentsMap.get(componentType), function (component) {\n        (componentType !== 'series' || !isNotTargetSeries(component, payload)) && component.restoreData();\n      });\n    });\n  }\n});\n\nfunction isNotTargetSeries(seriesModel, payload) {\n  if (payload) {\n    var index = payload.seiresIndex;\n    var id = payload.seriesId;\n    var name = payload.seriesName;\n    return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name != null && seriesModel.name !== name;\n  }\n}\n/**\n * @inner\n */\n\n\nfunction mergeTheme(option, theme) {\n  // PENDING\n  // NOT use `colorLayer` in theme if option has `color`\n  var notMergeColorLayer = option.color && !option.colorLayer;\n  each(theme, function (themeItem, name) {\n    if (name === 'colorLayer' && notMergeColorLayer) {\n      return;\n    } // 如果有 component model 则把具体的 merge 逻辑交给该 model 处理\n\n\n    if (!ComponentModel.hasClass(name)) {\n      if (typeof themeItem === 'object') {\n        option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false);\n      } else {\n        if (option[name] == null) {\n          option[name] = themeItem;\n        }\n      }\n    }\n  });\n}\n\nfunction initBase(baseOption) {\n  baseOption = baseOption; // Using OPTION_INNER_KEY to mark that this option can not be used outside,\n  // i.e. `chart.setOption(chart.getModel().option);` is forbiden.\n\n  this.option = {};\n  this.option[OPTION_INNER_KEY] = 1;\n  /**\n   * Init with series: [], in case of calling findSeries method\n   * before series initialized.\n   * @type {Object.<string, Array.<module:echarts/model/Model>>}\n   * @private\n   */\n\n  this._componentsMap = createHashMap({\n    series: []\n  });\n  /**\n   * Mapping between filtered series list and raw series list.\n   * key: filtered series indices, value: raw series indices.\n   * @type {Array.<nubmer>}\n   * @private\n   */\n\n  this._seriesIndices;\n  this._seriesIndicesMap;\n  mergeTheme(baseOption, this._theme.option); // TODO Needs clone when merging to the unexisted property\n\n  merge(baseOption, globalDefault, false);\n  this.mergeOption(baseOption);\n}\n/**\n * @inner\n * @param {Array.<string>|string} types model types\n * @return {Object} key: {string} type, value: {Array.<Object>} models\n */\n\n\nfunction getComponentsByTypes(componentsMap, types) {\n  if (!isArray(types)) {\n    types = types ? [types] : [];\n  }\n\n  var ret = {};\n  each(types, function (type) {\n    ret[type] = (componentsMap.get(type) || []).slice();\n  });\n  return ret;\n}\n/**\n * @inner\n */\n\n\nfunction determineSubType(mainType, newCptOption, existComponent) {\n  var subType = newCptOption.type ? newCptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.\n  : ComponentModel.determineSubType(mainType, newCptOption); // tooltip, markline, markpoint may always has no subType\n\n  return subType;\n}\n/**\n * @inner\n */\n\n\nfunction createSeriesIndices(ecModel, seriesModels) {\n  ecModel._seriesIndicesMap = createHashMap(ecModel._seriesIndices = map(seriesModels, function (series) {\n    return series.componentIndex;\n  }) || []);\n}\n/**\n * @inner\n */\n\n\nfunction filterBySubType(components, condition) {\n  // Using hasOwnProperty for restrict. Consider\n  // subType is undefined in user payload.\n  return condition.hasOwnProperty('subType') ? filter(components, function (cpt) {\n    return cpt.subType === condition.subType;\n  }) : components;\n}\n/**\n * @inner\n */\n\n\nfunction assertSeriesInitialized(ecModel) {}\n\nmixin(GlobalModel, colorPaletteMixin);\nvar _default = GlobalModel;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}