{"ast":null,"code":"var _core = require(\"./core\");\n\nvar createElement = _core.createElement;\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar matrix = require(\"../core/matrix\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"../graphic/helper/text\");\n\nvar Text = require(\"../graphic/Text\"); // TODO\n// 1. shadow\n// 2. Image: sx, sy, sw, sh\n\n\nvar CMD = PathProxy.CMD;\nvar arrayJoin = Array.prototype.join;\nvar NONE = 'none';\nvar mathRound = Math.round;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\nvar PI2 = Math.PI * 2;\nvar degree = 180 / PI;\nvar EPSILON = 1e-4;\n\nfunction round4(val) {\n  return mathRound(val * 1e4) / 1e4;\n}\n\nfunction isAroundZero(val) {\n  return val < EPSILON && val > -EPSILON;\n}\n\nfunction pathHasFill(style, isText) {\n  var fill = isText ? style.textFill : style.fill;\n  return fill != null && fill !== NONE;\n}\n\nfunction pathHasStroke(style, isText) {\n  var stroke = isText ? style.textStroke : style.stroke;\n  return stroke != null && stroke !== NONE;\n}\n\nfunction setTransform(svgEl, m) {\n  if (m) {\n    attr(svgEl, 'transform', 'matrix(' + arrayJoin.call(m, ',') + ')');\n  }\n}\n\nfunction attr(el, key, val) {\n  if (!val || val.type !== 'linear' && val.type !== 'radial') {\n    // Don't set attribute for gradient, since it need new dom nodes\n    el.setAttribute(key, val);\n  }\n}\n\nfunction attrXLink(el, key, val) {\n  el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);\n}\n\nfunction bindStyle(svgEl, style, isText, el) {\n  if (pathHasFill(style, isText)) {\n    var fill = isText ? style.textFill : style.fill;\n    fill = fill === 'transparent' ? NONE : fill;\n    attr(svgEl, 'fill', fill);\n    attr(svgEl, 'fill-opacity', style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);\n  } else {\n    attr(svgEl, 'fill', NONE);\n  }\n\n  if (pathHasStroke(style, isText)) {\n    var stroke = isText ? style.textStroke : style.stroke;\n    stroke = stroke === 'transparent' ? NONE : stroke;\n    attr(svgEl, 'stroke', stroke);\n    var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;\n    var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;\n    attr(svgEl, 'stroke-width', strokeWidth / strokeScale); // stroke then fill for text; fill then stroke for others\n\n    attr(svgEl, 'paint-order', isText ? 'stroke' : 'fill');\n    attr(svgEl, 'stroke-opacity', style.strokeOpacity != null ? style.strokeOpacity : style.opacity);\n    var lineDash = style.lineDash;\n\n    if (lineDash) {\n      attr(svgEl, 'stroke-dasharray', style.lineDash.join(','));\n      attr(svgEl, 'stroke-dashoffset', mathRound(style.lineDashOffset || 0));\n    } else {\n      attr(svgEl, 'stroke-dasharray', '');\n    } // PENDING\n\n\n    style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);\n    style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);\n    style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit);\n  } else {\n    attr(svgEl, 'stroke', NONE);\n  }\n}\n/***************************************************\n * PATH\n **************************************************/\n\n\nfunction pathDataToString(path) {\n  var str = [];\n  var data = path.data;\n  var dataLength = path.len();\n\n  for (var i = 0; i < dataLength;) {\n    var cmd = data[i++];\n    var cmdStr = '';\n    var nData = 0;\n\n    switch (cmd) {\n      case CMD.M:\n        cmdStr = 'M';\n        nData = 2;\n        break;\n\n      case CMD.L:\n        cmdStr = 'L';\n        nData = 2;\n        break;\n\n      case CMD.Q:\n        cmdStr = 'Q';\n        nData = 4;\n        break;\n\n      case CMD.C:\n        cmdStr = 'C';\n        nData = 6;\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++];\n        var psi = data[i++];\n        var clockwise = data[i++];\n        var dThetaPositive = Math.abs(dTheta);\n        var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2); // Mapping to 0~2PI\n\n        var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;\n        var large = false;\n\n        if (isCircle) {\n          large = true;\n        } else if (isAroundZero(dThetaPositive)) {\n          large = false;\n        } else {\n          large = unifiedTheta >= PI === !!clockwise;\n        }\n\n        var x0 = round4(cx + rx * mathCos(theta));\n        var y0 = round4(cy + ry * mathSin(theta)); // It will not draw if start point and end point are exactly the same\n        // We need to shift the end point with a small value\n        // FIXME A better way to draw circle ?\n\n        if (isCircle) {\n          if (clockwise) {\n            dTheta = PI2 - 1e-4;\n          } else {\n            dTheta = -PI2 + 1e-4;\n          }\n\n          large = true;\n\n          if (i === 9) {\n            // Move to (x0, y0) only when CMD.A comes at the\n            // first position of a shape.\n            // For instance, when drawing a ring, CMD.A comes\n            // after CMD.M, so it's unnecessary to move to\n            // (x0, y0).\n            str.push('M', x0, y0);\n          }\n        }\n\n        var x = round4(cx + rx * mathCos(theta + dTheta));\n        var y = round4(cy + ry * mathSin(theta + dTheta)); // FIXME Ellipse\n\n        str.push('A', round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);\n        break;\n\n      case CMD.Z:\n        cmdStr = 'Z';\n        break;\n\n      case CMD.R:\n        var x = round4(data[i++]);\n        var y = round4(data[i++]);\n        var w = round4(data[i++]);\n        var h = round4(data[i++]);\n        str.push('M', x, y, 'L', x + w, y, 'L', x + w, y + h, 'L', x, y + h, 'L', x, y);\n        break;\n    }\n\n    cmdStr && str.push(cmdStr);\n\n    for (var j = 0; j < nData; j++) {\n      // PENDING With scale\n      str.push(round4(data[i++]));\n    }\n  }\n\n  return str.join(' ');\n}\n\nvar svgPath = {};\n\nsvgPath.brush = function (el) {\n  var style = el.style;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('path');\n    el.__svgEl = svgEl;\n  }\n\n  if (!el.path) {\n    el.createPathProxy();\n  }\n\n  var path = el.path;\n\n  if (el.__dirtyPath) {\n    path.beginPath();\n    path.subPixelOptimize = false;\n    el.buildPath(path, el.shape);\n    el.__dirtyPath = false;\n    var pathStr = pathDataToString(path);\n\n    if (pathStr.indexOf('NaN') < 0) {\n      // Ignore illegal path, which may happen such in out-of-range\n      // data in Calendar series.\n      attr(svgEl, 'd', pathStr);\n    }\n  }\n\n  bindStyle(svgEl, style, false, el);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/***************************************************\n * IMAGE\n **************************************************/\n\n\nvar svgImage = {};\n\nsvgImage.brush = function (el) {\n  var style = el.style;\n  var image = style.image;\n\n  if (image instanceof HTMLImageElement) {\n    var src = image.src;\n    image = src;\n  }\n\n  if (!image) {\n    return;\n  }\n\n  var x = style.x || 0;\n  var y = style.y || 0;\n  var dw = style.width;\n  var dh = style.height;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('image');\n    el.__svgEl = svgEl;\n  }\n\n  if (image !== el.__imageSrc) {\n    attrXLink(svgEl, 'href', image); // Caching image src\n\n    el.__imageSrc = image;\n  }\n\n  attr(svgEl, 'width', dw);\n  attr(svgEl, 'height', dh);\n  attr(svgEl, 'x', x);\n  attr(svgEl, 'y', y);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/***************************************************\n * TEXT\n **************************************************/\n\n\nvar svgText = {};\n\nvar _tmpTextHostRect = new BoundingRect();\n\nvar _tmpTextBoxPos = {};\nvar _tmpTextTransform = [];\nvar TEXT_ALIGN_TO_ANCHRO = {\n  left: 'start',\n  right: 'end',\n  center: 'middle',\n  middle: 'middle'\n};\n/**\n * @param {module:zrender/Element} el\n * @param {Object|boolean} [hostRect] {x, y, width, height}\n *        If set false, rect text is not used.\n */\n\nvar svgTextDrawRectText = function (el, hostRect) {\n  var style = el.style;\n  var elTransform = el.transform;\n  var needTransformTextByHostEl = el instanceof Text || style.transformText;\n  el.__dirty && textHelper.normalizeTextStyle(style, true);\n  var text = style.text; // Convert to string\n\n  text != null && (text += '');\n\n  if (!textHelper.needDrawText(text, style)) {\n    return;\n  } // render empty text for svg if no text but need draw text.\n\n\n  text == null && (text = ''); // Follow the setting in the canvas renderer, if not transform the\n  // text, transform the hostRect, by which the text is located.\n\n  if (!needTransformTextByHostEl && elTransform) {\n    _tmpTextHostRect.copy(hostRect);\n\n    _tmpTextHostRect.applyTransform(elTransform);\n\n    hostRect = _tmpTextHostRect;\n  }\n\n  var textSvgEl = el.__textSvgEl;\n\n  if (!textSvgEl) {\n    textSvgEl = createElement('text');\n    el.__textSvgEl = textSvgEl;\n  } // style.font has been normalized by `normalizeTextStyle`.\n\n\n  var textSvgElStyle = textSvgEl.style;\n  var font = style.font || textContain.DEFAULT_FONT;\n  var computedFont = textSvgEl.__computedFont;\n\n  if (font !== textSvgEl.__styleFont) {\n    textSvgElStyle.font = textSvgEl.__styleFont = font; // The computedFont might not be the orginal font if it is illegal font.\n\n    computedFont = textSvgEl.__computedFont = textSvgElStyle.font;\n  }\n\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = el.__textCotentBlock;\n\n  if (!contentBlock || el.__dirtyText) {\n    contentBlock = el.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var lineHeight = contentBlock.lineHeight;\n  textHelper.getBoxPosition(_tmpTextBoxPos, el, style, hostRect);\n  var baseX = _tmpTextBoxPos.baseX;\n  var baseY = _tmpTextBoxPos.baseY;\n  var textAlign = _tmpTextBoxPos.textAlign || 'left';\n  var textVerticalAlign = _tmpTextBoxPos.textVerticalAlign;\n  setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY; // TODO needDrawBg\n\n  if (textPadding) {\n    textX = getTextXForPadding(baseX, textAlign, textPadding);\n    textY += textPadding[0];\n  } // `textBaseline` is set as 'middle'.\n\n\n  textY += lineHeight / 2;\n  bindStyle(textSvgEl, style, true, el); // FIXME\n  // Add a <style> to reset all of the text font as inherit?\n  // otherwise the outer <style> may set the unexpected style.\n  // Font may affect position of each tspan elements\n\n  var canCacheByTextString = contentBlock.canCacheByTextString;\n  var tspanList = el.__tspanList || (el.__tspanList = []);\n  var tspanOriginLen = tspanList.length; // Optimize for most cases, just compare text string to determine change.\n\n  if (canCacheByTextString && el.__canCacheByTextString && el.__text === text) {\n    if (el.__dirtyText && tspanOriginLen) {\n      for (var idx = 0; idx < tspanOriginLen; ++idx) {\n        updateTextLocation(tspanList[idx], textAlign, textX, textY + idx * lineHeight);\n      }\n    }\n  } else {\n    el.__text = text;\n    el.__canCacheByTextString = canCacheByTextString;\n    var textLines = contentBlock.lines;\n    var nTextLines = textLines.length;\n    var idx = 0;\n\n    for (; idx < nTextLines; idx++) {\n      // Using cached tspan elements\n      var tspan = tspanList[idx];\n      var singleLineText = textLines[idx];\n\n      if (!tspan) {\n        tspan = tspanList[idx] = createElement('tspan');\n        textSvgEl.appendChild(tspan);\n        tspan.appendChild(document.createTextNode(singleLineText));\n      } else if (tspan.__zrText !== singleLineText) {\n        tspan.innerHTML = '';\n        tspan.appendChild(document.createTextNode(singleLineText));\n      }\n\n      updateTextLocation(tspan, textAlign, textX, textY + idx * lineHeight);\n    } // Remove unused tspan elements\n\n\n    if (tspanOriginLen > nTextLines) {\n      for (; idx < tspanOriginLen; idx++) {\n        textSvgEl.removeChild(tspanList[idx]);\n      }\n\n      tspanList.length = nTextLines;\n    }\n  }\n};\n\nfunction setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY) {\n  matrix.identity(_tmpTextTransform);\n\n  if (needTransformTextByHostEl && elTransform) {\n    matrix.copy(_tmpTextTransform, elTransform);\n  } // textRotation only apply in RectText.\n\n\n  var textRotation = style.textRotation;\n\n  if (hostRect && textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      baseX = hostRect.width / 2 + hostRect.x;\n      baseY = hostRect.height / 2 + hostRect.y;\n    } else if (origin) {\n      baseX = origin[0] + hostRect.x;\n      baseY = origin[1] + hostRect.y;\n    }\n\n    _tmpTextTransform[4] -= baseX;\n    _tmpTextTransform[5] -= baseY; // Positive: anticlockwise\n\n    matrix.rotate(_tmpTextTransform, _tmpTextTransform, textRotation);\n    _tmpTextTransform[4] += baseX;\n    _tmpTextTransform[5] += baseY;\n  } // See the definition in `Style.js#textOrigin`, the default\n  // origin is from the result of `getBoxPosition`.\n\n\n  setTransform(textSvgEl, _tmpTextTransform);\n} // FIXME merge the same code with `helper/text.js#getTextXForPadding`;\n\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n\nfunction updateTextLocation(tspan, textAlign, x, y) {\n  // Consider different font display differently in vertial align, we always\n  // set vertialAlign as 'middle', and use 'y' to locate text vertically.\n  attr(tspan, 'dominant-baseline', 'middle');\n  attr(tspan, 'text-anchor', TEXT_ALIGN_TO_ANCHRO[textAlign]);\n  attr(tspan, 'x', x);\n  attr(tspan, 'y', y);\n}\n\nfunction removeOldTextNode(el) {\n  if (el && el.__textSvgEl) {\n    // textSvgEl may has no parentNode if el has been removed temporary.\n    if (el.__textSvgEl.parentNode) {\n      el.__textSvgEl.parentNode.removeChild(el.__textSvgEl);\n    }\n\n    el.__textSvgEl = null;\n    el.__tspanList = [];\n    el.__text = null;\n  }\n}\n\nsvgText.drawRectText = svgTextDrawRectText;\n\nsvgText.brush = function (el) {\n  var style = el.style;\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, false);\n  } else {\n    removeOldTextNode(el);\n  }\n};\n\nexports.path = svgPath;\nexports.image = svgImage;\nexports.text = svgText;","map":{"version":3,"names":["_core","require","createElement","PathProxy","BoundingRect","matrix","textContain","textHelper","Text","CMD","arrayJoin","Array","prototype","join","NONE","mathRound","Math","round","mathSin","sin","mathCos","cos","PI","PI2","degree","EPSILON","round4","val","isAroundZero","pathHasFill","style","isText","fill","textFill","pathHasStroke","stroke","textStroke","setTransform","svgEl","m","attr","call","el","key","type","setAttribute","attrXLink","setAttributeNS","bindStyle","fillOpacity","opacity","strokeWidth","textStrokeWidth","lineWidth","strokeScale","strokeNoScale","getLineScale","strokeOpacity","lineDash","lineDashOffset","lineCap","lineJoin","miterLimit","pathDataToString","path","str","data","dataLength","len","i","cmd","cmdStr","nData","M","L","Q","C","A","cx","cy","rx","ry","theta","dTheta","psi","clockwise","dThetaPositive","abs","isCircle","unifiedTheta","large","x0","y0","push","x","y","Z","R","w","h","j","svgPath","brush","__svgEl","createPathProxy","__dirtyPath","beginPath","subPixelOptimize","buildPath","shape","pathStr","indexOf","transform","text","svgTextDrawRectText","getBoundingRect","removeOldTextNode","svgImage","image","HTMLImageElement","src","dw","width","dh","height","__imageSrc","svgText","_tmpTextHostRect","_tmpTextBoxPos","_tmpTextTransform","TEXT_ALIGN_TO_ANCHRO","left","right","center","middle","hostRect","elTransform","needTransformTextByHostEl","transformText","__dirty","normalizeTextStyle","needDrawText","copy","applyTransform","textSvgEl","__textSvgEl","textSvgElStyle","font","DEFAULT_FONT","computedFont","__computedFont","__styleFont","textPadding","textLineHeight","contentBlock","__textCotentBlock","__dirtyText","parsePlainText","truncate","outerHeight","lineHeight","getBoxPosition","baseX","baseY","textAlign","textVerticalAlign","setTextTransform","boxY","adjustTextY","textX","textY","getTextXForPadding","canCacheByTextString","tspanList","__tspanList","tspanOriginLen","length","__canCacheByTextString","__text","idx","updateTextLocation","textLines","lines","nTextLines","tspan","singleLineText","appendChild","document","createTextNode","__zrText","innerHTML","removeChild","identity","textRotation","origin","textOrigin","rotate","parentNode","drawRectText","exports"],"sources":["D:/Desktop/project/app/node_modules/zrender/lib/svg/graphic.js"],"sourcesContent":["var _core = require(\"./core\");\n\nvar createElement = _core.createElement;\n\nvar PathProxy = require(\"../core/PathProxy\");\n\nvar BoundingRect = require(\"../core/BoundingRect\");\n\nvar matrix = require(\"../core/matrix\");\n\nvar textContain = require(\"../contain/text\");\n\nvar textHelper = require(\"../graphic/helper/text\");\n\nvar Text = require(\"../graphic/Text\");\n\n// TODO\n// 1. shadow\n// 2. Image: sx, sy, sw, sh\nvar CMD = PathProxy.CMD;\nvar arrayJoin = Array.prototype.join;\nvar NONE = 'none';\nvar mathRound = Math.round;\nvar mathSin = Math.sin;\nvar mathCos = Math.cos;\nvar PI = Math.PI;\nvar PI2 = Math.PI * 2;\nvar degree = 180 / PI;\nvar EPSILON = 1e-4;\n\nfunction round4(val) {\n  return mathRound(val * 1e4) / 1e4;\n}\n\nfunction isAroundZero(val) {\n  return val < EPSILON && val > -EPSILON;\n}\n\nfunction pathHasFill(style, isText) {\n  var fill = isText ? style.textFill : style.fill;\n  return fill != null && fill !== NONE;\n}\n\nfunction pathHasStroke(style, isText) {\n  var stroke = isText ? style.textStroke : style.stroke;\n  return stroke != null && stroke !== NONE;\n}\n\nfunction setTransform(svgEl, m) {\n  if (m) {\n    attr(svgEl, 'transform', 'matrix(' + arrayJoin.call(m, ',') + ')');\n  }\n}\n\nfunction attr(el, key, val) {\n  if (!val || val.type !== 'linear' && val.type !== 'radial') {\n    // Don't set attribute for gradient, since it need new dom nodes\n    el.setAttribute(key, val);\n  }\n}\n\nfunction attrXLink(el, key, val) {\n  el.setAttributeNS('http://www.w3.org/1999/xlink', key, val);\n}\n\nfunction bindStyle(svgEl, style, isText, el) {\n  if (pathHasFill(style, isText)) {\n    var fill = isText ? style.textFill : style.fill;\n    fill = fill === 'transparent' ? NONE : fill;\n    attr(svgEl, 'fill', fill);\n    attr(svgEl, 'fill-opacity', style.fillOpacity != null ? style.fillOpacity * style.opacity : style.opacity);\n  } else {\n    attr(svgEl, 'fill', NONE);\n  }\n\n  if (pathHasStroke(style, isText)) {\n    var stroke = isText ? style.textStroke : style.stroke;\n    stroke = stroke === 'transparent' ? NONE : stroke;\n    attr(svgEl, 'stroke', stroke);\n    var strokeWidth = isText ? style.textStrokeWidth : style.lineWidth;\n    var strokeScale = !isText && style.strokeNoScale ? el.getLineScale() : 1;\n    attr(svgEl, 'stroke-width', strokeWidth / strokeScale); // stroke then fill for text; fill then stroke for others\n\n    attr(svgEl, 'paint-order', isText ? 'stroke' : 'fill');\n    attr(svgEl, 'stroke-opacity', style.strokeOpacity != null ? style.strokeOpacity : style.opacity);\n    var lineDash = style.lineDash;\n\n    if (lineDash) {\n      attr(svgEl, 'stroke-dasharray', style.lineDash.join(','));\n      attr(svgEl, 'stroke-dashoffset', mathRound(style.lineDashOffset || 0));\n    } else {\n      attr(svgEl, 'stroke-dasharray', '');\n    } // PENDING\n\n\n    style.lineCap && attr(svgEl, 'stroke-linecap', style.lineCap);\n    style.lineJoin && attr(svgEl, 'stroke-linejoin', style.lineJoin);\n    style.miterLimit && attr(svgEl, 'stroke-miterlimit', style.miterLimit);\n  } else {\n    attr(svgEl, 'stroke', NONE);\n  }\n}\n/***************************************************\n * PATH\n **************************************************/\n\n\nfunction pathDataToString(path) {\n  var str = [];\n  var data = path.data;\n  var dataLength = path.len();\n\n  for (var i = 0; i < dataLength;) {\n    var cmd = data[i++];\n    var cmdStr = '';\n    var nData = 0;\n\n    switch (cmd) {\n      case CMD.M:\n        cmdStr = 'M';\n        nData = 2;\n        break;\n\n      case CMD.L:\n        cmdStr = 'L';\n        nData = 2;\n        break;\n\n      case CMD.Q:\n        cmdStr = 'Q';\n        nData = 4;\n        break;\n\n      case CMD.C:\n        cmdStr = 'C';\n        nData = 6;\n        break;\n\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var theta = data[i++];\n        var dTheta = data[i++];\n        var psi = data[i++];\n        var clockwise = data[i++];\n        var dThetaPositive = Math.abs(dTheta);\n        var isCircle = isAroundZero(dThetaPositive - PI2) || (clockwise ? dTheta >= PI2 : -dTheta >= PI2); // Mapping to 0~2PI\n\n        var unifiedTheta = dTheta > 0 ? dTheta % PI2 : dTheta % PI2 + PI2;\n        var large = false;\n\n        if (isCircle) {\n          large = true;\n        } else if (isAroundZero(dThetaPositive)) {\n          large = false;\n        } else {\n          large = unifiedTheta >= PI === !!clockwise;\n        }\n\n        var x0 = round4(cx + rx * mathCos(theta));\n        var y0 = round4(cy + ry * mathSin(theta)); // It will not draw if start point and end point are exactly the same\n        // We need to shift the end point with a small value\n        // FIXME A better way to draw circle ?\n\n        if (isCircle) {\n          if (clockwise) {\n            dTheta = PI2 - 1e-4;\n          } else {\n            dTheta = -PI2 + 1e-4;\n          }\n\n          large = true;\n\n          if (i === 9) {\n            // Move to (x0, y0) only when CMD.A comes at the\n            // first position of a shape.\n            // For instance, when drawing a ring, CMD.A comes\n            // after CMD.M, so it's unnecessary to move to\n            // (x0, y0).\n            str.push('M', x0, y0);\n          }\n        }\n\n        var x = round4(cx + rx * mathCos(theta + dTheta));\n        var y = round4(cy + ry * mathSin(theta + dTheta)); // FIXME Ellipse\n\n        str.push('A', round4(rx), round4(ry), mathRound(psi * degree), +large, +clockwise, x, y);\n        break;\n\n      case CMD.Z:\n        cmdStr = 'Z';\n        break;\n\n      case CMD.R:\n        var x = round4(data[i++]);\n        var y = round4(data[i++]);\n        var w = round4(data[i++]);\n        var h = round4(data[i++]);\n        str.push('M', x, y, 'L', x + w, y, 'L', x + w, y + h, 'L', x, y + h, 'L', x, y);\n        break;\n    }\n\n    cmdStr && str.push(cmdStr);\n\n    for (var j = 0; j < nData; j++) {\n      // PENDING With scale\n      str.push(round4(data[i++]));\n    }\n  }\n\n  return str.join(' ');\n}\n\nvar svgPath = {};\n\nsvgPath.brush = function (el) {\n  var style = el.style;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('path');\n    el.__svgEl = svgEl;\n  }\n\n  if (!el.path) {\n    el.createPathProxy();\n  }\n\n  var path = el.path;\n\n  if (el.__dirtyPath) {\n    path.beginPath();\n    path.subPixelOptimize = false;\n    el.buildPath(path, el.shape);\n    el.__dirtyPath = false;\n    var pathStr = pathDataToString(path);\n\n    if (pathStr.indexOf('NaN') < 0) {\n      // Ignore illegal path, which may happen such in out-of-range\n      // data in Calendar series.\n      attr(svgEl, 'd', pathStr);\n    }\n  }\n\n  bindStyle(svgEl, style, false, el);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/***************************************************\n * IMAGE\n **************************************************/\n\n\nvar svgImage = {};\n\nsvgImage.brush = function (el) {\n  var style = el.style;\n  var image = style.image;\n\n  if (image instanceof HTMLImageElement) {\n    var src = image.src;\n    image = src;\n  }\n\n  if (!image) {\n    return;\n  }\n\n  var x = style.x || 0;\n  var y = style.y || 0;\n  var dw = style.width;\n  var dh = style.height;\n  var svgEl = el.__svgEl;\n\n  if (!svgEl) {\n    svgEl = createElement('image');\n    el.__svgEl = svgEl;\n  }\n\n  if (image !== el.__imageSrc) {\n    attrXLink(svgEl, 'href', image); // Caching image src\n\n    el.__imageSrc = image;\n  }\n\n  attr(svgEl, 'width', dw);\n  attr(svgEl, 'height', dh);\n  attr(svgEl, 'x', x);\n  attr(svgEl, 'y', y);\n  setTransform(svgEl, el.transform);\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, el.getBoundingRect());\n  } else {\n    removeOldTextNode(el);\n  }\n};\n/***************************************************\n * TEXT\n **************************************************/\n\n\nvar svgText = {};\n\nvar _tmpTextHostRect = new BoundingRect();\n\nvar _tmpTextBoxPos = {};\nvar _tmpTextTransform = [];\nvar TEXT_ALIGN_TO_ANCHRO = {\n  left: 'start',\n  right: 'end',\n  center: 'middle',\n  middle: 'middle'\n};\n/**\n * @param {module:zrender/Element} el\n * @param {Object|boolean} [hostRect] {x, y, width, height}\n *        If set false, rect text is not used.\n */\n\nvar svgTextDrawRectText = function (el, hostRect) {\n  var style = el.style;\n  var elTransform = el.transform;\n  var needTransformTextByHostEl = el instanceof Text || style.transformText;\n  el.__dirty && textHelper.normalizeTextStyle(style, true);\n  var text = style.text; // Convert to string\n\n  text != null && (text += '');\n\n  if (!textHelper.needDrawText(text, style)) {\n    return;\n  } // render empty text for svg if no text but need draw text.\n\n\n  text == null && (text = ''); // Follow the setting in the canvas renderer, if not transform the\n  // text, transform the hostRect, by which the text is located.\n\n  if (!needTransformTextByHostEl && elTransform) {\n    _tmpTextHostRect.copy(hostRect);\n\n    _tmpTextHostRect.applyTransform(elTransform);\n\n    hostRect = _tmpTextHostRect;\n  }\n\n  var textSvgEl = el.__textSvgEl;\n\n  if (!textSvgEl) {\n    textSvgEl = createElement('text');\n    el.__textSvgEl = textSvgEl;\n  } // style.font has been normalized by `normalizeTextStyle`.\n\n\n  var textSvgElStyle = textSvgEl.style;\n  var font = style.font || textContain.DEFAULT_FONT;\n  var computedFont = textSvgEl.__computedFont;\n\n  if (font !== textSvgEl.__styleFont) {\n    textSvgElStyle.font = textSvgEl.__styleFont = font; // The computedFont might not be the orginal font if it is illegal font.\n\n    computedFont = textSvgEl.__computedFont = textSvgElStyle.font;\n  }\n\n  var textPadding = style.textPadding;\n  var textLineHeight = style.textLineHeight;\n  var contentBlock = el.__textCotentBlock;\n\n  if (!contentBlock || el.__dirtyText) {\n    contentBlock = el.__textCotentBlock = textContain.parsePlainText(text, computedFont, textPadding, textLineHeight, style.truncate);\n  }\n\n  var outerHeight = contentBlock.outerHeight;\n  var lineHeight = contentBlock.lineHeight;\n  textHelper.getBoxPosition(_tmpTextBoxPos, el, style, hostRect);\n  var baseX = _tmpTextBoxPos.baseX;\n  var baseY = _tmpTextBoxPos.baseY;\n  var textAlign = _tmpTextBoxPos.textAlign || 'left';\n  var textVerticalAlign = _tmpTextBoxPos.textVerticalAlign;\n  setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY);\n  var boxY = textContain.adjustTextY(baseY, outerHeight, textVerticalAlign);\n  var textX = baseX;\n  var textY = boxY; // TODO needDrawBg\n\n  if (textPadding) {\n    textX = getTextXForPadding(baseX, textAlign, textPadding);\n    textY += textPadding[0];\n  } // `textBaseline` is set as 'middle'.\n\n\n  textY += lineHeight / 2;\n  bindStyle(textSvgEl, style, true, el); // FIXME\n  // Add a <style> to reset all of the text font as inherit?\n  // otherwise the outer <style> may set the unexpected style.\n  // Font may affect position of each tspan elements\n\n  var canCacheByTextString = contentBlock.canCacheByTextString;\n  var tspanList = el.__tspanList || (el.__tspanList = []);\n  var tspanOriginLen = tspanList.length; // Optimize for most cases, just compare text string to determine change.\n\n  if (canCacheByTextString && el.__canCacheByTextString && el.__text === text) {\n    if (el.__dirtyText && tspanOriginLen) {\n      for (var idx = 0; idx < tspanOriginLen; ++idx) {\n        updateTextLocation(tspanList[idx], textAlign, textX, textY + idx * lineHeight);\n      }\n    }\n  } else {\n    el.__text = text;\n    el.__canCacheByTextString = canCacheByTextString;\n    var textLines = contentBlock.lines;\n    var nTextLines = textLines.length;\n    var idx = 0;\n\n    for (; idx < nTextLines; idx++) {\n      // Using cached tspan elements\n      var tspan = tspanList[idx];\n      var singleLineText = textLines[idx];\n\n      if (!tspan) {\n        tspan = tspanList[idx] = createElement('tspan');\n        textSvgEl.appendChild(tspan);\n        tspan.appendChild(document.createTextNode(singleLineText));\n      } else if (tspan.__zrText !== singleLineText) {\n        tspan.innerHTML = '';\n        tspan.appendChild(document.createTextNode(singleLineText));\n      }\n\n      updateTextLocation(tspan, textAlign, textX, textY + idx * lineHeight);\n    } // Remove unused tspan elements\n\n\n    if (tspanOriginLen > nTextLines) {\n      for (; idx < tspanOriginLen; idx++) {\n        textSvgEl.removeChild(tspanList[idx]);\n      }\n\n      tspanList.length = nTextLines;\n    }\n  }\n};\n\nfunction setTextTransform(textSvgEl, needTransformTextByHostEl, elTransform, style, hostRect, baseX, baseY) {\n  matrix.identity(_tmpTextTransform);\n\n  if (needTransformTextByHostEl && elTransform) {\n    matrix.copy(_tmpTextTransform, elTransform);\n  } // textRotation only apply in RectText.\n\n\n  var textRotation = style.textRotation;\n\n  if (hostRect && textRotation) {\n    var origin = style.textOrigin;\n\n    if (origin === 'center') {\n      baseX = hostRect.width / 2 + hostRect.x;\n      baseY = hostRect.height / 2 + hostRect.y;\n    } else if (origin) {\n      baseX = origin[0] + hostRect.x;\n      baseY = origin[1] + hostRect.y;\n    }\n\n    _tmpTextTransform[4] -= baseX;\n    _tmpTextTransform[5] -= baseY; // Positive: anticlockwise\n\n    matrix.rotate(_tmpTextTransform, _tmpTextTransform, textRotation);\n    _tmpTextTransform[4] += baseX;\n    _tmpTextTransform[5] += baseY;\n  } // See the definition in `Style.js#textOrigin`, the default\n  // origin is from the result of `getBoxPosition`.\n\n\n  setTransform(textSvgEl, _tmpTextTransform);\n} // FIXME merge the same code with `helper/text.js#getTextXForPadding`;\n\n\nfunction getTextXForPadding(x, textAlign, textPadding) {\n  return textAlign === 'right' ? x - textPadding[1] : textAlign === 'center' ? x + textPadding[3] / 2 - textPadding[1] / 2 : x + textPadding[3];\n}\n\nfunction updateTextLocation(tspan, textAlign, x, y) {\n  // Consider different font display differently in vertial align, we always\n  // set vertialAlign as 'middle', and use 'y' to locate text vertically.\n  attr(tspan, 'dominant-baseline', 'middle');\n  attr(tspan, 'text-anchor', TEXT_ALIGN_TO_ANCHRO[textAlign]);\n  attr(tspan, 'x', x);\n  attr(tspan, 'y', y);\n}\n\nfunction removeOldTextNode(el) {\n  if (el && el.__textSvgEl) {\n    // textSvgEl may has no parentNode if el has been removed temporary.\n    if (el.__textSvgEl.parentNode) {\n      el.__textSvgEl.parentNode.removeChild(el.__textSvgEl);\n    }\n\n    el.__textSvgEl = null;\n    el.__tspanList = [];\n    el.__text = null;\n  }\n}\n\nsvgText.drawRectText = svgTextDrawRectText;\n\nsvgText.brush = function (el) {\n  var style = el.style;\n\n  if (style.text != null) {\n    svgTextDrawRectText(el, false);\n  } else {\n    removeOldTextNode(el);\n  }\n};\n\nexports.path = svgPath;\nexports.image = svgImage;\nexports.text = svgText;"],"mappings":"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"},"metadata":{},"sourceType":"script"}