{"ast":null,"code":"var Animator = require(\"../animation/Animator\");\n\nvar logError = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n/**\n * @alias module:zrender/mixin/Animatable\n * @constructor\n */\n\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      logError('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    animateTo(this, target, time, delay, easing, callback, forceAnimate);\n  },\n\n  /**\n   * Animate from the target state to current state.\n   * The params and the return value are the same as `this.animateTo`.\n   */\n  animateFrom: function (target, time, delay, easing, callback, forceAnimate) {\n    animateTo(this, target, time, delay, easing, callback, forceAnimate, true);\n  }\n};\n\nfunction animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {\n  // animateTo(target, time, easing, callback);\n  if (isString(delay)) {\n    callback = easing;\n    easing = delay;\n    delay = 0;\n  } // animateTo(target, time, delay, callback);\n  else if (isFunction(easing)) {\n    callback = easing;\n    easing = 'linear';\n    delay = 0;\n  } // animateTo(target, time, callback);\n  else if (isFunction(delay)) {\n    callback = delay;\n    delay = 0;\n  } // animateTo(target, callback)\n  else if (isFunction(time)) {\n    callback = time;\n    time = 500;\n  } // animateTo(target)\n  else if (!time) {\n    time = 500;\n  } // Stop all previous animations\n\n\n  animatable.stopAnimation();\n  animateToShallow(animatable, '', animatable, target, time, delay, reverse); // Animators may be removed immediately after start\n  // if there is nothing to animate\n\n  var animators = animatable.animators.slice();\n  var count = animators.length;\n\n  function done() {\n    count--;\n\n    if (!count) {\n      callback && callback();\n    }\n  } // No animators. This should be checked before animators[i].start(),\n  // because 'done' may be executed immediately if no need to animate.\n\n\n  if (!count) {\n    callback && callback();\n  } // Start after all animators created\n  // Incase any animator is done immediately when all animation properties are not changed\n\n\n  for (var i = 0; i < animators.length; i++) {\n    animators[i].done(done).start(easing, forceAnimate);\n  }\n}\n/**\n * @param {string} path=''\n * @param {Object} source=animatable\n * @param {Object} target\n * @param {number} [time=500]\n * @param {number} [delay=0]\n * @param {boolean} [reverse] If `true`, animate\n *        from the `target` to current state.\n *\n * @example\n *  // Animate position\n *  el._animateToShallow({\n *      position: [10, 10]\n *  })\n *\n *  // Animate shape, style and position in 100ms, delayed 100ms\n *  el._animateToShallow({\n *      shape: {\n *          width: 500\n *      },\n *      style: {\n *          fill: 'red'\n *      }\n *      position: [10, 10]\n *  }, 100, 100)\n */\n\n\nfunction animateToShallow(animatable, path, source, target, time, delay, reverse) {\n  var objShallow = {};\n  var propertyCount = 0;\n\n  for (var name in target) {\n    if (!target.hasOwnProperty(name)) {\n      continue;\n    }\n\n    if (source[name] != null) {\n      if (isObject(target[name]) && !isArrayLike(target[name])) {\n        animateToShallow(animatable, path ? path + '.' + name : name, source[name], target[name], time, delay, reverse);\n      } else {\n        if (reverse) {\n          objShallow[name] = source[name];\n          setAttrByPath(animatable, path, name, target[name]);\n        } else {\n          objShallow[name] = target[name];\n        }\n\n        propertyCount++;\n      }\n    } else if (target[name] != null && !reverse) {\n      setAttrByPath(animatable, path, name, target[name]);\n    }\n  }\n\n  if (propertyCount > 0) {\n    animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n  }\n}\n\nfunction setAttrByPath(el, path, name, value) {\n  // Attr directly if not has property\n  // FIXME, if some property not needed for element ?\n  if (!path) {\n    el.attr(name, value);\n  } else {\n    // Only support set shape or style\n    var props = {};\n    props[path] = {};\n    props[path][name] = value;\n    el.attr(props);\n  }\n}\n\nvar _default = Animatable;\nmodule.exports = _default;","map":{"version":3,"names":["Animator","require","logError","_util","isString","isFunction","isObject","isArrayLike","indexOf","Animatable","animators","prototype","constructor","animate","path","loop","target","animatingShape","el","zr","__zr","pathSplitted","split","prop","i","l","length","id","animator","during","dirty","done","splice","push","animation","addAnimator","stopAnimation","forwardToLast","len","stop","animateTo","time","delay","easing","callback","forceAnimate","animateFrom","animatable","reverse","animateToShallow","slice","count","start","source","objShallow","propertyCount","name","hasOwnProperty","setAttrByPath","when","value","attr","props","_default","module","exports"],"sources":["D:/Desktop/project/project/project/app/node_modules/zrender/lib/mixin/Animatable.js"],"sourcesContent":["var Animator = require(\"../animation/Animator\");\n\nvar logError = require(\"../core/log\");\n\nvar _util = require(\"../core/util\");\n\nvar isString = _util.isString;\nvar isFunction = _util.isFunction;\nvar isObject = _util.isObject;\nvar isArrayLike = _util.isArrayLike;\nvar indexOf = _util.indexOf;\n\n/**\n * @alias module:zrender/mixin/Animatable\n * @constructor\n */\nvar Animatable = function () {\n  /**\n   * @type {Array.<module:zrender/animation/Animator>}\n   * @readOnly\n   */\n  this.animators = [];\n};\n\nAnimatable.prototype = {\n  constructor: Animatable,\n\n  /**\n   * 动画\n   *\n   * @param {string} path The path to fetch value from object, like 'a.b.c'.\n   * @param {boolean} [loop] Whether to loop animation.\n   * @return {module:zrender/animation/Animator}\n   * @example:\n   *     el.animate('style', false)\n   *         .when(1000, {x: 10} )\n   *         .done(function(){ // Animation done })\n   *         .start()\n   */\n  animate: function (path, loop) {\n    var target;\n    var animatingShape = false;\n    var el = this;\n    var zr = this.__zr;\n\n    if (path) {\n      var pathSplitted = path.split('.');\n      var prop = el; // If animating shape\n\n      animatingShape = pathSplitted[0] === 'shape';\n\n      for (var i = 0, l = pathSplitted.length; i < l; i++) {\n        if (!prop) {\n          continue;\n        }\n\n        prop = prop[pathSplitted[i]];\n      }\n\n      if (prop) {\n        target = prop;\n      }\n    } else {\n      target = el;\n    }\n\n    if (!target) {\n      logError('Property \"' + path + '\" is not existed in element ' + el.id);\n      return;\n    }\n\n    var animators = el.animators;\n    var animator = new Animator(target, loop);\n    animator.during(function (target) {\n      el.dirty(animatingShape);\n    }).done(function () {\n      // FIXME Animator will not be removed if use `Animator#stop` to stop animation\n      animators.splice(indexOf(animators, animator), 1);\n    });\n    animators.push(animator); // If animate after added to the zrender\n\n    if (zr) {\n      zr.animation.addAnimator(animator);\n    }\n\n    return animator;\n  },\n\n  /**\n   * 停止动画\n   * @param {boolean} forwardToLast If move to last frame before stop\n   */\n  stopAnimation: function (forwardToLast) {\n    var animators = this.animators;\n    var len = animators.length;\n\n    for (var i = 0; i < len; i++) {\n      animators[i].stop(forwardToLast);\n    }\n\n    animators.length = 0;\n    return this;\n  },\n\n  /**\n   * Caution: this method will stop previous animation.\n   * So do not use this method to one element twice before\n   * animation starts, unless you know what you are doing.\n   * @param {Object} target\n   * @param {number} [time=500] Time in ms\n   * @param {string} [easing='linear']\n   * @param {number} [delay=0]\n   * @param {Function} [callback]\n   * @param {Function} [forceAnimate] Prevent stop animation and callback\n   *        immediently when target values are the same as current values.\n   *\n   * @example\n   *  // Animate position\n   *  el.animateTo({\n   *      position: [10, 10]\n   *  }, function () { // done })\n   *\n   *  // Animate shape, style and position in 100ms, delayed 100ms, with cubicOut easing\n   *  el.animateTo({\n   *      shape: {\n   *          width: 500\n   *      },\n   *      style: {\n   *          fill: 'red'\n   *      }\n   *      position: [10, 10]\n   *  }, 100, 100, 'cubicOut', function () { // done })\n   */\n  // TODO Return animation key\n  animateTo: function (target, time, delay, easing, callback, forceAnimate) {\n    animateTo(this, target, time, delay, easing, callback, forceAnimate);\n  },\n\n  /**\n   * Animate from the target state to current state.\n   * The params and the return value are the same as `this.animateTo`.\n   */\n  animateFrom: function (target, time, delay, easing, callback, forceAnimate) {\n    animateTo(this, target, time, delay, easing, callback, forceAnimate, true);\n  }\n};\n\nfunction animateTo(animatable, target, time, delay, easing, callback, forceAnimate, reverse) {\n  // animateTo(target, time, easing, callback);\n  if (isString(delay)) {\n    callback = easing;\n    easing = delay;\n    delay = 0;\n  } // animateTo(target, time, delay, callback);\n  else if (isFunction(easing)) {\n      callback = easing;\n      easing = 'linear';\n      delay = 0;\n    } // animateTo(target, time, callback);\n    else if (isFunction(delay)) {\n        callback = delay;\n        delay = 0;\n      } // animateTo(target, callback)\n      else if (isFunction(time)) {\n          callback = time;\n          time = 500;\n        } // animateTo(target)\n        else if (!time) {\n            time = 500;\n          } // Stop all previous animations\n\n\n  animatable.stopAnimation();\n  animateToShallow(animatable, '', animatable, target, time, delay, reverse); // Animators may be removed immediately after start\n  // if there is nothing to animate\n\n  var animators = animatable.animators.slice();\n  var count = animators.length;\n\n  function done() {\n    count--;\n\n    if (!count) {\n      callback && callback();\n    }\n  } // No animators. This should be checked before animators[i].start(),\n  // because 'done' may be executed immediately if no need to animate.\n\n\n  if (!count) {\n    callback && callback();\n  } // Start after all animators created\n  // Incase any animator is done immediately when all animation properties are not changed\n\n\n  for (var i = 0; i < animators.length; i++) {\n    animators[i].done(done).start(easing, forceAnimate);\n  }\n}\n/**\n * @param {string} path=''\n * @param {Object} source=animatable\n * @param {Object} target\n * @param {number} [time=500]\n * @param {number} [delay=0]\n * @param {boolean} [reverse] If `true`, animate\n *        from the `target` to current state.\n *\n * @example\n *  // Animate position\n *  el._animateToShallow({\n *      position: [10, 10]\n *  })\n *\n *  // Animate shape, style and position in 100ms, delayed 100ms\n *  el._animateToShallow({\n *      shape: {\n *          width: 500\n *      },\n *      style: {\n *          fill: 'red'\n *      }\n *      position: [10, 10]\n *  }, 100, 100)\n */\n\n\nfunction animateToShallow(animatable, path, source, target, time, delay, reverse) {\n  var objShallow = {};\n  var propertyCount = 0;\n\n  for (var name in target) {\n    if (!target.hasOwnProperty(name)) {\n      continue;\n    }\n\n    if (source[name] != null) {\n      if (isObject(target[name]) && !isArrayLike(target[name])) {\n        animateToShallow(animatable, path ? path + '.' + name : name, source[name], target[name], time, delay, reverse);\n      } else {\n        if (reverse) {\n          objShallow[name] = source[name];\n          setAttrByPath(animatable, path, name, target[name]);\n        } else {\n          objShallow[name] = target[name];\n        }\n\n        propertyCount++;\n      }\n    } else if (target[name] != null && !reverse) {\n      setAttrByPath(animatable, path, name, target[name]);\n    }\n  }\n\n  if (propertyCount > 0) {\n    animatable.animate(path, false).when(time == null ? 500 : time, objShallow).delay(delay || 0);\n  }\n}\n\nfunction setAttrByPath(el, path, name, value) {\n  // Attr directly if not has property\n  // FIXME, if some property not needed for element ?\n  if (!path) {\n    el.attr(name, value);\n  } else {\n    // Only support set shape or style\n    var props = {};\n    props[path] = {};\n    props[path][name] = value;\n    el.attr(props);\n  }\n}\n\nvar _default = Animatable;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script"}